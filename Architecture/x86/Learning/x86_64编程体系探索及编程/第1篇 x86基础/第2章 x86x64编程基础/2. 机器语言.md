
**一条机器指令**由相应的**二进制数标识**，直接能**被机器识别**。在汇编语言出现之前，使用机器指令编写程序是直接将二进制数输入计算机中。

>C语言中的c=a+b在机器语言中应该怎样表达？

这是一个很麻烦的过程，a、b和c都是变量，在机器语言中应该怎样表达？**C**语言**不能**直接转换为**机器语言**，要先由C编译器译出相当的**assembly**，然后再由**assembler**生成**机器指令**，最终再由**链接器**将这些**变量的地址定下来**。

我们来看看怎样转化机器指令。首先用相应的汇编语言表达出来。

```
mov eax，[a]                ； 变量 a 的值放到 eax 寄存器中
add eax，[b]                ； 执行 a+b
mov [c]，eax                ； 放到 c 中
```

在x86机器中，如果两个内存操作数要进行加法运算，不能直接相加，其中一方必须是寄存器，至少要将一个操作数放入寄存器中。这一表达已经是最简单形式了，实际上当然不止这么简单，还要配合程序的上下文结构。如果其中一个变量只是临时性的，C编译器可能会选择不放入内存中。那么这些变量是局部变量还是外部变量呢？编译器首先要决定变量的地址。
￼
```
mov eax，[ebp-4]                ； 变量 a 是局部变量
add eax，[ebp-8]                ； 执行 a+b，变量b也是局部变量
mov [0x0000001c]，eax          ； 放到 c 中，变量c可能是外部变量
```

变量a和b是在stack上。在大多数的平台下，变量c会放入到.data节，可是在进行链接之前，c的地址可能只是一个偏移量，不是真正的地址，链接器将负责用变量c的真正地址来代替这个偏移值。

上面的汇编语言译成机器语言为

```
￼8b 45 fc                 ； 对应于  mov eax，[ebp-4]
03 45 f8                 ； 对应于  add eax，[ebp-8]
a3 1c 00 00 00         ； 对应于  mov [0x0000001c]，eax
```

x86机器是CISC（复杂指令集计算）体系，指令的长度是不固定的，比如上述前面两条指令是3字节，最后一条指令是5字节。

> x86机器指令长度最短1字节，最长15字节。

最后，假定.data节的基地址是0x00408000，那么变量c的地址就是0x00408000+0x1c=0x0040801c，经过链接后，最后一条机器指令变成

```

a3 1c 80 40 00         ； 原始汇编表达形式： mov [c]，eax
```

指令同样采用little-endian存储序列，从低到高依次存放a3 1c 80 40 00字节，其中1c 80 40 00是地址值0x0040801c的little-endian字节序排列。