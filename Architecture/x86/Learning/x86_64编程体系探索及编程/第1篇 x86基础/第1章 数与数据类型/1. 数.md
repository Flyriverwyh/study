
# 数字

>各个进制数的数字

## 二进制数字

包括0和1

## 八进制数字

包括0，1，2，3，4，5，6，7。

## 十进制数字

包括0，1，2，3，4，5，6，7，8，9。

## 十六进制数字

包括0，1，2，3，4，5，6，7，8，9及字母A，B，C，D，E，F。

## base值

**各个进制**以相应的数字表达的计数范围作为base值，如：二进制的base值是2，八进制的base值是8，十进制的base值是10，十六进制的base值是16。

# 二进制数

二进制数是**计算机运算的基础**，无论**何种制式的数**，在计算机中都是以**二进制形式存放**的。由二进制数字组成的数字序列是二进制数，如下所示。
￼
二进制数组合里，每个数位被称为bit（位），能表达值0和1。二进制数的base值是2，那么在n个二进制数字的序列中，其值为
值=（Dn-1×2n-1）+（Dn-2×2n-2）+…+（D1×21）+（D0×20）
这是一个数学上的算式。这个值是我们很容易辨识的十进制值。
1.1.3 二进制数的排列
在日常的书写或表达上，最左边的位是最高位。数的位排列从左到右，对应的值从高到低。可是在机器的数字电路上，数的高低位可以从左到右进行排列，也可以从右到左进行排列。这样就产生了MSB和LSB的概念。
什么是MSB？什么是LSB？
以一个自然的二进制表达序列上32位的二进制数为例，最右边是bit 0，最左边是bit 31。那么bit 0就用LSB（Least Significant Bit，最低有效位）来表示，bit 31就用MSB（Most Significant Bit，最高有效位）来表示。
￼
MSB也用做符号位（1为负，0为正），但若在无符号数上，则MSB就是数的最高位，LSB是数的最低位。无论一个数在机器上是从左到右排列，还是从右到左排列，使用MSB和LSB的概念都很容易对其二进制形式进行描述说明。
小端序与大端序
二进制数在计算机的组织存放中，地址由低位到高位对应着两种排列。
① 由LSB到MSB，这就是小端序（little-endian）排法。
② 由MSB到LSB，这就是大端序（big-endian）排法。
在x86/x64体系中使用的是小端序存储格式，也就是：MSB对应着存储器地址的高位，LSB对应着存储器地址的低位。
在有些RISC（精简指令集计算机）体系里，典型的如Power/PowerPC系列，使用大端序排法。即在由低到高的地址位里，依次存放MSB到LSB。亦即：MSB存放在存储器地址的低位，LSB存放在高位。
代码清单1-1：
￼ mov dword [Foo]，1￼ test byte [Foo]，1                                ； 测试 LSB 是否存放在低端上￼ jnz IS_little_endian                              ； 是小端序
上面的代码将1存放在32位的内存里，通过读取内存的低字节来判断1到底存放在低字节还是高字节，从而区分是小端序还是大端序。
某些RISC机器上是可以在大端序与小端序存储序列之间做选择的。大端序格式看上去更符合人类表达习惯，而小端序看上去不那么直观，不过这对于计算机的处理逻辑并无影响。
实验1-1：测试字节内的位排列
字节内的位是否有大端序和小端序之分？这似乎没有定论，我们不是硬件设计人员，很难做出判断。笔者倾向于认为位的排列是区分的。
从代码清单1-1我们可以测试机器是属于小端序还是大端序，原理是根据字节在内存中的存储序列进行判断。对代码稍做修改，即可用来测试位的排列，如代码清单1-2所示。
代码清单1-2（topic01\ex1-1\boot.asm）：