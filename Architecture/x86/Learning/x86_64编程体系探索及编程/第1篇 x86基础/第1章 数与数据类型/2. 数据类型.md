
# 指令处理的数据类型

在x86/x64体系中, **指令处理的数据**分为`fundamental`（基础）和`numeric`（数值）两大类。

## fundamental基础类型

- **基础类型**包括：`byte`（8位），`word`（16位），`doubleword`（32位），以及`quadword`（64位），它们代表指令能一次性处理的**数据宽度**。

## numeric数值类型

- **numeric数据类型**使用在**运算类指令**上，总结来说x86/x64体系的**运算类指令**能处理下面**四大类数据**。

    ① `integer（整型数）`：包括**unsigned类型**和**singed类型**。

    ② `floating-point（浮点数）`：包括`single-precision floating-point`（单精度浮点数），`double-precision floating-point`（双精度浮点数），以及`double extended-precision floatingpoint`（扩展双精度浮点数）。

    ③ `BCD（binary-code decmial integer）`：包括`non-packed BCD码`和`packed-BCD码`。

    ④ `SIMD（single instruction，multiple data）`：这是属于`packed类型`的数据。

SIMD数据是在一个operand（操作数）里集成了多个integer、floating-point或者BCD数据。SIMD指令可以一性次同时处理这些数据。

# integer数

在计算机处理中，**整数**会区分**signed**（`有符号数`）和**unsigned**（`无符号数`）两种情况，数值的**MSB值**被作为**符号位**。每个数值类型有自己的取值范围，如下所示。

![2020-02-09-19-49-24.png](./images/2020-02-09-19-49-24.png)
￼
可是在计算机中根本无法判断一个整数是signed数还是unsigned数。例如0ABh这个整数就无法知道它是signed数还是unsigned数。

计算机能做到的是：在整数的使用中，在应该使用signed数的场合下认为它是signed数，而在使用unsigned数的场合下认为它是unsigned数。

在这种假定下，即使不是signed数也会被当做signed数进行处理。既然这样，在计算机运算中就无须判断是signed数还是unsigned数，只需假定它是signed数或是unsigned数。

而在浮点数上，每个浮点数都有符号位，因此浮点数能够清楚地识别它就是signed数。所以浮点数不存在unsigned数的情况。

在x86机器上，对整数的加减法运算过程中不会识别signed数与unsigned数，而根据signed与unsigned两种运算结果进行相应的eflags标志位设置。

代码清单1-3：

```asm
mov eax，0x70000000￼
mov ebx，0x80000000￼
sub eax，ebx
```

上面的代码中，0x70000000和0x80000000是signed数还是unsigned数呢？
￼
二进制运算结果值是0xF0000000，指令会同时对结果进行两种分析设置。

## 为signed时

假定运算双方是signed数时，这个结果是错误的，它产生了溢出。它会置eflags寄存器的OF（Overflow Flag）标志为1，以及SF（Sign Flag）标志为1，表示结果为负数。

## 为unsigned时

假定双方是unsigned数时，它会置CF（Carry Flag）标志为1，表示产生了借位。

因此：这条指令会同时对OF、SF及CF标志置位。而对这个结果如何运用那是程序员的职责。

另外，RISC体系的机器普遍会在指令层上做假定运算，如在MIPS机器上add是进行signed数相加，addu是进行unsigned数相加，对指令进行了区分，明确了使用场合。

x86的乘法和除法指令也进行了区分，mul是无符号数乘法，imul是符号数乘法，div是无符号除法，idiv是符号数除法。另外，所有的条件转移、条件传送、条件设置指令会对指令运算的结果进行signed与unsigned的区分。

## 整数运算规则

当假定它是signed数时，这个数需要使用另一种形式去解析，这就产生了signed数的表示方法。signed的表示法是以MSB（Most Significant Bit）作为符号位，MSB为1时是负数，MSB为0时为正数。

![2020-02-09-19-56-19.png](./images/2020-02-09-19-56-19.png)
￼
以32位的数为例：0是正数的最小值，0x7FFFFFFF是正数的最大值，0x80000000是负数的最小值，0xFFFFFFFF是负数的最大值，超过这个表达范围就产生了溢出情况。

>0x7FFFFFFF+0x00000001结果为0x80000000，这个结果超过了32位正数能表达的最大值，于是就产生了溢出。两个正数相加，32位的结果为负数（负数的最小值）。这个结果是错误的。

signed数是以二进制的补码来表示，以4位二进制数为例，求出-7的二进制补码形式。

![2020-02-09-19-58-21.png](./images/2020-02-09-19-58-21.png)
￼
-7的补码形式是1001B，它的计算过程是：～7+1=-7。那么反过来，1001B这个值是多少呢？从-7的求值过程可以推出：～（（-7）-1），从而得出

![2020-02-09-19-58-36.png](./images/2020-02-09-19-58-36.png)
￼
由于1001B表达的是负数，求值后要加上负号，这就是我们所知道的十进制的signed数。

# floating-point数

现在的计算机浮点数格式都遵循IEEE754标准。在x86/x64体系中有三种浮点数。

① single-precision floating point（单精度浮点数）：使用23位的精度。

② double-precision floating point（双精度浮点数）：使用52位的精度。

③ double extended-precision floating point（扩展双精度浮点数）：使用64位的精度。

x87 FPU的硬件上使用扩展双精度浮点类型，所有浮点数最终都要转为扩展双精度浮点数进行处理（使用64位精度）。
二进制格式
在计算机上，浮点数需要换化为二进制格式进行处理，分为3个部分：sign（符号位），exponent（指数位），以及significand（有效数位），如下所示。
￼
最高位为符号位，单精度浮点数的exponent位是8位，significand位是23位；双精度浮点数的exponent位是11位，significand位是52位。
在单精度和双精度浮点数里，它们的significand部分有一个隐式的integer位（或被称为J-bit），这个位的值固定为1。因此，单精度浮点数的精度实际为24位，而双精度浮点数的精度实际为53位。
扩展双精度浮点数
在扩展双精度浮点数里，significand部分为64位，exponent为15位，如下所示。
￼
在扩展双精度浮点数里，它的integer位是显式的，在normal（合规的）数里，这个位必须为1，否则属于denormal（不合规的）数。
normalized（规格化）
在IEEE754里，规格化是浮点数的基础。正常情况下机器中的浮点数使用规格化的格式，这类浮点数被称为normal数。
看看这个浮点数：0.625，在机器中是如何表示的呢？
首先需要转化为规格化的科学计数形式。
0.625=625/1000=5/8=5/23=101×2-3=1.01×2-1
于是0.625的二进制科学计数法表达是1.01×2-1。
在IEEE 754中规定规格化数的significand（有效数）部分第1位是1，不能是0。如下所示。
￼
接下来，这个浮点数被转化为单精度的二进制形式，其值为0x3F200000。如下所示。
￼
由于单精度浮点数的significand部分含有隐式的1值，因此在二进制数格式里，significand部分的值为01000000...（即1.01中前面的1去掉）。
指数部分需要加上一个127值，这个值被称为biased notation（移码或校正值）。
biased notation（校正值）
biased notation用来解决浮点数使用integer方法进行比较时出现的问题。我们看看下面这两个浮点数大小的比较：1.00×2-1和1.00×21。
前面的指数为-1，后面的指数为1，指数大的那个必定会大。因此1.0×21的值是大于1.0×2-1的。在指数相同的情况下才需要对有效数部分进行比较。
基于这种考虑，IEEE 754在浮点数的格式中，将指数部分安排在有效数前面，这样就可以使用快速的整数比较方法来比较浮点数。
可是当指数是负数时，按照这样的比较方法，会得出比指数为正数还要大的结论，这是错误的。
1.0×2-1会比1.0×21要大！（因为：-1的二进制8位值为11111111）
为了解决这个问题，于是引入了biased notation值，如下所示。
￼
单精度的biased码是127，双精度的biased码是1023，扩展双精度的biased码是16383。这个biased码值加上指数值，就得出了一个浮点数格式中的指数值：-1+127=126，1+127=128。
算一下。
1.0×2-1的二进制序列是：001111110000000000000000000000000（0x3F000000）。
1.0×21的二进制序列是：010000000000000000000000000000000（0x40000000）。
这样就解决了在使用整数进行比较时，负的指数会比正的指数要大的问题。
在nasm汇编语言语法里，可以使用一系列的宏来获得浮点数以整数形式表现的常量值。
代码清单1-4：
￼ mov eax，__float32__（0.625）                    ； 获得浮点数的整数形式值
__float32__（0.625）这个宏的求值结果是0x3f200000，即0.625的浮点数值是0x3f200000。