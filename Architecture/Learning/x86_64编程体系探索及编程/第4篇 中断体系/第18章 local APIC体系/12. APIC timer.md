
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [简介](#简介)
- [1. APIC timer组成](#1-apic-timer组成)
- [2. LVT timer寄存器](#2-lvt-timer寄存器)
- [3. 计数模式](#3-计数模式)
    - [3.1. one-shot计数模式(一次性)](#31-one-shot计数模式一次性)
    - [3.2. Periodic计数模式(周期)](#32-periodic计数模式周期)
    - [3.3. TSC-deadline计数模式(到达TSC值)](#33-tsc-deadline计数模式到达tsc值)

<!-- /code_chunk_output -->

# 简介

使用APIC Timer的最大好处是每个cpu内核都有一个定时器（避免了定时器资源的抢占问题，你要是抢走了一个cpu核心，你就肯定抢走了一个定时器），这里的cpu内核是指和核心数，把超线程技术的那个内核也算进去了。相反的我们之前使用的PIT(Programmable Interval Timer)就不这样，PIT是共用的一个。因为这样，我们不需要考虑任何资源管理问题，我们能够很轻松的使用它（老外说话有时候很..）。但是APIC有一个比较麻烦的是，他的精度和CPU的频率有关（这里的频率指的是CPU的外频，现在主流的就是200MHz，但是有点飘，这个我在最后解释）。而PIT使用的是一个标准的频率（1193182Hz）。如果要使用APICTimer，那么你必须自己知道每秒钟能触发多少个中断。

# 1. APIC timer组成


local APIC的**timer**是非常简单易用的。它由以下**4个部分组成**。

① **LVT timer**寄存器。

② Initial\-count（**初始计数器**）寄存器。

③ Current\-count（**当前计数器**）寄存器, 只读寄存器。

④ Divide configuration（**clock频率配置**）寄存器。

Divide configuration寄存器用来**配置timer计数的时钟频率**，和time\-stamp counter一样，local APIC timer的计数器使用**固定的clock频率**，但是它可以通过Divide configuration寄存器进行具体频率的配置，如下所示。

![config](./images/62.png)

**Timer的计数频率**使用**system bus频率除以上图所列出来的值**，当配置使用除1时，将使用与**TSC（time\-stamp counter**）及**IA32\_FIXED\_CTR2计数器相同的计数频率**。这个寄存器的初始值为0，即使用system bus频率除以2的计数频率。

initial\-count与current\-count寄存器是32位寄存器，在**开始计数时**，**软件**需要在**Initial\-count（初始计数）寄存器**提供一个**非0值**的初始计数值。一旦设置初始计数值，local APIC会将**初始计数值**复制到**只读**的**current\-count（当前计数）寄存器**里。

current\-count寄存器的值开始**减1，直至为0值**。current\-count减为0时产生**timer中断**。

APIC timer支持**三种计数模式**，在LVT timer寄存器里设置。

# 2. LVT timer寄存器

LVT timer寄存器属于7个local vector table寄存器之一。

使用timer前，软件对APIC timer进行相关的编程设置，如下所示。

![config](./images/63.png)

LVT timer**只能使用Fixed delivery模式和edge触发**，并且**必须提供一个vector值**。

# 3. 计数模式

APIC定时器一般包含2-3种定时器模式，前两种（周期触发periodic和一次性触发one-shot）一般被现在所有的Local APIC所支持。但是第三种（TSC-Deadline模式）目前只在最新的CPU里面支持。

LVT timer提供了三种计数模式。

① One\-shot（一次性）计数模式。

② Periodic（定期）计数模式。

③ TSC\-deadline（达到TSC值）计数模式。

### 3.1. one-shot计数模式(一次性)

对于一次性触发模式，Local APIC中的“当前计数”寄存器的减少方式和周期触发模式一样，也是当“当前计数“寄存器的值到0的时候触发一次定时器IRQ（中断）。但是它不会自动恢复到初始计数。这样，软件必须每次都要写“初始计数”寄存器一个值来让其再一次的计时并触发IRQ。这种模式的有点事，软件可以精确地控制定时器的IRQ的发生时间。例如，系统可以根据进程的优先级来设置任务切换（一些任务使用较短的CPU时间，一些任务使用较长的CPU时间），并且不会产生任何不必要的IRQs（这句话我也不太清楚什么意思，不过大约就是可以精确地控制切换进程的时间到时IRQ产生，因为进程切换也耽误时间）。一些系统通过为计数器付值的方法去实现通用的高精度计时器服务。换个例子来说就是，有3个任务需要分别在1234ns、333ns、4444ns的时候去做，这样的话，就设定定时器显示333ns，到时中断发生时执行任务二，同时设定定时器901ns，到时中断发生时执行任务一，同时在设定定时器441111ns，定时后执行任务三（原文的英语的例子我是不理解为什么要写那么折腾了，我就简单的按上面举例了）。

缺点是，一次性触发可能会影响实时性（因为在设置的时候会耽误一些，导致的不确定性），并且还需要为了避免竞争，维护新的计数值和老的计数值。



在one\-shot模式里，当current\-count的值减为0时，产生**timer中断**，**current\-count的值维持在0不变**，除非**写入新的initial\-count值**。

```assembly
； 设置 LVT timer
       mov DWORD [APIC_BASE + LVT_TIMER]，TIMER_ONE_SHOT | APIC_TIMER_VECTOR
； 写入 initial-count 值
       mov DWORD [APIC_BASE + TIMER_ICR]，256
```

上面的代码向**LVT timer寄存器**写入设置的值使用了one\-shot模式。

**initial\-count寄存器**被写入256值。一旦写入initial\-count值，APIC timer就开始计数。

### 3.2. Periodic计数模式(周期)

周期触发模式中，程序设置一个”初始计数“寄存器（Initial Count），同时Local APIC会将这个数复制到”当前计数“寄存器（Current Count）。Local APIC会将这个数（当前计数）递减，直到减到0为止，这时候将触发一个IRQ（可以理解为触发一次中断），与此同时将当前计数恢复到初始计数寄存器的值，然后周而复始的执行上述逻辑。可以使用这种方法通过Local APIC实现定时按照一定时间间隔触发中断的功能。”当前计数“寄存器中的值的递减速度依赖于当前CPU的主频除以一个叫做”分频寄存器“（“Divide Configuration Register”）的值（换个思路来说就是，多少个tick减少1）。

举例来说，对于一个2.4GHz的CPU使用的CPU总线频率是800MHz（大家说的外频800MHz)，”分频寄存器“（“Divide Configuration Register”）设置的是“除四”（”divide by 4“），并且初始计数（initial count）设置到123456。那么结果就是当前计数（current count）每200M分之1秒减1，大约617.28us触发一个irq(一次中断)，也就是1620.01Hz。




使用**periodic**计数模式，当**current\-count**减为**0**时，产生**timer中断**。

local APIC将在**current\-count寄存器**里装入**initial\-count**值**重新开始计数！！！**，从而**周期性**地产生timer中断，除非**写入0值**到initial\-count寄存器里。

```x86asm
； 设置 LVT timer
       mov DWORD [APIC_BASE + LVT_TIMER]，0x00020030  ； 使用periodic 模式
； 写入 initial-count 值
       mov DWORD [APIC_BASE + TIMER_ICR]，0xff
```

当写入新的initial\-count值时，local APIC将重新装入新的initial\-count值进行计数。

### 3.3. TSC-deadline计数模式(到达TSC值)

TSC-Deadline模式同上述两种模式有很大的区别。触发方式发生了区别，上述两种方式是基于**当前计数减少到0触发**的，而TSC-Deadline模式是软件设置了一个”deadline“，然后当CPU的时间戳大于或等于”deadline“的时候触发一次IRQ。

尽管存在如上的差异，软件可能会将它用于替代一次性触发模式，相比于一次性触发模式，这样可以得到更高的精度（因为时间戳的生成时CPU的时钟，而不是CPU总线频率），并且它更容易处理资源竞争（最后这句话我真不太理解）。



当`CPUID.01：ECX[24]`为**1**时，APIC timer允许使用TSC\-deadline计数模式。

在**TSC\-deadline计数模式**里，**initial\-count**寄存器**被忽略**，current\-count寄存器**读出来为0**。

`IA32_TSC_DEADLINE`寄存器设置一个**目标的TSC（time\-stamp counter）值**。

软件向64位的`IA32_TSC_DEADLINE`寄存器写入**非0**值时，**APIC timer**开始计数。

当**TSC（Time Stamp Counter**）值**大于或等于**IA32\_TSC\_DEADLINE寄存器的值时，将产生timer中断。

TSC见`15.6`.

```assembly
； 测试是否支持APIC timer TSC-deadline模式
       mov eax，1
       cupid
       bt ecx，24       ； TSC-deadline 位
       jnc no_support
； 设置 TSC-deadline 模式
       mov DWORD [APIC_BASE + LVT_TIMER]，0x00040030
； 写入目标TSC值
       rdtsc        ； 读当前 TSC 值
       mov ecx，IA32_TSC_DEADLINE
       add eax，256      ； current_TSC + 256
       wrmsr        ； 写入目标TSC值
       ；；
no_support：
       ； … …
```
上面代码显示，当处理器支持TSC\-deadline计数模式时，将LVT timer寄存器设置为TSC-deadline模式，软件通过读取当前的TSC值，将目标TSC值设置为当前的TSC值加上256。

当往IA32\_TSC\_DEADLINE寄存器写入0时，将停止APIC timer的运作。

>实验18-11：测试APIC timer的one-shot模式

在这个实验里，简单地使用APIC timer中断，在APIC timer中断处理程序里打印出所有local APIC寄存器的信息。实验的源码在topic18\ex18-11\protected.asm文件里，请读者自行阅读。

![config](./images/64.png)

上面是在Bochs里的运行结果，产生timer中断时在处理程序里打印出local APIC寄存器的相关信息：APIC timer使用30h中断向量号，initial\-count寄存器被设置为0x00000100值。