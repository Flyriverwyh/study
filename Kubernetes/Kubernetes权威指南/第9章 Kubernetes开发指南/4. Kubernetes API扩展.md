
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 概述](#1-概述)
  - [1.1. 背景需求](#11-背景需求)
  - [1.2. API机制](#12-api机制)
  - [1.3. 两种API扩展机制](#13-两种api扩展机制)
- [2. 使用CRD扩展API资源](#2-使用crd扩展api资源)
  - [创建CRD的定义](#创建crd的定义)

<!-- /code_chunk_output -->

# 1. 概述

## 1.1. 背景需求

随着Kubernetes的发展，用户对Kubernetes的扩展性也提出了越来越高的要求。

从**1.7版本**开始，Kubernetes引入**扩展API资源的能力**，使得开发人员在**不修改Kubernetes核心代码**的前提下可以**对Kubernetes API进行扩展**，仍然使用Kubernetes的语法对**新增的API**进行操作，这非常适用于在Kubernetes上通过其API实现**其他功能**（例如**第三方性能指标采集服务**）或者**测试实验性新特性**（例如**外部设备驱动**）。

## 1.2. API机制

* 资源对象的抽象和访问入口: 在Kubernetes中，**所有对象**都被抽象定义为**某种资源对象**，同时系统会为其设置一个**API入口（API Endpoint**），**对资源对象的操作**（如新增、删除、修改、查看等）都需要通过**Master**的**核心组件API Server调用资源对象的API**来完成。

* 交互方式: **与API Server的交互**可以通过**kubectl命令行工具**或**访问其RESTful API**进行。

* API的不同版本: **每个API**都可以设置**多个版本**，在**不同的API URL路径**下区分，例如“/api/v1”或“/apis/extensions/v1beta1”等。

使用这种机制后，用户可以很方便地**定义这些API资源对象（YAML配置**），并将其**提交给Kubernetes（调用RESTful API**），来完成对容器应用的各种管理工作。

## 1.3. 两种API扩展机制

Kubernetes系统内置的Pod、RC、Service、ConfigMap、Volume等资源对象已经能够满足常见的容器应用管理要求，但如果用户希望将其自行开发的第三方系统纳入Kubernetes，并使用Kubernetes的API对其自定义的功能或配置进行管理，就需要对API进行扩展了。

目前Kubernetes提供了以下两种机制供用户扩展API。

（1）**使用CRD机制**：**复用Kubernetes的API Server**，**无须编写额外的API Server**。用户**只需要定义CRD**，并且提供一个**CRD控制器**，就能通过Kubernetes的API管理自定义资源对象了，同时要求**用户的CRD对象符合API Server的管理规范**。

（2）使用**API聚合机制**：用户需要**编写额外的API Server**，可以对资源进行**更细粒度的控制**（例如，如何在各API版本之间切换），要求用户自行处理对多个API版本的支持。

本节主要对CRD和API聚合这两种API扩展机制的概念和用法进行详细说明。

# 2. 使用CRD扩展API资源

CRD是Kubernetes从**1.7版本**开始引入的特性，在Kubernetes**早期版本**中被称为**TPR**（**ThirdPartyResources**，第三方资源）。TPR从Kubernetes 1.8版本开始被停用，被CRD全面替换。

CRD本身**只是一段声明**，用于**定义用户自定义的资源对象**。但**仅有CRD的定义**并没有实际作用，用户还需要提供**管理CRD对象的CRD控制器**（CRD Controller），才能实现**对CRD对象的管理**。

**CRD控制器**通常可以通过Go语言进行开发，并需要**遵循Kubernetes的控制器开发规范**，基于**客户端库client\-go**进行开发，需要实现**Informer**、**ResourceEventHandler**、**Workqueue**等组件**具体的功能处理逻辑**，详细的开发过程请参考**官方示例**（ https://github.com/kubernetes/sample-controller ）和**client\-go库**（ https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md ）的详细说明。

## 创建CRD的定义

与其他资源对象一样，对CRD的定义也使用**YAML配置**进行声明。以**Istio系统**中的**自定义资源VirtualService**为例，配置文件crd\-virtualservice.yaml的内容如下：

```yaml
---
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: virtualservices.networking.istio.io # 关键
  annotations:
    "helm.sh/hook": crd-install
  labels:
    app: istio-pilot
spec:
  group: networking.istio.io        # 关键 往下 ↓
  scope: Namespaced                 
  versions:                         
  - name: v1alpha3
    served: true
    storage: true
  names:
    kind: VirtualService
    listKind: VirtualServiceList
    singular: virtualservice
    plural: virtualservices
    categories:
    - istio-io
    - networking-istio-io           # 关键 往上 ↑     
```

CRD定义中的**关键字段**如下。

（1）**group**：设置API所属的组，将其映射为API URL中“/apis/”的下一级目录，设置networking.istio.io生成的API URL路径为“/apis/networking.istio.io”。

（2）scope：该API的生效范围，可选项为Namespaced（由Namespace限定）和Cluster（在集群范围全局生效，不局限于任何Namespace），默认值为Namespaced。

（3）versions：设置此CRD支持的版本，可以设置多个版本，用列表形式表示。目前还可以设置名为version的字段，只能设置一个版本，在将来的Kubernetes版本中会被弃用，建议使用versions进行设置。如果该CRD支持多个版本，则每个版本都会在API URL“/apis/networking.istio.io”的下一级进行体现，例如“/apis/networking.istio.io/v1”或“/apis/networking.istio.io/v1alpha3”等。每个版本都可以设置下列参数。

* name：版本的名称，例如v1、v1alpha3等。
* served：是否启用，在被设置为true时表示启用。
* storage：是否进行存储，只能有一个版本被设置为true。

（4）names：CRD的名称，包括单数、复数、kind、所属组等名称的定义，可以设置如下参数。

* kind：CRD的资源类型名称，要求以驼峰式命名规范进行命名（单词的首字母都大写），例如VirtualService。
* listKind：CRD列表，默认被设置为<kind>List格式，例如VirtualServiceList。
* singular：单数形式的名称，要求全部小写，例如virtualservice。
* plural：复数形式的名称，要求全部小写，例如virtualservices。
* shortNames：缩写形式的名称，要求全部小写，例如vs。
* categories：CRD所属的资源组列表。例如，VirtualService属于istio-io组和networking-istio-io组，用户通过查询istio-io组和networking-istio-io组，也可以查询到该CRD实例。

使用kubectl create命令完成CRD的创建：
