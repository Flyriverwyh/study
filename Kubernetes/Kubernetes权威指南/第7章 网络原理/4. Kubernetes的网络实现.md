
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [容器到容器的通信](#容器到容器的通信)
- [Pod之间的通信](#pod之间的通信)

<!-- /code_chunk_output -->

在实际的业务场景中，业务组件之间的关系十分复杂，特别是随着微服务理念逐步深入人心，应用部署的粒度更加细小和灵活。为了支持业务应用组件的通信，**Kubernetes网络的设计**主要致力于解决以下问题。

（1）**容器到容器之间的直接通信**。

（2）**抽象的Pod到Pod之间的通信**。

（3）**Pod到Service之间的通信**。

（4）**集群外部**与**内部组件之间的通信**。

其中第3条、第4条在之前的章节里都有所讲解，本节对更为基础的第1条与第2条进行深入分析和讲解。

# 容器到容器的通信

**同一个Pod**内的**容器**（**Pod内的容器是不会跨宿主机的！！！**）共享**同一个网络命名空间**，共享**同一个Linux协议栈**。所以对于网络的各类操作，就和它们在同一台机器上一样，它们甚至可以用**localhost地址**访问彼此的**端口**。

这么做的结果是简单、安全和高效，也能减小将已经存在的程序从物理机或者虚拟机移植到容器下运行的难度。其实，在**容器技术出来之前**，大家早就积累了如何在**一台机器上**运行一组应用程序的经验，例如，**如何让端口不冲突**，以及**如何让客户端发现它们**等。

我们来看一下**Kubernetes**是**如何利用Docker的网络模型**的。

如图7.8中的阴影部分所示，在Node上运行着一个Pod实例。在我们的例子中，容器就是图7.8中的容器1和容器2。**容器1**和**容器2**共享**一个网络的命名空间**，**共享一个命名空间**的结果就是它们好像**在一台机器上运行**，它们打开的端口不会有冲突，可以直接使用Linux的**本地IPC进行通信**（例如**消息队列**或者**管道**）。其实，这和传统的一组普通程序运行的环境是完全一样的，**传统程序不需要针对网络做特别的修改就可以移植**了，它们之间的互相访问只需要使用localhost就可以。例如，如果容器2运行的是MySQL，那么容器1使用localhost:3306就能直接访问这个运行在容器2上的MySQL了。

![2019-09-19-16-44-39.png](./images/2019-09-19-16-44-39.png)

# Pod之间的通信

