
以下各节介绍了AVIC的架构。

# 虚拟LAPIC

Virtualizing the Local APIC

**guest虚拟处理器**通过读写位于**guest物理地址空间**中**4KB页面**中的**一组寄存器**来访问其LAPIC的功能。**AVIC硬件**通过将guest的尝试访问**重定向**到位于**系统物理地址**（System physical address, SPA）空间中的**vAPIC backing页面**来虚拟化此访问。

注: guest肯定访问的是guest自己的地址空间, 这里对lapic的访问使用的是物理地址, 所以是guest物理地址, 但是最终还是会落到真实的物理地址, 这部分也就是AVIC的工作.

**AVIC硬件**检测到**guest对其LAPIC寄存器集**的尝试**访问**，并将这些访问**重定向到vAPIC backing页面**。如下图所示。

![2020-09-07-09-37-12.png](./images/2020-09-07-09-37-12.png)

要将**虚拟机vAPIC寄存器的guest访问**正确重定向到vAPIC backing页面，该硬件需要**两个地址**。 这些是：
* **系统物理地址(SPA)空间**中的**vAPIC backing页面地址**
* **虚拟机物理地址(GPA)空间**中的**guest vAPIC基址**(APIC BAR)

**系统软件**负责在**嵌套页面表**(nested page table)中**设置转换关系**，以授予**guest读写**访问**SPA空间**中**vAPIC backing页面**的权限。AVIC硬件walks nested page table(嵌套页面表)以**检查权限**，但**不使用**在**叶子页表条目**中指定的**SPA地址**。而是，AVIC硬件在**VMCB**的`AVIC_BACKING_PAGE`指针字段中找到此地址。

VMM使用适当的**默认APIC寄存器值**（包括诸如**APIC版本号**之类的项目）初始化backing页面。vAPIC backing页面地址和guest vAPIC基址分别存储在VMCB字段`AVIC_BACKING_PAGE`**指针**和`V_APIC_BAR`中。

系统固件将**guest vAPIC基址**（和`VMCB.V_APIC_BAR`）的值初始化为`FEE0_0000h`。 **guest操作系统**在**引导**时希望在**此地址**找到**LAPIC寄存器集**。

如果**guest**尝试通过**写入APIC基址寄存器**（MSR `0000_001Bh`）来在**GPA空间**中**重新定位LAPIC寄存器基址**，则VMM应该**拦截该写操作**，以更新**guest VMCB**的`V_APIC_BAR`字段和虚拟机**嵌套页表**的**translation**中**GPA部分**内容。

在**guestVM的整个生命周期**中，vAPIC backing页必须存在于**系统物理内存**中，因为即使guest未运行，**某些字段也会更新**。

虚拟APIC寄存器访问(Virtual APIC Register Accesses)。AVIC硬件检测到guest尝试访问backing页中的vAPI寄存器。这些尝试的访问由**寄存器级权限过滤器**(register-level permissions filter)处理, 使用下列三种方式之一处理：
* 允许(Allow). 允许完成对backing页面的访问。 **写入**将更新backing页面值，而**读取**将返回**当前值**。 在某些情况下，写操作会导致特定的基于硬件的加速操作（在表15-22中进行了汇总，并在下面进行了介绍）。
* 故障(Fault)
* 陷阱(Trap)