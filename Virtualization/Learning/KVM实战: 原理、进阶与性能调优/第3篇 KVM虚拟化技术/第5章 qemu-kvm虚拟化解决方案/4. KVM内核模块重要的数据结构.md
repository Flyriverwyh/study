
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. KVM结构体](#1-kvm结构体)
- [2. kvm_vcpu结构体](#2-kvm_vcpu结构体)
- [3. kvm_run结构体](#3-kvm_run结构体)
- [4. 结构体之间的关系](#4-结构体之间的关系)
- [5. kvm_x86_ops结构体](#5-kvm_x86_ops结构体)
- [6. KVM API中重要的结构体](#6-kvm-api中重要的结构体)
  - [6.1. kvm_chardev_ops](#61-kvm_chardev_ops)
  - [6.2. kvm_vm_fops](#62-kvm_vm_fops)
  - [6.3. kvm_vcpu_fops](#63-kvm_vcpu_fops)

<!-- /code_chunk_output -->

# 1. KVM结构体

**KVM 结构体**在 KVM 的系统架构中**代表一个具体的虚拟机**。

当通过**VM\_CREATE\_KVM！！！指令字**创建一个新的 KVM 虚拟机之后，就会**创建一个新的KVM结构体对象**。

```cpp
// include/linux/kvm_host.h
struct kvm {
	spinlock_t mmu_lock;
	struct mutex slots_lock;
	struct mm_struct *mm; /* userspace tied to this vm */
	struct kvm_memslots *memslots[KVM_ADDRESS_SPACE_NUM];
	struct srcu_struct srcu;
	struct srcu_struct irq_srcu;
	struct kvm_vcpu *vcpus[KVM_MAX_VCPUS];

	/*
	 * created_vcpus is protected by kvm->lock, and is incremented
	 * at the beginning of KVM_CREATE_VCPU.  online_vcpus is only
	 * incremented after storing the kvm_vcpu pointer in vcpus,
	 * and is accessed atomically.
	 */
	atomic_t online_vcpus;
	int created_vcpus;
	int last_boosted_vcpu;
	struct list_head vm_list;
	struct mutex lock;
	struct kvm_io_bus *buses[KVM_NR_BUSES];
#ifdef CONFIG_HAVE_KVM_EVENTFD
	struct {
		spinlock_t        lock;
		struct list_head  items;
		struct list_head  resampler_list;
		struct mutex      resampler_lock;
	} irqfds;
	struct list_head ioeventfds;
#endif
	struct kvm_vm_stat stat;
	struct kvm_arch arch;
	atomic_t users_count;
#ifdef KVM_COALESCED_MMIO_PAGE_OFFSET
	struct kvm_coalesced_mmio_ring *coalesced_mmio_ring;
	spinlock_t ring_lock;
	struct list_head coalesced_zones;
#endif

	struct mutex irq_lock;
#ifdef CONFIG_HAVE_KVM_IRQCHIP
	/*
	 * Update side is protected by irq_lock.
	 */
	struct kvm_irq_routing_table __rcu *irq_routing;
#endif
#ifdef CONFIG_HAVE_KVM_IRQFD
	struct hlist_head irq_ack_notifier_list;
#endif

#if defined(CONFIG_MMU_NOTIFIER) && defined(KVM_ARCH_WANT_MMU_NOTIFIER)
	struct mmu_notifier mmu_notifier;
	unsigned long mmu_notifier_seq;
	long mmu_notifier_count;
#endif
	long tlbs_dirty;
	struct list_head devices;
	struct dentry *debugfs_dentry;
	struct kvm_stat_data **debugfs_stat_data;
};
```

**KVM结构体对象**中包含了**vCPU**、**内存**、**APIC**、**IRQ**、**MMU**、**Event事件管理**等信息。

该结构体中的信息主要在 **KVM 虚拟机内部！！！使用**，用于**跟踪虚拟机的状态**。

在定义 KVM 结构体的**结构成员**的过程中，集成了**很多编译开关**，这些开关对应了 KVM 体系中的不同功能点。

在 KVM 中，连接了如下几个重要的结构体成员，它们对虚拟机的运行有重要的作用。

* `struct kvm_memslots *memslots`;

KVM虚拟机所分配到的**内存slot**，

以**数组形式**存储这些**slot的地址信息**。用于GPA转成HVA, 内存虚拟化.

* `struct kvm_vcpu *vcpus[KVM_MAX_VCPUS]`;

KVM虚拟机中包含的**vCPU结构体**，

**一个虚拟CPU**对应**一个vCPU结构体**。

* `struct list_head vm_list;`

Host上的VM管理链表

* `struct kvm_io_bus *buses[KVM_NR_BUSES]`;

KVM虚拟机中的**I/O总线**

**一条总线**对应一个**kvm\_io\_bus结构体**，如**ISA总线**、**PCI总线**。

* `struct kvm_vm_stat stat`;

虚拟机运行时状态信息

KVM虚拟机中的**页表**、**MMU**等**运行时状态信息**。

* `struct kvm_arch arch`;

KVM 的软件 **arch** 方面所需要的一些参数，

将在后文讨论 KVM 的实现机理时详细叙述。

# 2. kvm_vcpu结构体

在用户通过**KVM\_CREATE\_VCPU**系统调用请求创建vCPU之后，**KVM子模块**将创建kvm\_vcpu结构体并进行相应的初始化操作，然后返回**对应的vcpu\_fd描述符**。

在KVM的**内部虚拟机调度！！！** 中，以**kvm\_vcpu**和**KVM中的相关数据**进行操作。

kvm\_vcpu结构体中的字段较多，其中重要的成员如下。

```cpp
// include/linux/kvm_host.h
struct kvm_vcpu
```

* `struct kvm *kvm;`

归属的kvm

* `int vcpu_id`;

对应的VCPU的ID。

* `struct kvm_run *run;`

vCPU 的**运行时参数**，即运行时的状态

其中保存了**寄存器信息**、**内存信息**、**虚拟机状态**等各种**动态信息**。

* `struct kvm_vcpu_arch arch;`

当前VCPU虚拟的架构信息.

存储有 KVM **虚拟机**的**运行时参数**，如**定时器**、**中断**、**内存槽**等方面的信息。

另外，kvm\_cpu中还包含了执行**iomem**所需要的数据结构，用于处理**iomem方面**的请求。

# 3. kvm_run结构体

vcpu的运行状态, 比如VM-Exit原因等

```cpp
// include/uapi/linux/kvm.h
struct kvm_run {
	/* in */
	__u8 request_interrupt_window;
	__u8 immediate_exit;
	__u8 padding1[6];

	/* out */
	__u32 exit_reason;
	__u8 ready_for_interrupt_injection;
	__u8 if_flag;
	__u16 flags;

	/* in (pre_kvm_run), out (post_kvm_run) */
	__u64 cr8;
	__u64 apic_base;

	union {
		/* KVM_EXIT_UNKNOWN */
		struct {
			__u64 hardware_exit_reason;
		} hw;
		/* KVM_EXIT_FAIL_ENTRY */
		struct {
			__u64 hardware_entry_failure_reason;
		} fail_entry;
		/* KVM_EXIT_EXCEPTION */
		struct {
			__u32 exception;
			__u32 error_code;
		} ex;
		/* KVM_EXIT_IO */
		struct {
#define KVM_EXIT_IO_IN  0
#define KVM_EXIT_IO_OUT 1
			__u8 direction;
			__u8 size; /* bytes */
			__u16 port;
			__u32 count;
			__u64 data_offset; /* relative to kvm_run start */
		} io; // IO操作导致发生vm-exit时, 在这里保存IO相关信息
		/* KVM_EXIT_DEBUG */
		struct {
			struct kvm_debug_exit_arch arch;
		} debug;
		/* KVM_EXIT_MMIO */
		struct {
			__u64 phys_addr;
			__u8  data[8];
			__u32 len;
			__u8  is_write;
		} mmio;
		/* KVM_EXIT_HYPERCALL */
		struct {
			__u64 nr;
			__u64 args[6];
			__u64 ret;
			__u32 longmode;
			__u32 pad;
		} hypercall;
		/* KVM_EXIT_TPR_ACCESS */
		struct {
			__u64 rip;
			__u32 is_write;
			__u32 pad;
		} tpr_access;
		/* KVM_EXIT_DCR (deprecated) */
		struct {
			__u32 dcrn;
			__u32 data;
			__u8  is_write;
		} dcr;
		/* KVM_EXIT_INTERNAL_ERROR */
		struct {
			__u32 suberror;
			/* Available with KVM_CAP_INTERNAL_ERROR_DATA: */
			__u32 ndata;
			__u64 data[16];
		} internal;
		/* KVM_EXIT_OSI */
		struct {
			__u64 gprs[32];
		} osi;
		/* KVM_EXIT_PAPR_HCALL */
		struct {
			__u64 nr;
			__u64 ret;
			__u64 args[9];
		} papr_hcall;
		/* KVM_EXIT_EPR */
		struct {
			__u32 epr;
		} epr;
		/* KVM_EXIT_SYSTEM_EVENT */
		struct {
#define KVM_SYSTEM_EVENT_SHUTDOWN       1
#define KVM_SYSTEM_EVENT_RESET          2
#define KVM_SYSTEM_EVENT_CRASH          3
			__u32 type;
			__u64 flags;
		} system_event;
		/* KVM_EXIT_IOAPIC_EOI */
		struct {
			__u8 vector;
		} eoi;
		/* KVM_EXIT_HYPERV */
		struct kvm_hyperv_exit hyperv;
		/* Fix the size of the union. */
		char padding[256];
	};

	/* 2048 is the size of the char array used to bound/pad the size
	 * of the union that holds sync regs.
	 */
	#define SYNC_REGS_SIZE_BYTES 2048
	/*
	 * shared registers between kvm and userspace.
	 * kvm_valid_regs specifies the register classes set by the host
	 * kvm_dirty_regs specified the register classes dirtied by userspace
	 * struct kvm_sync_regs is architecture specific, as well as the
	 * bits for kvm_valid_regs and kvm_dirty_regs
	 */
	__u64 kvm_valid_regs;
	__u64 kvm_dirty_regs;
	union {
		struct kvm_sync_regs regs;
		char padding[SYNC_REGS_SIZE_BYTES];
	} s;
};
```

* `__u8 request_interrupt_window;`

向VCPU注入一个中断，让VCPU做好相关准备工作

* `__u8 ready_for_interrupt_injection;`

响应request_interrupt_window的中断请求，当设置时，说明VCPU可以接收中断。

* `__u8 if_flag;`

中断使能标识，如果使用了APIC，则无效

# 4. 结构体之间的关系

先看下相关结构体的相关部分

```cpp
// include/linux/kvm_host.h
struct kvm
{
    struct kvm_vcpu *vcpus[KVM_MAX_VCPUS];
    struct list_head vm_list; // 用于挂到全局vm_list列表
    struct kvm_arch arch; // 平台相关
}
```

`struct kvm`代表一个虚拟机, 包含多个vcpu

```cpp
// include/linux/kvm_host.h
struct kvm_vcpu {
	int cpu;    /*运行当前VCPU的物理CPU编号*/
}
```

`struct kvm_vcpu`代表一个vCPU, 同一个时刻只能对应一个物理CPU

```cpp
// arch/x86/kvm/vmx/vmx.h
struct vcpu_vmx {
	struct kvm_vcpu       vcpu;
	/*
	 * loaded_vmcs points to the VMCS currently used in this vcpu. For a
	 * non-nested (L1) guest, it always points to vmcs01. For a nested
	 * guest (L2), it points to a different VMCS.
	 */
	struct loaded_vmcs    vmcs01;
	struct loaded_vmcs   *loaded_vmcs;
}
```

`struct vcpu_vmx`代表vcpu的一个运行环境, `loaded_vmcs`指向当前vcpu使用的vmcs. 对于非嵌套(即L1)虚拟机, `loaded_vmcs`一直指向`vmcs01`, 对于嵌套(L2), 指向另外的vmcs.

```cpp
// arch/x86/kvm/vmx/vmcs.h
struct loaded_vmcs {
	struct vmcs *vmcs;  /*本VCPU对应的VMCS*/
	int cpu;            /*上一次运行的CPU编号*/
	int launched;
	struct list_head loaded_vmcss_on_cpu_link;
};
```

`vcpu_vmx`其实是**VCPU**的**一个运行环境**，理解为environment。通过**loaded\_vmcs**和**vcpu**成员将**vmcs**和**CPU**关联起来。

**一个VCPU**当然可以运行在**不同的物理CPU**之上，只要更换`loaded_vmcs`中**cpu编号**即可；

但是为什么会**一个VCPU**对应**多个不同的VMCS**呢？其实是因为**嵌套虚拟化**的原因，当**L2虚拟机**的**VCPU加载**后，**VCPU**所使用的**VMCS不是L1层的VMCS**；而是L2层的VMCS；其实就是把L1的VCPU在L2中当做了物理CPU用，物理CPU当然可以有多个VMCS了。

![2019-12-18-16-51-15.png](./images/2019-12-18-16-51-15.png)

一般L1中，loaded_vmcs就执行vmcs01，当VCPU运行的物理CPU发生切换的时候，修改loaded_vmcs中的cpu成员即可

```cpp
static struct kvm_vcpu *vmx_create_vcpu(struct kvm *kvm, unsigned int id)
{
 
    /*vmcs的分配*/
	vmx->loaded_vmcs = &vmx->vmcs01;
	vmx->loaded_vmcs->vmcs = alloc_vmcs();
 
}
```

在L2中，loaded_vmcs会在L1 VMCS和各个L2 VMCS之间切换，那么就需要修改loaded_vmcs指针的指向

```cpp
static int nested_vmx_run(struct kvm_vcpu *vcpu, bool launch)
{
	cpu = get_cpu();
	vmx->loaded_vmcs = vmcs02;
	vmx_vcpu_put(vcpu);
	vmx_vcpu_load(vcpu, cpu);
	vcpu->cpu = cpu;
	put_cpu();
}
```

# 5. kvm_x86_ops结构体

kvm\_x86\_ops结构体中包含了针对**具体的CPU架构**进行**虚拟化时**的**函数指针调用**，其定义在Linux内核文件的`arch/x86/include/asm/kvm_host.h`中。

该结构体主要包含 。

- **CPU VMM状态硬件初始化**。
- **vCPU创建与管理**。
- **中断管理**。
- **寄存器管理**。
- **时钟管理**。

kvm\_x86\_ops 结构体中的所有成员都是**函数指针**，在 kvm\-intel.ko 和kvm\-amd.ko这两个**不同的模块**中，针对**各自的体系**提供了**不同的函数**。在KVM的初始化过程和后续的运行过程中，KVM 子系统的代码将通过该结构体的函数进行**实际的硬件操作**。

kvm\_x86\_ops结构体通过**静态初始化**。

- 针对**amd架构**的初始化代码在**svm.c**中，
- 针对**Intel架构**的初始化代码在**vmx.c**中。

amd架构的kvm\_x86\_ops结构体部分代码列举如下。

代码5\-2 **svm.c**中的**kvm\_x86\_ops**初始化代码片段

```cpp
// arch/x86/kvm/svm.c
(01)static struct kvm_x86_ops svm_x86_ops = {￼
(02)     .cpu_has_kvm_support = has_svm,￼
(03)     .disabled_by_bios = is_disabled,￼
(04)     .hardware_setup = svm_hardware_setup,￼
(05)     .hardware_unsetup = svm_hardware_unsetup,￼
(06)     .check_processor_compatibility = svm_check_processor_compat,￼
(07)     .hardware_enable = svm_hardware_enable,￼
(08)     .hardware_disable = svm_hardware_disable,￼
(09)     .cpu_has_accelerated_tpr = svm_cpu_has_accelerated_tpr,￼
(10) ……
```

需要注意的是，因为KVM架构要同时考虑到支持**不同的架构体系**。因此，**kvm\_x86\_ops结构体**是在**KVM架构的初始化！！！** 过程中**注册**并**导出成为全局变量！！！**，让KVM的各个子模块能够方便地调用。

在 **arch/x86/kvm/x86.c** 中，定义了名为 **kvm\_x86\_ops** 的**静态变量**，通过**export\_symbol 宏**在**全局范围！！！**内导出。

```cpp
// arch/x86/kvm/x86.c
struct kvm_x86_ops *kvm_x86_ops __read_mostly;
EXPORT_SYMBOL_GPL(kvm_x86_ops);
```

在 **kvm\_init** 的**初始化过程**中，通过**调用kvm\_arch\_init**函数给**kvm\_x86\_ops**赋值，代码如下，其中，ops就是通过**svm.c**调用**kvm\_init**函数时传入的**kvm\_x86\_ops结构体**。

代码5\-3 kvm\_x86\_ops赋值

```cpp
// arch/x86/kvm/x86.c
￼(4652)        kvm_init_msr_list();￼
(4653)￼
(4654)        kvm_x86_ops = ops;￼
(4655)        kvm_mmu_set_nonpresent_ptes(0ull, 0ull);￼
(4656)        kvm_mmu_set_base_ptes(PT_PRESENT_MASK);
```

有关该结构的各个成员的详细说明，将在后文针对 KVM 的初始化和其他关键过程的分析过程中进行详细阐述。

# 6. KVM API中重要的结构体

**KVM** 在和**用户态程序**进行**交互的过程**中，**主要**通过/**dev/kvm 设备文件**进行通信。

从后文的 **KVM的初始化**过程中可以得知，/**dev/kvm**是一个**字符型设备**，通过符合**Linux标准**的**一系列结构体**进行支撑，主要是**kvm\_chardev\_ops**、**kvm\_vm\_fops**、**kvm\_vcpu\_fops**，分别对应**字符型设备**、**VM文件描述符**和**vCPU文件描述符**的三种操作。

## 6.1. kvm_chardev_ops

**kvm\_chardev\_ops**的定义在**virt/kvm/kvm\_main.c**中，代码如下：

在模块初始化的`kvm_init()`调用了`misc_register(&kvm_dev)`注册`/dev/kvm`设备文件.

下面是设备文件的结构体

```cpp
// virt/kvm/kvm_main.c
static struct file_operations kvm_chardev_ops = {
    .unlocked_ioctl = kvm_dev_ioctl,
    .llseek         = noop_llseek,
    KVM_COMPAT(kvm_dev_ioctl),
};
static struct miscdevice kvm_dev = {
    KVM_MINOR,
    "kvm",
    &kvm_chardev_ops,
};
```

代码5\-4 kvm\_chardev\_ops
￼
```cpp
// virt/kvm/kvm_main.c
(1913)   static struct file_operations kvm_chardev_ops = {￼
(1914)        .unlocked_ioctl = kvm_dev_ioctl,￼
(1915)        .compat_ioctl   = kvm_dev_ioctl,￼
(1916)        .llseek       = noop_llseek,￼
(1917)   };
```

kvm\_chardev\_ops为一个标准的**file\_operations结构体**，但是只包含了**ioctl函数**，**read**、**open**、**write**等常见的**系统调用**均采用**默认实现**。因此，就**只能**在**用户态**通过**ioctl函数**进行操作。

## 6.2. kvm_vm_fops

如前文所述，通过**KVM\_CREATE\_VM**之后可以获得一个**fd文件描述符**，代表**该VM**，该fd文件描述符在**KVM子模块**内部操作实际上对应着**kvm\_vm\_fops结构体**，其主要内容如下。

代码5\-5 kvm\_vm\_fops结构体

```cpp
// virt/kvm/kvm_main.c
(1815)   static struct file_operations kvm_vm_fops = {￼
(1816)        .release       = kvm_vm_release,￼
(1817)        .unlocked_ioctl = kvm_vm_ioctl,￼ // vmfd的ioctl接口，提供对vm级别的控制
(1818)   #ifdef CONFIG_COMPAT￼
(1819)        .compat_ioctl   = kvm_vm_compat_ioctl,￼
(1820)   #endif￼
(1821)        .mmap          = kvm_vm_mmap,￼
(1822)        .llseek       = noop_llseek,￼
(1823)   };
```

**针对VM**的文件操作中，提供了**ioctl**和**mmap**两个操作函数，其中mmap对应着**GUEST OS的物理地址**，可以直接对**GUEST OS的地址空间**进行**读/写**， ioctl则用于**发送KVM的控制字**。

## 6.3. kvm_vcpu_fops

针对 KVM 的 fd，通过 **KVM\_CREATE\_VCPU 指令字**可以创建 KVM 的vCPU，并且获得该**vcpu\_fd**，在KVM子模块中的操作对应着该结构体。

vcpu\_fd的操作主要包含在kvm\_vcpu\_fops中，其主要定义如下。

代码5\-6 kvm\_vcpu\_fops结构体

```cpp
// virt/kvm/kvm_main.c
(1348)   static struct file_operations kvm_vcpu_fops = {￼
(1349)        .release       = kvm_vcpu_release,￼
(1350)        .unlocked_ioctl = kvm_vcpu_ioctl,￼
(1351)        .compat_ioctl   = kvm_vcpu_ioctl,￼
(1352)        .mmap          = kvm_vcpu_mmap,￼
(1353)        .llseek       = noop_llseek,￼
(1354)   };
```

在**ioctl**中，通过发送ioctl，即可**对vCPU进行控制**。

通过**mmap**，则可以访问**kvm\_run结构体**，在这个结构体中保存了**vCPU运行和控制的信息**，并且可以对其**运行参数**进行设置。
