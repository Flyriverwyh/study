





在模块初始化时候, 

```cpp
// arch/x86/kvm/vmx/vmx.c
struct vmcs_config vmcs_config;
struct vmx_capability vmx_capability;

hardware_setup();
 ├─setup_vmcs_config(&vmcs_config, &vmx_capability);
```

```cpp
// arch/x86/include/asm/msr-index.h
#define MSR_IA32_VMX_PROCBASED_CTLS     0x00000482

// arch/x86/kvm/vmx/vmx.c
static __init int setup_vmcs_config(struct vmcs_config *vmcs_conf,
                                    struct vmx_capability *vmx_cap)
{
        u32 min, opt, min2, opt2;
        u32 _pin_based_exec_control = 0;
        u32 _cpu_based_exec_control = 0;
        u32 _cpu_based_2nd_exec_control = 0;
        ......
        memset(vmcs_conf, 0, sizeof(*vmcs_conf));
        // 必须具备的能力
        min = CPU_BASED_HLT_EXITING |
#ifdef CONFIG_X86_64
              CPU_BASED_CR8_LOAD_EXITING |
              CPU_BASED_CR8_STORE_EXITING |
#endif
              CPU_BASED_CR3_LOAD_EXITING |
              CPU_BASED_CR3_STORE_EXITING |
              CPU_BASED_UNCOND_IO_EXITING |
              CPU_BASED_MOV_DR_EXITING |
              CPU_BASED_USE_TSC_OFFSETTING |
              CPU_BASED_MWAIT_EXITING |
              CPU_BASED_MONITOR_EXITING |
              CPU_BASED_INVLPG_EXITING |
              CPU_BASED_RDPMC_EXITING;
        // 可选的能力, secondary
        opt = CPU_BASED_TPR_SHADOW |
              CPU_BASED_USE_MSR_BITMAPS |
              CPU_BASED_ACTIVATE_SECONDARY_CONTROLS;
        // 根据 msr 寄存器的值来调整 primary 的值
        if (adjust_vmx_controls(min, opt, MSR_IA32_VMX_PROCBASED_CTLS,
                                &_cpu_based_exec_control) < 0)
                return -EIO;
        if (_cpu_based_exec_control & CPU_BASED_ACTIVATE_SECONDARY_CONTROLS) {
                min2 = 0;
                opt2 = SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |

        }
}
```




```cpp
// arch/x86/kvm/vmx/vmx.c
static __init int adjust_vmx_controls(u32 ctl_min, u32 ctl_opt,
                                      u32 msr, u32 *result)
{
        u32 vmx_msr_low, vmx_msr_high;
        u32 ctl = ctl_min | ctl_opt;

        rdmsr(msr, vmx_msr_low, vmx_msr_high);

        ctl &= vmx_msr_high; /* bit == 0 in high word ==> must be zero */
        ctl |= vmx_msr_low;  /* bit == 1 in low word  ==> must be one  */

        /* Ensure minimum (required) set of control bits are supported. */
        if (ctl_min & ~ctl)
                return -EIO;

        *result = ctl;
        return 0;
}
```