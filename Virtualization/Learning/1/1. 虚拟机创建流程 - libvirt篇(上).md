
# libvirt的架构

libvirt是CS架构应用，用户通过client与server交互，server与client通过socket连接通信。

## 基本架构图

基本架构图如下所示：

![2019-11-23-11-01-45.png](./images/2019-11-23-11-01-45.png)

* libvirt分为**client**和**deamon**两个部分
* libvirt **deamon**中还包含了**rpc**、**acl**、**事件机制**、**线程池**等公共组件。
    * **基于rpc**可以实现**libvirt remote client**对本地虚拟机的操作。
    * **acl**实现了**访问控制标签**。
    * **事件机制**是libvirt**所有动作的基础**，所有的请求，消息转发，事件触发都是通过事件机制传递的。
* libvirt deamon中通过**事件机制**监听**某个端口**的消息。**client**发出的请求会通过**socket连接**发送到libvirt **api**。
* libvirt deamon在启动时会**加载**部署的**hypervisor驱动**，libvirt api接收到的请求会路由到**conn对象**指定的**驱动程序**中。
* **驱动程序**接收到转发的请求之后会与**hypervisor交互**实现对虚拟机的具体操作。
* libvirt中目前实现了**多种hypervisor的驱动**，其中**qemu_driver**对应**kvm**，**lxc**对应**容器**。
* 对于kvm而言，一个虚拟机对应一个qemu进程。**qemu进程**通过**软件**模拟计算机的**主板**，**CPU**，**南北桥**及**内存设备**。虚拟机操作系统就运行在qemu进程内。
* libvirt独立实现了lxc driver来管理容器。**lxc driver**启动一个**独立的进程**并使用这个进程拉起一个**init子进程**，这个子进程有其**独立的namespace**并与cgroup结合实现了容器资源的隔离和限制。

## 接口调用方式

在libvirt中接口的调用方式分为两种：

远程调用

![2019-11-23-11-29-42.png](./images/2019-11-23-11-29-42.png)

本地调用

![2019-11-23-11-35-34.png](./images/2019-11-23-11-35-34.png)

# 从nova到libvirt

openstack是基于Python实现的，而libvirt是基于C实现的。那么C和Python之间是如何转换的呢。

下面以启动虚拟机实例来看一下在openstack中如何调用libvirt接口: 

1. import python-libvirt库

```python
if libvirt is None:
    libvirt = __import__('libvirt')
```

2. 通过openAuth获取与libvirtd进程的连接conn

```python
return tpool.proxy_call(
    (libvirt.virDomain, libvirt.virConnect),
    libvirt.openAuth, uri, auth, flags)
)
```

3. 调用define接口创建一个虚拟机实例, 获取domain对象

```python
domain = self._conn.defineXML(xml)
```

4. 通过domain对象启动虚拟机实例

```python
domain.createWithFlags(launch_flags)
```

由这个流程我们可以看到，openstack中主要通过与libvirtd进程交互，完成对虚拟机实例的操作。

**libvirt\-python**是由libvirt提供的一个**面向python client**的连接组件，包含以下内容：

```
/usr/share/pyshared/libvirt.py #libvirt python接口文件，包含大部分的libvirt接口
/usr/share/pyshared/libvirt_lxc.py #lxc接口文件，因为这部分接口参数不能自动转换，所以通过手动重写完成转换
/usr/share/pyshared/libvirt_qemu.py #与上面的类似，qemu相关的。
/usr/lib/python2.7/dist-packages/libvirtmod_qemu.so
/usr/lib/python2.7/dist-packages/libvirtmod_lxc.so
/usr/lib/python2.7/dist-packages/libvirtmod.so
```

在**libvirt代码**中有一个专门的目录用于存放接口python化相关的代码。

所有的**libvirt接口**被分为了两个部分：

1. 可以**直接自动转换**的接口，使用**generator.py**直接封装python接口
2. 无法直接自动转换的接口，通过**libvirt-override.c等文件**对C接口做一层封装再封装python接口。 

**libvirt-python**工程会将未重写和重写过的接口编译到一个动态库中，并且和生成的py文件一起打包到python-libvirt包中。然后我们就可以通过引入这个python库的方式调用libvirt的C接口了。

# libvirt的接口调用流程

下面继续以创建虚拟机为例说明libvirt中接口调用的流程

1. libvirt中接收**xml格式定义的虚拟机实例配置**，nova通过**defineXML接口**定义虚拟机。该接口返回一个虚拟机的domain对象，用户接下来可以通过这个对象操作虚拟机。

```python
domain = self._conn.defineXML(xml)
```

2. 第一步只是执行了定义操作，相当于libvirt开始管理这台虚拟机。但是此时实际的虚拟机还没有运行，用户还无法使用。nova中调用domain.**createWithFlags**(launch_flags)接口，用第一步中定义的虚拟机规格在**hypervisor层**把虚拟机真正创建起来。

3. createWithFlags调用**libvirt\-python**封装的virDomainCreateWithFlags

```python
def createWithFlags(self, flags=0):
        ret = libvirtmod.virDomainCreateWithFlags(self._o, flags)
        if ret == -1: raise libvirtError ('virDomainCreateWithFlags() failed', dom=self)
        return ret
```

在python-libvirt中，createWithFlags接口是**直接封装**的，参数不需要转换。下一步会在转换中调用到libvirt.c中的virDomainCreateWithFlags接口，由此进入libvirt api层。 传入的flag值为0，flag取值范围及对应含义如下：

```python
VIR_DOMAIN_NONE               = 0,      /* Default behavior */
VIR_DOMAIN_START_PAUSED       = 1 << 0, /* Launch guest in paused state */
VIR_DOMAIN_START_AUTODESTROY  = 1 << 1, /* Automatically kill guest when virConnectPtr is closed */
VIR_DOMAIN_START_BYPASS_CACHE = 1 << 2, /* Avoid file system cache pollution */
VIR_DOMAIN_START_FORCE_BOOT   = 1 << 3, /* Boot, discarding any managed save */
```

```python
int
virDomainCreateWithFlags(virDomainPtr domain, unsigned int flags) {
    virConnectPtr conn;

    VIR_DOMAIN_DEBUG(domain, "flags=%x", flags);

    virResetLastError();#重置错误码。
    #libvirt中采用了线程池机制，每次从线程池中取出一个线程执行当前的请求。
    #线程中会保存当前线程最后产生的错误码，因此在请求最开始的位置就要把原有的错误重置，防止误报。

    #合法性检查，传入的domain指针及其中的conn指针是否为正确的类型。
    if (!VIR_IS_CONNECTED_DOMAIN(domain)) {
        virLibDomainError(VIR_ERR_INVALID_DOMAIN, __FUNCTION__);
        virDispatchError(NULL);
        return -1;
    }
    #获取domain中的conn指针，如果conn是只读的，则设置错误码并直接退出。因为创建虚拟机属于修改操作。
    conn = domain->conn;
    if (conn->flags & VIR_CONNECT_RO) {
        virLibDomainError(VIR_ERR_OPERATION_DENIED, __FUNCTION__);
        goto error;
    }
    #从这里跳转到具体的driver中执行。驱动在libvirtd启动的时候加载，映射关系由conn指针初始化的时候指定。在配置文件中可以配置默认的conn driver，也可以在创建conn的时候通过接口参数指定。
    if (conn->driver->domainCreateWithFlags) {
        int ret;
        ret = conn->driver->domainCreateWithFlags(domain, flags);
        if (ret < 0)
            goto error;
        return ret;
    }
    #如果驱动中没有实现对应的方法，直接报no support错误。
    virLibConnError(VIR_ERR_NO_SUPPORT, __FUNCTION__);

error:
    virDispatchError(domain->conn);
    return -1;
}
```

libvirt中每一个driver都有一张映射关系表，用于对应driver中的函数指针和具体的driver函数。第4步中从api映射到了具体的driver。在qemu_driver.c中查找该函数。

