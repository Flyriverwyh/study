
# libvirt的架构

libvirt是CS架构应用，用户通过client与server交互，server与client通过socket连接通信。

## 基本架构图

基本架构图如下所示：

![2019-11-23-11-01-45.png](./images/2019-11-23-11-01-45.png)

* libvirt分为**client**和**deamon**两个部分
* libvirt **deamon**中还包含了**rpc**、**acl**、**事件机制**、**线程池**等公共组件。
    * **基于rpc**可以实现**libvirt remote client**对本地虚拟机的操作。
    * **acl**实现了**访问控制标签**。
    * **事件机制**是libvirt**所有动作的基础**，所有的请求，消息转发，事件触发都是通过事件机制传递的。
* libvirt deamon中通过**事件机制**监听**某个端口**的消息。**client**发出的请求会通过**socket连接**发送到libvirt **api**。
* libvirt deamon在启动时会**加载**部署的**hypervisor驱动**，libvirt api接收到的请求会路由到**conn对象**指定的**驱动程序**中。
* **驱动程序**接收到转发的请求之后会与**hypervisor交互**实现对虚拟机的具体操作。
* libvirt中目前实现了**多种hypervisor的驱动**，其中**qemu_driver**对应**kvm**，**lxc**对应**容器**。
* 对于kvm而言，一个虚拟机对应一个qemu进程。**qemu进程**通过**软件**模拟计算机的**主板**，**CPU**，**南北桥**及**内存设备**。虚拟机操作系统就运行在qemu进程内。
* libvirt独立实现了lxc driver来管理容器。**lxc driver**启动一个**独立的进程**并使用这个进程拉起一个**init子进程**，这个子进程有其**独立的namespace**并与cgroup结合实现了容器资源的隔离和限制。

## 接口调用方式

在libvirt中接口的调用方式分为两种：

远程调用

![2019-11-23-11-29-42.png](./images/2019-11-23-11-29-42.png)

本地调用

![2019-11-23-11-35-34.png](./images/2019-11-23-11-35-34.png)

# 从nova到libvirt

openstack是基于Python实现的，而libvirt是基于C实现的。那么C和Python之间是如何转换的呢。

下面以启动虚拟机实例来看一下在openstack中如何调用libvirt接口: 

1. import python-libvirt库

```python
if libvirt is None:
    libvirt = __import__('libvirt')
```

2. 通过openAuth获取与libvirtd进程的连接conn

```python
return tpool.proxy_call(
    (libvirt.virDomain, libvirt.virConnect),
    libvirt.openAuth, uri, auth, flags)
)
```

3. 调用define接口创建一个虚拟机实例, 获取domain对象

```python
domain = self._conn.defineXML(xml)
```

4. 通过domain对象启动虚拟机实例

```python
domain.createWithFlags(launch_flags)
```

由这个流程我们可以看到，openstack中主要通过与libvirtd进程交互，完成对虚拟机实例的操作。

**libvirt\-python**是由libvirt提供的一个**面向python client**的连接组件，包含以下内容：

```
/usr/share/pyshared/libvirt.py #libvirt python接口文件，包含大部分的libvirt接口
/usr/share/pyshared/libvirt_lxc.py #lxc接口文件，因为这部分接口参数不能自动转换，所以通过手动重写完成转换
/usr/share/pyshared/libvirt_qemu.py #与上面的类似，qemu相关的。
/usr/lib/python2.7/dist-packages/libvirtmod_qemu.so
/usr/lib/python2.7/dist-packages/libvirtmod_lxc.so
/usr/lib/python2.7/dist-packages/libvirtmod.so
```

在**libvirt代码**中有一个专门的目录用于存放接口python化相关的代码。

所有的**libvirt接口**被分为了两个部分：

1. 可以**直接自动转换**的接口，使用**generator.py**直接封装python接口
2. 无法直接自动转换的接口，通过**libvirt-override.c等文件**对C接口做一层封装再封装python接口。 

**libvirt-python**工程会将未重写和重写过的接口编译到一个动态库中，并且和生成的py文件一起打包到python-libvirt包中。然后我们就可以通过引入这个python库的方式调用libvirt的C接口了。

# libvirt的接口调用流程

下面继续以创建虚拟机为例说明libvirt中接口调用的流程

1. libvirt中接收**xml格式定义的虚拟机实例配置**，nova通过**defineXML接口**定义虚拟机。该接口返回一个虚拟机的domain对象，用户接下来可以通过这个对象操作虚拟机。

```python
domain = self._conn.defineXML(xml)
```

2. 第一步只是执行了定义操作，相当于libvirt开始管理这台虚拟机。但是此时实际的虚拟机还没有运行，用户还无法使用。nova中调用domain.createWithFlags(launch_flags)接口，用第一步中定义的虚拟机规格在hypervisor层把虚拟机真正创建起来。

createWithFlags调用python\-libvirt封装的virDomainCreateWithFlags

```python
def createWithFlags(self, flags=0):
        ret = libvirtmod.virDomainCreateWithFlags(self._o, flags)
        if ret == -1: raise libvirtError ('virDomainCreateWithFlags() failed', dom=self)
        return ret
```

在python-libvirt中，createWithFlags接口是直接封装的，参数不需要转换。下一步会在转换中调用到libvirt.c中的virDomainCreateWithFlags接口，由此进入libvirt api层。 传入的flag值为0，flag取值范围及对应含义如下：