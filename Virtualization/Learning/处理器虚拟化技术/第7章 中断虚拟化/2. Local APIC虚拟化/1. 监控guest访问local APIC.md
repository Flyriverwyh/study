
# 1. 两种监控模式

VMM通过**EPT映射机制**或者`MSR-bitmap`来限制guest访问local APIC, 其原理是监控guest访问local APIC的行为并做出相应处理。

## 1.1. 监控基于内存映射的local APIC访问: XAPIC

当local APIC 使用 **xAPIC** 模式, local APIC 寄存器通过 `memory-mapped`(内存映射)方式映射在**物理空间**的**4K页面**上，我们可以称这个4K页面为`APIC-page`。

`APIC-page`**物理基址**在`IA32_APIC_BASE`寄存器的`bits N-1:12`里提供(N=MAXPHYADDR)

在这种情况下，VMM可以通过**EPT映射机制！！！** 来监控guest访问local APIC。

## 1.2. 监控基于MSR的localAPIC访问: x2APIC

当local APIC 使用 **x2APIC** 模式(xAPIC 的扩展模式), local APIC 寄存器映射到**MSR空间**上，MSR地址范围为`800H ~ 8FFH`。guest 软件使用`RDMSR`指令读取local APIC寄存器. 使用 WRMSR 指令写入 local APIC 寄存器.

在这种情况下，VMM可以通过设置**MSR-bitmap！！！** 来监控guest访问local APIC。

# 2. 例子: 使用EPT机制实现local APIC虚拟化

>示例7-3: 使用EPT机制实现local APIC虚拟化

上文提及，当local APIC使用**xAPIC**模式时，我们可以通过**EPT映射机制**来实现监控guest访问localAPIC在这一节里， 我们将使用EPT映射机制来实现local APIC虚拟化。

## 2.1. 监控guest访问IA32_APIC_BASE寄存器

VMM 必须监控 guest 对 `IA32_APIC_BASE` 寄存器的访问(包括**读与写访问**), 只有这样才能够监控guest访问local APIC寄存器，如代码片段7-16所示。

```x86asm
;;
;; 设置拦截对 IA32_APIC_BASE 的读操作
;;
mov esi, IA32_APIC_BASE
call set_msr_read_bitmap        

;;
;; 设置拦截对 IA32_APIC_BASE 的写操作
;;
mov esi, IA32_APIC_BASE
call set_msr_write_bitmap
```

在`chap07\ex7-3\ex.asm`模块的`init_guest_a`与`init_guest_b`函数里，分别设置了对`IA32_APIC_BASE`的**读/写**进行拦截。`set_msr_read_bitmap` 函数**设置MSR的读访问限制**, `set_msr_write__bitmap` 函数设置**MSR的写访问限制**。

## 2.2. 处理写IA32_APIC_BASE时产生的VM-exit

当guest执行**WRMSR指令**尝试写`IA32_APIC_BASE`寄存器时产生`VM-exit`。 例如，下面的 `chap07\ex7-3\guest_ex.asm` 模块代码片段7-17所示。

```x86asm
;;
;; 设置 local APIC base 值为 01000000h
;;
mov ecx, IA32_APIC_BASE
mov eax, 01000000h | APIC_BASE_BSP | APIC_BASE_ENABLE
xor edx, edx
wrmsr
```

guest 试图设置 `APIC-page` 的**基址**为 `01000000H` . ECX 寄存器表示操作的是哪个 MSR 寄存器.

在产生 `VM-exit` 后, VMM调用**DoWRMSR函数**处理由于**WRMSR指令**而产生的 `VM-exit` .

```x86asm
        ;;
        ;; 读取 MSR index
        ;;
        mov ecx, [ebx + VSB.Rcx]
        cmp ecx, IA32_APIC_BASE
        jne DoWRMSR.@1
        
        ;;
        ;; 处理写 IA32_APIC_BASE 寄存器
        ;;
        call DoWriteMsrForApicBase

DoWRMSR.@1:  
```

**DoWRMSR函数**实现在`lib\Vmx\VmxVMM.asm`文件里. 它读取`VM-exit`时的ECX寄存器値, 属于`IA32_APIC_BASE`寄存器吋，调用 `DoWriteMsrForApicBase` 来处理guest对`IA32_APIC_BASE`寄存器的**写操作**。

```x86asm
;-----------------------------------------------------------------------
; DoWriteMsrForApicBase()
; input:
;       none
; output:
;       none
; 描述：
;       1) 处理 guest 访问 IA32_APIC_BASE 寄存器
;-----------------------------------------------------------------------
DoWriteMsrForApicBase:
        push ebp
        push ebx
        push edx
        push ecx
        
%ifdef __X64
        LoadGsBaseToRbp
%else
        mov ebp, [gs: PCB.Base]
%endif  
        REX.Wrxb
        mov ebx, [ebp + PCB.CurrentVmbPointer]
        REX.Wrxb
        mov ebx, [ebx + VMB.VsbBase]
               
        ;;
        ;; 读取 guest 写入的 MSR 值
        ;;
        mov eax, [ebx + VSB.Rax]
        mov edx, [ebx + VSB.Rdx]

        DEBUG_RECORD    "[DoWriteMsrForApicBase]: write to IA32_APIC_BASE"
                
        ;;
        ;; ### 检查写入值是否合法 ###
        ;; 1) 保留位（bits 7:0, bit 9，bits 63:N）需为 0
        ;; 2) 检查 bit 11 与 bit 10 的设置
        ;;      a) 当 bit 11 = 1, bit 10 = 0 时，设置 bit 11 = 1， bit 10 = 1 开启 x2APIC 模式
        ;;      b) 当 bit 11 = 0, bit 10 = 1 时，无效
        ;;      c) 当 bit 11 = 0, bit 10 = 0 时，关闭 local APIC
        ;;      d) 当 bit 11 = 1, bit 10 = 1 时，设置 bit 11 = 1, bit 10 = 0 时，产生 #GP 异常 
        ;;
        
        ;;
        ;; 检查保留位，不为 0 时注入 #GP 异常
        ;;
        test eax, 2FFh
        jnz DoWriteMsrForApicBase.Error
        mov esi, [ebp + PCB.MaxPhyAddrSelectMask + 4]
        not esi
        test edx, esi
        jnz DoWriteMsrForApicBase.Error
        
        ;;
        ;; 检查 xAPIC enable（bit 11）与 x2APIC enable（bit 10）
        ;;
        test eax, APIC_BASE_X2APIC
        jz DoWriteMsrForApicBase.Check.@1

        ;;
        ;; 当 bit 10 = 1 时，检查 CPUID.01H:ECX[21].x2APIC 位
        ;; 1) 为 0 时表明不支持 x2APIC 模式，注入 #GP(0) 异常
        ;; 
        test DWORD [ebp + PCB.CpuidLeaf01Ecx], (1 << 21)
        jz DoWriteMsrForApicBase.Error

        ;;
        ;; 当 bit 10 = 1 时，bit 11 = 0，无效设置则注入 #GP(0) 异常
        ;;
        test eax, APIC_BASE_ENABLE
        jz DoWriteMsrForApicBase.Error
        

DoWriteMsrForApicBase.x2APIC:
        ;;
        ;; 现在 bit 10 = 1, bit 11 = 1
        ;; 1) 使用 x2APIC 模式的虚拟化设置
        ;;       
        mov esi, IA32_APIC_BASE
        call AppendMsrVte                                ;; 保存 guest 写入原值
        

        ;;
        ;; 检查 secondary prcessor-based VM-execution control 字段“virtualize x2APIC mode”位
        ;; 1) 为 1 时，使用 VMX 原生的 x2APIC 虚拟化，直接返回
        ;; 2) 为 0 时，监控 800H - 8FFH MSR 的读写
        ;;
        GetVmcsField    CONTROL_PROCBASED_SECONDARY
        test eax, VIRTUALIZE_X2APIC_MODE
        jnz DoWriteMsrForApicBase.Done
        
        ;;
        ;; 现在监控 x2APIC MSR 的读写，范围从 800H 到 8FFH
        ;;
        call set_msr_read_bitmap_for_x2apic
        call set_msr_write_bitmap_for_x2apic
        jmp DoWriteMsrForApicBase.Done
                
DoWriteMsrForApicBase.Check.@1:
        ;;
        ;; bit 10 = 0, bit 11 = 0，关闭 local APIC，不进行虚拟化处理
        ;; 1）写入 IA32_APIC_BASE 寄存器
        ;; 2）恢复映射
        ;;
        test eax, APIC_BASE_ENABLE
        jnz DoWriteMsrForApicBase.Check.@2
        
        ;;
        ;; guest 尝试关闭 local APIC
        ;; 1) 恢复 guest 对 IA32_APIC_BASE 寄存器的写入
        ;; 2) 恢复 EPT 映射
        ;;
        mov esi, IA32_APIC_BASE
        mov eax, [ebx + VSB.Rax]
        mov edx, [ebx + VSB.Rdx]
        call append_vmentry_msr_load_entry

%ifdef __X64        
        REX.Wrxb
        mov esi, [ebx + VSB.Rax]
        mov edi, 0FEE00000h
        mov eax, EPT_WRITE | EPT_READ
        call do_guest_physical_address_mapping
%else
        mov esi, [ebx + VSB.Rax]
        mov edi, [ebx + VSB.Rdx]
        mov eax, 0FEE00000h
        mov edx, 0
        mov ecx, EPT_WRITE | EPT_READ
        call do_guest_physical_address_mapping
%endif

        jmp DoWriteMsrForApicBase.Done
        
DoWriteMsrForApicBase.Check.@2:
        ;;
        ;; 读取原 guest 设置的 APIC_APIC_BASE 值
        ;; 1) 假如返回 0 值，则表明 guest 第 1 次写 IA32_APIC_BASE
        ;;
        mov esi, IA32_APIC_BASE
        call GetMsrVte
        test eax, eax
        jz DoWriteMsrForApicBase.xAPIC
                
        ;;
        ;; 如果原值 bit 11 = 1, bit 10 = 1 时，当设置 bit 11 = 1, bit 10 = 0 时，将产生 #GP 异常
        ;;
        test DWORD [eax + MSR_VTE.Value], APIC_BASE_X2APIC
        jnz DoWriteMsrForApicBase.Error
        
        
DoWriteMsrForApicBase.xAPIC:
        ;;
        ;; ### 下面虚拟化 local APIC 的 xAPIC 模式 ###
        ;;                
        mov esi, IA32_APIC_BASE
        mov eax, [ebx + VSB.Rax]
        mov edx, [ebx + VSB.Rdx]
        call AppendMsrVte                               ; 保存 guest 写入值
        
        REX.Wrxb
        mov edx, eax
        
        ;;
        ;; 1）检查是否开启了“virtualize APIC access ”
        ;;     a) 是，则设置 APIC-access page 页面
        ;;     b) 否，则提供 GPA 例程处理 local APIC 访问
        ;; 2）检查是否开启了“enable EPT”
        ;;     a）是，则映射 IA32_APIC_BASE[N-1:12]，将 APIC-access page 设置为该 HPA 值
        ;;     b）否，则直接将 IA32_APIC_BASE[N-1:12] 设为 APIC-access page
        ;;
        
        GetVmcsField    CONTROL_PROCBASED_SECONDARY
        
        test eax, VIRTUALIZE_APIC_ACCESS
        jz DoWriteMsrForApicBase.SetForEptViolation        
        test eax, ENABLE_EPT
        jz DoWriteMsrForApicBase.EptDisable
        
        ;;
        ;; 执行 EPT 映射到 0FEE00000H
        ;;
%ifdef __X64        
        REX.Wrxb
        mov esi, [edx + MSR_VTE.Value]
        mov edi, 0FEE00000h
        mov eax, EPT_READ | EPT_WRITE
        call do_guest_physical_address_mapping
%else
        mov esi, [edx + MSR_VTE.Value]
        mov edi, [edx + MSR_VTE.Value + 4]
        mov eax, 0FEE00000H
        mov edx, 0
        mov ecx, EPT_READ | EPT_WRITE
        call do_guest_physical_address_mapping
%endif

        mov eax, 0FEE00000h
        mov edx, 0
        jmp DoWriteMsrForApicBase.SetApicAccessPage


DoWriteMsrForApicBase.EptDisable:
        REX.Wrxb
        mov eax, [edx + MSR_VTE.Value]
        mov edx, [edx + MSR_VTE.Value + 4]
        REX.Wrxb
        and eax, ~0FFFh
        
DoWriteMsrForApicBase.SetApicAccessPage:        
        SetVmcsField    CONTROL_APIC_ACCESS_ADDRESS_FULL, eax
%ifndef __X64
        SetVmcsField    CONTROL_APIC_ACCESS_ADDRESS_HIGH, edx
%endif        
        
        call update_guest_rip
        jmp DoWriteMsrForApicBase.Done
        
        
DoWriteMsrForApicBase.SetForEptViolation:
        ;;
        ;; 处理 guest 写入 IA32_APIC_BASE 寄存器的值：
        ;; 1）将 IA32_APIC_BASE[N-1:12] 映射到 host 的 IA32_APIC_BASE 值，但是为 not-present
        ;; 2）GPA 不进行任何映射
        ;;        
        
        ;;
        ;; 为 GPA 提供处理例程
        ;;
        REX.Wrxb
        mov esi, [edx + MSR_VTE.Value]
        REX.Wrxb
        and esi, ~0FFFh
        mov edi, EptHandlerForGuestApicPage
        call AppendGpaHte

       
        call update_guest_rip
        jmp DoWriteMsrForApicBase.Done
        
DoWriteMsrForApicBase.Error:
        ;;
        ;; 反射 #GP(0) 给 guest 处理
        ;;
        SetVmcsField    VMENTRY_INTERRUPTION_INFORMATION, INJECT_EXCEPTION_GP
        SetVmcsField    VMENTRY_EXCEPTION_ERROR_CODE, 0

DoWriteMsrForApicBase.Done:        
        pop ecx
        pop edx
        pop ebx
        pop ebp
        ret
```

