
# 1. 两种监控模式

VMM通过**EPT映射机制**或者`MSR-bitmap`来限制guest访问local APIC, 其原理是监控guest访问local APIC的行为并做出相应处理。

## 1.1. 监控基于内存映射的local APIC访问: APIC-page

当local APIC 使用 **xAPIC** 模式, **local APIC 寄存器**通过 `memory-mapped`(内存映射)方式映射在**物理空间**的**4K页面**上，我们可以称这个4K页面为`APIC-page`。

`APIC-page`**物理基址**在`IA32_APIC_BASE`寄存器的`bits N-1:12`里提供(N=MAXPHYADDR)

在这种情况下，VMM可以通过**EPT映射机制！！！** 来监控guest访问local APIC。

## 1.2. 监控基于MSR的localAPIC访问: MSR空间

当local APIC 使用 **x2APIC** 模式(xAPIC 的扩展模式), local APIC 寄存器映射到**MSR空间！！！** 上，MSR地址范围为`800H ~ 8FFH`。guest 软件使用`RDMSR`指令读取local APIC寄存器. 使用 WRMSR 指令写入 local APIC 寄存器.

在这种情况下，VMM可以通过设置**MSR-bitmap！！！** 来监控guest访问local APIC。

# 2. 例子: 使用EPT机制实现local APIC虚拟化

>示例7-3: 使用EPT机制实现local APIC虚拟化

上文提及，当local APIC使用**xAPIC**模式时，我们可以通过**EPT映射机制**来实现监控guest访问localAPIC在这一节里， 我们将使用EPT映射机制来实现local APIC虚拟化。

## 2.1. 监控guest访问IA32_APIC_BASE寄存器

VMM 必须监控 guest 对 `IA32_APIC_BASE` 寄存器的访问(包括**读与写访问**), 只有这样才能够监控guest访问local APIC寄存器，如代码片段7-16所示。

```x86asm
;;
;; 设置拦截对 IA32_APIC_BASE 的读操作
;;
mov esi, IA32_APIC_BASE
call set_msr_read_bitmap        

;;
;; 设置拦截对 IA32_APIC_BASE 的写操作
;;
mov esi, IA32_APIC_BASE
call set_msr_write_bitmap
```

在`chap07\ex7-3\ex.asm`模块的`init_guest_a`与`init_guest_b`函数里，分别设置了对`IA32_APIC_BASE`的**读/写**进行拦截。
* `set_msr_read_bitmap` 函数**设置MSR的读访问限制**
* `set_msr_write__bitmap` 函数设置**MSR的写访问限制**

## 2.2. 处理写IA32_APIC_BASE时产生的VM-exit

当guest执行**WRMSR指令**尝试写`IA32_APIC_BASE`寄存器时产生`VM-exit`。 

例如，下面的 `chap07\ex7-3\guest_ex.asm` 模块代码片段7-17所示。

```x86asm
;;
;; 设置 local APIC base 值为 01000000h
;;
mov ecx, IA32_APIC_BASE
mov eax, 01000000h | APIC_BASE_BSP | APIC_BASE_ENABLE
xor edx, edx
wrmsr
```

guest 试图设置 `APIC-page` 的**基址**为 `01000000H` . **ECX 寄存器**表示操作的是哪个 MSR 寄存器.

在产生 `VM-exit` 后, VMM调用**DoWRMSR函数**处理由于**WRMSR指令**而产生的 `VM-exit` .

注: 具体处理从`lib/VMX/VmxVMM.asm`中的`VmmEntry`开始, 根据`exit code`执行对应的处理例程.

```x86asm
DoWRMSR:

        ......

        ;;
        ;; 读取 MSR index
        ;;
        mov ecx, [ebx + VSB.Rcx]
        cmp ecx, IA32_APIC_BASE
        jne DoWRMSR.@1
        
        ;;
        ;; 处理写 IA32_APIC_BASE 寄存器
        ;;
        call DoWriteMsrForApicBase

```

**DoWRMSR函数**实现在`lib\Vmx\VmxVMM.asm`文件里. 它读取`VM-exit`时的**ECX寄存器値**, 属于`IA32_APIC_BASE`寄存器吋，调用 `DoWriteMsrForApicBase` 来处理guest对`IA32_APIC_BASE`寄存器的**写操作**。

```x86asm
;-----------------------------------------------------------------------
; DoWriteMsrForApicBase()
; input:
;       none
; output:
;       none
; 描述：
;       1) 处理 guest 访问 IA32_APIC_BASE 寄存器
;-----------------------------------------------------------------------
DoWriteMsrForApicBase:
        push ebp
        push ebx
        push edx
        push ecx
        
%ifdef __X64
        LoadGsBaseToRbp
%else
        mov ebp, [gs: PCB.Base]
%endif  
        REX.Wrxb
        mov ebx, [ebp + PCB.CurrentVmbPointer]
        REX.Wrxb
        mov ebx, [ebx + VMB.VsbBase]
               
        ;;
        ;; 读取 guest 写入的 MSR 值
        ;;
        mov eax, [ebx + VSB.Rax]
        mov edx, [ebx + VSB.Rdx]

        DEBUG_RECORD    "[DoWriteMsrForApicBase]: write to IA32_APIC_BASE"
                
        ;;
        ;; ### 检查写入值是否合法 ###
        ;; 1) 保留位（bits 7:0, bit 9，bits 63:N）需为 0
        ;; 2) 检查 bit 11 与 bit 10 的设置
        ;;      a) 当 bit 11 = 1, bit 10 = 0 时，设置 bit 11 = 1， bit 10 = 1 开启 x2APIC 模式
        ;;      b) 当 bit 11 = 0, bit 10 = 1 时，无效
        ;;      c) 当 bit 11 = 0, bit 10 = 0 时，关闭 local APIC
        ;;      d) 当 bit 11 = 1, bit 10 = 1 时，设置 bit 11 = 1, bit 10 = 0 时，产生 #GP 异常 
        ;;
        
        ;;
        ;; 检查保留位，不为 0 时注入 #GP 异常
        ;;
        test eax, 2FFh
        jnz DoWriteMsrForApicBase.Error
        mov esi, [ebp + PCB.MaxPhyAddrSelectMask + 4]
        not esi
        test edx, esi
        jnz DoWriteMsrForApicBase.Error
        
        ;;
        ;; 检查 xAPIC enable（bit 11）与 x2APIC enable（bit 10）
        ;;
        test eax, APIC_BASE_X2APIC
        jz DoWriteMsrForApicBase.Check.@1

        ;;
        ;; 当 bit 10 = 1 时，检查 CPUID.01H:ECX[21].x2APIC 位
        ;; 1) 为 0 时表明不支持 x2APIC 模式，注入 #GP(0) 异常
        ;; 
        test DWORD [ebp + PCB.CpuidLeaf01Ecx], (1 << 21)
        jz DoWriteMsrForApicBase.Error

        ;;
        ;; 当 bit 10 = 1 时，bit 11 = 0，无效设置则注入 #GP(0) 异常
        ;;
        test eax, APIC_BASE_ENABLE
        jz DoWriteMsrForApicBase.Error
        

DoWriteMsrForApicBase.x2APIC:
        ;;
        ;; 现在 bit 10 = 1, bit 11 = 1
        ;; 1) 使用 x2APIC 模式的虚拟化设置
        ;;       
        mov esi, IA32_APIC_BASE
        call AppendMsrVte                                ;; 保存 guest 写入原值
        

        ;;
        ;; 检查 secondary prcessor-based VM-execution control 字段“virtualize x2APIC mode”位
        ;; 1) 为 1 时，使用 VMX 原生的 x2APIC 虚拟化，直接返回
        ;; 2) 为 0 时，监控 800H - 8FFH MSR 的读写
        ;;
        GetVmcsField    CONTROL_PROCBASED_SECONDARY
        test eax, VIRTUALIZE_X2APIC_MODE
        jnz DoWriteMsrForApicBase.Done
        
        ;;
        ;; 现在监控 x2APIC MSR 的读写，范围从 800H 到 8FFH
        ;;
        call set_msr_read_bitmap_for_x2apic
        call set_msr_write_bitmap_for_x2apic
        jmp DoWriteMsrForApicBase.Done
                
DoWriteMsrForApicBase.Check.@1:
        ;;
        ;; bit 10 = 0, bit 11 = 0，关闭 local APIC，不进行虚拟化处理
        ;; 1）写入 IA32_APIC_BASE 寄存器
        ;; 2）恢复映射
        ;;
        test eax, APIC_BASE_ENABLE
        jnz DoWriteMsrForApicBase.Check.@2
        
        ;;
        ;; guest 尝试关闭 local APIC
        ;; 1) 恢复 guest 对 IA32_APIC_BASE 寄存器的写入
        ;; 2) 恢复 EPT 映射
        ;;
        mov esi, IA32_APIC_BASE
        mov eax, [ebx + VSB.Rax]
        mov edx, [ebx + VSB.Rdx]
        call append_vmentry_msr_load_entry

%ifdef __X64        
        REX.Wrxb
        mov esi, [ebx + VSB.Rax]
        mov edi, 0FEE00000h
        mov eax, EPT_WRITE | EPT_READ
        call do_guest_physical_address_mapping
%else
        mov esi, [ebx + VSB.Rax]
        mov edi, [ebx + VSB.Rdx]
        mov eax, 0FEE00000h
        mov edx, 0
        mov ecx, EPT_WRITE | EPT_READ
        call do_guest_physical_address_mapping
%endif

        jmp DoWriteMsrForApicBase.Done
        
DoWriteMsrForApicBase.Check.@2:
        ;;
        ;; 读取原 guest 设置的 APIC_APIC_BASE 值
        ;; 1) 假如返回 0 值，则表明 guest 第 1 次写 IA32_APIC_BASE
        ;;
        mov esi, IA32_APIC_BASE
        call GetMsrVte
        test eax, eax
        jz DoWriteMsrForApicBase.xAPIC
                
        ;;
        ;; 如果原值 bit 11 = 1, bit 10 = 1 时，当设置 bit 11 = 1, bit 10 = 0 时，将产生 #GP 异常
        ;;
        test DWORD [eax + MSR_VTE.Value], APIC_BASE_X2APIC
        jnz DoWriteMsrForApicBase.Error
        
        
DoWriteMsrForApicBase.xAPIC:
        ;;
        ;; ### 下面虚拟化 local APIC 的 xAPIC 模式 ###
        ;;                
        mov esi, IA32_APIC_BASE
        mov eax, [ebx + VSB.Rax]
        mov edx, [ebx + VSB.Rdx]
        call AppendMsrVte                               ; 保存 guest 写入值
        
        REX.Wrxb
        mov edx, eax
        
        ;;
        ;; 1）检查是否开启了“virtualize APIC access ”
        ;;     a) 是，则设置 APIC-access page 页面
        ;;     b) 否，则提供 GPA 例程处理 local APIC 访问
        ;; 2）检查是否开启了“enable EPT”
        ;;     a）是，则映射 IA32_APIC_BASE[N-1:12]，将 APIC-access page 设置为该 HPA 值
        ;;     b）否，则直接将 IA32_APIC_BASE[N-1:12] 设为 APIC-access page
        ;;
        
        GetVmcsField    CONTROL_PROCBASED_SECONDARY
        
        test eax, VIRTUALIZE_APIC_ACCESS
        jz DoWriteMsrForApicBase.SetForEptViolation        
        test eax, ENABLE_EPT
        jz DoWriteMsrForApicBase.EptDisable
        
        ;;
        ;; 执行 EPT 映射到 0FEE00000H
        ;;
%ifdef __X64        
        REX.Wrxb
        mov esi, [edx + MSR_VTE.Value]
        mov edi, 0FEE00000h
        mov eax, EPT_READ | EPT_WRITE
        call do_guest_physical_address_mapping
%else
        mov esi, [edx + MSR_VTE.Value]
        mov edi, [edx + MSR_VTE.Value + 4]
        mov eax, 0FEE00000H
        mov edx, 0
        mov ecx, EPT_READ | EPT_WRITE
        call do_guest_physical_address_mapping
%endif

        mov eax, 0FEE00000h
        mov edx, 0
        jmp DoWriteMsrForApicBase.SetApicAccessPage


DoWriteMsrForApicBase.EptDisable:
        REX.Wrxb
        mov eax, [edx + MSR_VTE.Value]
        mov edx, [edx + MSR_VTE.Value + 4]
        REX.Wrxb
        and eax, ~0FFFh
        
DoWriteMsrForApicBase.SetApicAccessPage:        
        SetVmcsField    CONTROL_APIC_ACCESS_ADDRESS_FULL, eax
%ifndef __X64
        SetVmcsField    CONTROL_APIC_ACCESS_ADDRESS_HIGH, edx
%endif        
        
        call update_guest_rip
        jmp DoWriteMsrForApicBase.Done
        
        
DoWriteMsrForApicBase.SetForEptViolation:
        ;;
        ;; 处理 guest 写入 IA32_APIC_BASE 寄存器的值：
        ;; 1）将 IA32_APIC_BASE[N-1:12] 映射到 host 的 IA32_APIC_BASE 值，但是为 not-present
        ;; 2）GPA 不进行任何映射
        ;;        
        
        ;;
        ;; 为 GPA 提供处理例程
        ;;
        REX.Wrxb
        mov esi, [edx + MSR_VTE.Value]
        REX.Wrxb
        and esi, ~0FFFh
        mov edi, EptHandlerForGuestApicPage
        call AppendGpaHte

       
        call update_guest_rip
        jmp DoWriteMsrForApicBase.Done
        
DoWriteMsrForApicBase.Error:
        ;;
        ;; 反射 #GP(0) 给 guest 处理
        ;;
        SetVmcsField    VMENTRY_INTERRUPTION_INFORMATION, INJECT_EXCEPTION_GP
        SetVmcsField    VMENTRY_EXCEPTION_ERROR_CODE, 0

DoWriteMsrForApicBase.Done:        
        pop ecx
        pop edx
        pop ebx
        pop ebp
        ret
```

`DoWriteMsrForApicBase` 函数实现在 `lib\Vmx\Vmxmsr.asm` 文件里，它根据 guest 设置 **local APIC** 的**模式**（**XAPIC** 还是 **x2APIC**），以及 `secondary processor-based VM-execution control` 字段的设置进行虚拟化配置。

* 当 local APIC 为 **XAPIC** 模式时
    * 如果 “**virtualize APIC accesses**” 为 1, 则使用 VMX 提供的 **local APIC 虚拟化功能**。
    * 如果 “**virtualize APIC accesses**” 为 0, 则利用 **EPT violation** 故障来达到 local APIC 虚拟化。
* 当 local APIC 为 **x2APIC** 模式时
    * 如果 “**virtualize x2 APIC mode**” 为 1, 则使用 VMX 提供的 **x2APIC 模式虚拟化**功能。
    * 如果 “**virtualize x2 APIC mode**” 为 0, 则利用 **MSR bitmap** 来达到 local APIC 虚拟化。

`DoWriteMsrForApicBase` 例程通过检査 guest 写入 **IA32 APIC BASE** 寄存器的**值**确定 guest 的 local APIC 处于**何种工作模式**。在检查**写入值不合法**时将**注入** `#GP` 异常给 guest 处理，例如保留位（bits 63:N、bit 9 以及 bits 7:0) 必须为 0。

当利用 **EPT violation** 来虚拟化 local APIC 时，下面是简单的处理流程。

(1) 读取 EAX 与 EDX 寄存器值。两个寄存器组合的 64 位值是 guest 尝试写入 `IA32_APIC_BASE` **寄存器的值**。

(2) **保存** guest 写入 `IA32_APIC_BASE` 寄存器的**值**。这个值在 guest 读取 `IA32_APIC_BASE` 寄存器时需要**反馈给 guest**

(3) 为 guest 的写入值提供一个 `EPT violation` 处理例程。

## 保存 guest 的写入值

在前面介绍的 `DoWriteMsrForApicBase` 函数里，使用 `AppendMsrVte` 函数将 guest 的**写入值**保存在了 guest 对应的 **MSR VTE** (Value Table Entry) 区域里。

这个 MSR VTE 区域在 `initialize_vmcs_buffer` 函数初始化时从 **kernel pool** 里分配。**这个不属于VMCS区域**, 可以看`3.11`的实例代码.

在 `inc\vmcs.inc` 文件里定义了一个 `MSR_VTE` 结构，这个结构用来定义 MSR VTE 区域里的每个表项。

```inc
;;
;; MSR 值列表项结构
;;
struc MSR_VTE
        .MsrIndex                       RESD    1
        .Value                          RESQ    1

        MSR_VTE_SIZE                    EQU     $
endstruc
```

`AppendMsrVte` 函数的定义实现在 `lib\Vmx\VmxMsr.asm` 文件

## 提供 EPT violation 处理例程

由于 VMM **拦截**guest写 `IA32_APIC_BASE` 寄存器, 但并**没有**为 guest 写入的 guest-physical address 地址值进行 **EPT 映射**. 因此, 当 **guest** 尝试**访问** local APIC **寄存器**时, 会产生 EPT violation 故障.

那么, 在 `DoWriteMsrForApicBase` 函数里使用 `AppendGpaHte` 函数提供了由这个 `guest-physical address` 产生 EPT violation 而导致 VM-exit 的处理例程.

```x86asm

```

`AppendGpaHte` 函数的定义看起来像上面的 C 代码，实现在 `lib\Vmx\VmxPage.asm` 文件里。在 **GPA HTE** (Handler Table Entry）区域建立 **GPA** 与 EPT violation 处理例程的**对应关系**。这个 GPA HTE 区域在 `initialize_vmcs_buffer` 函数初始化时在 kernel pool 里分配。GPA HTE 结构定义在 `inc\vmcs.inc` 文件里。

## 处理读 IA32_APIC_BASE 产生的 VM-exit

当 guest 尝试**读取** `IA32_APIC_BASE` 寄存器的值时，VMM 拦截了 RDMSR 指令而产生 `VM-exit`。

DORDMSR 例程检查到 **ECX** 的值是 `IA32_APIC_BASE` 寄存器时，调用 `DoReadMsrForApicBase` 例程来处理。

```x86asm
;-----------------------------------------------------------------------
; DoReadMsrForApicBase()
; input:
;       none
; output:
;       none
; 描述：
;       1) 处理 guest 读 IA32_APIC_BASE 寄存器
;-----------------------------------------------------------------------
DoReadMsrForApicBase:
        push ebp
        push ebx
        push edx

%ifdef __X64
        LoadGsBaseToRbp
%else
        mov ebp, [gs: PCB.Base]
%endif  
        REX.Wrxb
        mov ebx, [ebp + PCB.CurrentVmbPointer]
        REX.Wrxb
        mov ebx, [ebx + VMB.VsbBase]

        mov esi, IA32_APIC_BASE
        call GetMsrVte
        REX.Wrxb
        test eax, eax
        jz DoReadMsrForApicBase.Done
        
        mov edx, [eax + MSR_VTE.Value + 4]
        mov eax, [eax + MSR_VTE.Value]
        mov [ebx + VSB.Rax], eax
        mov [ebx + VSB.Rdx], edx
        
        DEBUG_RECORD    "[DoWriteMsrForApicBase]: read from IA32_APIC_BASE"
        
        call update_guest_rip
DoReadMsrForApicBase.Done:
        pop edx
        pop ebx
        pop ebp
        ret
```

`DoReadMsrForApicBase` 函数实现在`lib\Vmx\VmxMsr.asm`文件里, 它的主要工作是:

(1) 调用 GetMsrVte 函数从**MSR VTE区域**中找到**对应的VTE表项**.

(2) 从 VTE 表项里读取 guest 尝试写入 `IA32_APIC_BASE` 寄存器里的**原值**, 写入 **guest 对应的 VSB 区域**中.

GetMsrVte 函数实现在 `lib\Vmx\VmxMsr.asm` 文件里, 

当没有 MSR 对应的 MSR VTE 表项时, 返回 0 值. 从 VTE 表项**读取MSR值**复制到 VSB(VM Store Block) 区域后, 在执行 VMRESUME 指令前, 从 **VSB 区域**恢复guest的context信息.

## 处理 guest 访问 local APIC

