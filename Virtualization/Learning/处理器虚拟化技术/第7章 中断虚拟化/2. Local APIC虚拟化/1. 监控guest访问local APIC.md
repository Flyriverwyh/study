
# 两种监控模式

VMM通过**EPT映射机制**或者`MSR-bitmap`来限制guest访问local APIC, 其原理是监控guest访问local APIC的行为并做出相应处理。

## 监控基于内存映射的local APIC访问: XAPIC

当local APIC 使用 **xAPIC** 模式, local APIC 寄存器通过 `memory-mapped`(内存映射)方式映射在**物理空间**的**4K页面**上，我们可以称这个4K页面为`APIC-page`。`APIC-page`**物理基址**在`IA32_APIC_BASE`寄存器的`bits N-1:12`里提供(N=MAXPHYADDR)

在这种情况下，VMM可以通过**EPT映射机制！！！** 来监控guest访问local APIC。

## 监控基于MSR的localAPIC访问: x2APIC

当local APIC 使用 **x2APIC** 模式(xAPIC 的扩展模式), local APIC 寄存器映射到**MSR空间**上，MSR地址范围为`800H ~ 8FFH`。guest 软件使用`RDMSR`指令读取local APIC寄存器. 使用 WRMSR 指令写入 local APIC 寄存器.

在这种情况下，VMM可以通过设置**MSR-bitmap！！！** 来监控guest访问local APIC。

# 例子: 使用EPT机制实现local APIC虚拟化

>示例7-3: 使用EPT机制实现local APIC虚拟化

上文提及，当local APIC使用**xAPIC**模式时，我们可以通过EPT映射机制来实现监控guest访问localAPIC在这一节里， 我们将使用EPT映射机制来实现local APIC虚拟化。

## 监控guest访问IA32_APIC_BASE寄存器

VMM 必须监控 guest 对 `IA32_APIC_BASE` 寄存器的访问(包括**读与写访问**), 只有这样才能够监控guest访问local APIC寄存器，如代码片段7-16所示。

```x86asm
;;
;; 设置拦截对 IA32_APIC_BASE 的读操作
;;
mov esi, IA32_APIC_BASE
call set_msr_read_bitmap        

;;
;; 设置拦截对 IA32_APIC_BASE 的写操作
;;
mov esi, IA32_APIC_BASE
call set_msr_write_bitmap
```

在`chap07\ex7-3\ex.asm`模块的`init_guest_a`与`init_guest_b`函数里，分别设置了对`IA32_APIC_BASE`的**读/写**进行拦截。`set_msr_read_bitmap` 函数**设置MSR的读访问限制**, `set_msr_write__bitmap` 函数设置MSR的写访问限制。

## 处理写IA32_APIC_BASE时产生的VM-exit

当guest执行WRMSR指令尝试写IA32_APIC_BASE寄存器时产生VM-exit。 例如，下面的 `chap07\ex7-3\guest_ex.asm` 模块代码片段7-17所示。

```x86asm
;;
;; 设置 local APIC base 值为 01000000h
;;
mov ecx, IA32_APIC_BASE
mov eax, 01000000h | APIC_BASE_BSP | APIC_BASE_ENABLE
xor edx, edx
wrmsr
```

guest 试图设置 `APIC-page` 的基址为 01000000 . 在产生 VM-exit 后, VMM调用DoWRMSR函数处理由于WRMSR指令而产生的 VM-exit .

```x86asm

```

DoWRMSR函数实现在`lib\Vmx\VmxVMM.asm`文件里.它湊取VM-exit肘的ECX寄存器値.属于IA32 APIC BASE寄存器吋，凋用DoWieMsrForApicBase来辻理guest対IA32 APIC BASE寄存器的写操作。