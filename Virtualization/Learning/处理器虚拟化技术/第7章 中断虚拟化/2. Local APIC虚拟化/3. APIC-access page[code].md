


由于 `virtualize APIC accesses` 是VMX的扩展功能, 所以在 `Secondary Processor-Based VM-Execution Controls` 中控制.

这个字段的定义如下:

```cpp
// arch/x86/include/asm/vmxfeatures.h

/* Secondary Processor-Based VM-Execution Controls, word 2 */
// 结果是 0x40
#define VMX_FEATURE_VIRT_APIC_ACCESSES  ( 2*32+  0) /* "vapic" Virtualize memory mapped APIC accesses */

// arch/x86/include/asm/vmx.h
// 结果是0
#define VMCS_CONTROL_BIT(x)     BIT(VMX_FEATURE_##x & 0x1f)
/*
 * Definitions of Secondary Processor-Based VM-Execution Controls.
 */
#define SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES VMCS_CONTROL_BIT(VIRT_APIC_ACCESSES)
```










```cpp
// arch/x86/kvm/vmx/capabilities.h
static inline bool cpu_has_vmx_virtualize_apic_accesses(void)
{
        return vmcs_config.cpu_based_2nd_exec_ctrl &
                SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;
}
```




```cpp
// arch/x86/kvm/vmx/vmx.c
static void vmx_vcpu_after_set_cpuid(struct kvm_vcpu *vcpu)
{
        struct vcpu_vmx *vmx = to_vmx(vcpu);

        /* xsaves_enabled is recomputed in vmx_compute_secondary_exec_control(). */
        vcpu->arch.xsaves_enabled = false;

        if (cpu_has_secondary_exec_ctrls()) {
                vmx_compute_secondary_exec_control(vmx);
                vmcs_set_secondary_exec_control(vmx);
        }





```cpp
static struct kvm_x86_ops vmx_x86_ops __initdata = {
        ......
        .set_virtual_apic_mode = vmx_set_virtual_apic_mode,
        ......
}
```



```cpp
kvm_arch_vcpu_create(); // arch/x86/kvm/x86.c

kvm_vcpu_reset(vcpu, false); // arch/x86/kvm/x86.c

kvm_lapic_reset(vcpu, init_event); // arch/x86/kvm/lapic.c

kvm_lapic_set_base(vcpu, APIC_DEFAULT_PHYS_BASE | MSR_IA32_APICBASE_ENABLE); // arch/x86/kvm/lapic.c

vmx_set_virtual_apic_mode(); // arch/x86/kvm/vmx/vmx.c

```






```cpp

hardware_setup(); // arch/x86/kvm/vmx/vmx.c

setup_vmcs_config(); // arch/x86/kvm/vmx/vmx.c
```