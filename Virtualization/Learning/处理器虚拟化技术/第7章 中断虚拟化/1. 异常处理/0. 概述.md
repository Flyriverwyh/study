

当guest在运行过程中可能会遇到**某些错误**引发**异常**，面由于该**异常向量号**在`exception bitmap`字段中**对应的位为1**而导致 `vm-exit` .

如果**这个异常不直接**导致`VM-exit`, 也可能会在这个异常(或其他向量事件)的delivery期间遇到了**另一个错误**(包括**异常**、**triple fault**、**任务切换**、**EPT violation**、**EPT misconfiguration**或者访问**APIC-access page**)而间接导致`VM-exit`。

尽管VMM接管了这个异常(向量事件)的控制权，并且可以做某些处理，但是如果这个异常的发生是由于**guest自身原因**而导致，那么**guest OS**总是**期望**能得到对这个异常的**最终处理**。此时，VMM不应该忽略掉这个异常，而总是需要使用**事件注人方式**将异常交回guest进行处理，这样能保证guest OS正确的行为。

因此，VMM对异常如何处理，取决于这个异常**是否由于guest 自身原因**而产生。

- 当异常是由于**guest自身条件**而引发时，VMM需要反射这个异常给guest处理，**VMM可以不做任何处理**。

- 当异常是由于**host/VMM**出于某些目的设置了**某些条件**或者VMM的**错误设置**而引发时，VMM根据自身设置的条件做相应处理，或者修正自身的错误设置后反射异常给guest处理，然后恢复guest的运行。

例如，当guest产生`#PF`异常而导致`VM-exit`时，如果`#PF异常`是由于**gust 0S**并**没有映射线性地址**而产生，那么**VMM不能插手处理**，需要**直接反射给gest处理**。但是，如果**这个线性地址**是由于VMM的有意安排而产生`#PF`异常，那么VMM根据这个情况做些处理后无须反射给guest (参考7.2.2节的例子7-1)。

又如，在**异常delivery期间**由于`EPT misconfiguration`而导致`VM-exit`时，VMM应该**修复这个故障**，然后**注人这个原始异常事件**(并不是直接引发`VM-exit`的异常)让guest恢复继续执行(即这个异常间接导致VM-exit)，

然而有一个特殊的例子，在VMX non root operation模式里尝试进行**任务切换**将直接产生VM-exit。当guest运行在 legacy 模式时，并不是guest的错误，也不是VMM本身的错误。因此，VMM必须要帮助guest来完成这个任务切换操作(参考7.1.3节例子7-2)。
