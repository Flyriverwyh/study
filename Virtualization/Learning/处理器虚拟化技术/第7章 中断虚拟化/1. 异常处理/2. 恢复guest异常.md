
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [直接恢复](#直接恢复)
  - [处理NMI unblocking位](#处理nmi-unblocking位)
- [示例](#示例)
  - [监控SYSENTER指令的原理及实现](#监控sysenter指令的原理及实现)

<!-- /code_chunk_output -->

当guest引发异常的条件是host/VMM所设置时，VMM取消引发guest 异常的条件后使用 VMRESUME 指令恢复 guest 的运行.

# 直接恢复

当异常直接引发`VM-exit`, 也就是 `IDT-vectoring information` 字段`bit 31`为0 (不是间接引发`VM-exit`)时。尽管 `VM-exit interruption information` 字段记录了引发VM-exit的异常。但是，由于异常是host的原因引发，并不是guest 造成的，因此VMM无须反射异常给guest处理(忽略这个异常)，可以直接执行 VMRESUME 指令恢复guest 执行。

## 处理NMI unblocking位

当 `VM-exit interruption information` 字段的“`NMI unblocking`"位为1时，表明由于尝试执行IRET指令而解除了“blocking by NMI"阻塞状态，但是IRET指令并没有成功执行。

在这种情况下，VMM在执行VMRESUME指令前，需要将interruptility state字段bit3置1, 用来反馈guest在执行IRET指令前存在“blocking by NMI”阻塞状态。恢复guest执行后，guest 完成IRET指令的执行将自动解除"blocking by NMI"阻塞状态。当pin-based VM-execution control 字段的“`virtual NMIs`"为1 (“`NMI exiting`"也为1)，VM-exit interruption information 字段的“NMI unblocking" 为1时，表明尝试执行IRET指令而解除了"blocking by virtual-NM1"阻塞状态。

同样，VMM需要将 `interrupibility state` 字段bit 3置1,反馈guest在执行IRET指令前存在 "`blocking by virtual-NMI`" 阻塞状态，然后执行VMRESUME指令恢复guest执行。

注意: 当 `VM-exit interruption information` 字段记录的向量号为8 (`#DF`异常)时，`VM-exit interruption information` 字段的 `bit 12` 是未定义(参见3.10.2.1节)，VMM不需要对`interruptibility state` 字段进行额外的设置。

# 示例

>实现对SYSENTER指令的监控

现在，我们用一个例子来说明VMM直接恢复guest 执行而忽略产生的异常事件，这个例子实现了对guest 用户层代码执行**SYSENTER指令**的监控。本例子的代码在`chap07\ex7-1`目录下。

## 监控SYSENTER指令的原理及实现

用户层代码通过SYSENTER指令来快速切入kernel的服务例程，目标代码人口的线性地址提供在 `IA32_SYSENTER_EIP` 寄存器里。VMM通过设置`IA32_SYSENTER_EIP` 寄存器在 **MSR write bitmap** 区域里对应的位置1, 来监控guest更新 `IA32_SYSENTER_EIP` 寄存器。

当 guest 尝试使用WRMSR指令向`IA32_SYSENTER_EIP`寄存器写人系统服务例程人口地址时产生`VM-exit`。VMM将拦截 guest 的写人动作，使用一个预先定义的**签名值**来代替这个系统服务例程人口地址值写人 `IA32_SYSENTER_EIP` 寄存器。

当guest 执行SYSENTER指令时，由于**目标地址无效**(写人的**签名值**)而产生`#PF`异常，VMM拦截了`#PF`异常后(由于`#PF`异常而导致`VM-exit`)，**VMM**检查引发`#PF`异常的**源地址值**是否为这个**签名值**，如果属于则找回guest原系统服务例程的人口地址，直接恢复guest的执行。

代码片段7-1:

”: 定义一个SYSENTER EIP hook签名

Sdefine SYSENTER HOOK SIGN

'HOOK'

在ex.asm 文件的开头，我们定义一个SYSENTER HOOK_ SIGN常量作为hookIA32_ SYSENTER_ EIP 寄存器的签名值。

代码片段7-2:

设置拦被对IA32_ sYsENTER EIP的写操作