
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [直接恢复](#直接恢复)
  - [处理NMI unblocking位](#处理nmi-unblocking位)

<!-- /code_chunk_output -->

当guest引发异常的条件是host/VMM所设置时，VMM取消引发guest 异常的条件后使用 VMRESUME 指令恢复 guest 的运行.

# 直接恢复

当异常直接引发`VM-exit`, 也就是 `IDT-vectoring information` 字段`bit 31`为0 (不是间接引发`VM-exit`)时。尽管 `VM-exit interruption information` 字段记录了引发VM-exit的异常。但是，由于异常是host的原因引发，并不是guest 造成的，因此VMM无须反射异常给guest处理(忽略这个异常)，可以直接执行 VMRESUME 指令恢复guest 执行。

## 处理NMI unblocking位

当 `VM-exit interruption information` 字段的“`NMI unblocking`"位为1时，表明由于尝试执行IRET指令而解除了“blocking by NMI"阻塞状态，但是IRET指令并没有成功执行。

在这种情况下，VMM在执行VMRESUME指令前，需要将interruptility state字段bit3置1, 用来反馈guest在执行IRET指令前存在“blocking by NMI”阻塞状态。恢复guest执行后，guest 完成IRET指令的执行将自动解除"blocking by NMI"阻塞状态。当pin-based VM-execution control 字段的“`virtual NMIs`"为1 (“`NMI exiting`"也为1)，VM-exit interruption information 字段的“NMI unblocking" 为1时，表明尝试执行IRET指令而解除了"blocking by virtual-NM1"阻塞状态。

同样，VMM需要将 `interrupibility state` 字段bit 3置1,反馈guest在执行IRET指令前存在 "`blocking by virtual-NMI`" 阻塞状态，然后执行VMRESUME指令恢复guest执行。

注意: 当 `VM-exit interruption information` 字段记录的向量号为8 (#DF异常)时，VM-exit interruption information 字段的bit 12 是未定义(参见3.10.2.1节)，VMM不需要对interruptibility state字段进行额外的设置。