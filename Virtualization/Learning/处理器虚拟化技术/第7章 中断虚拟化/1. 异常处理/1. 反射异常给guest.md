

由于异常而引发`VM-exit`时，`VM- exit interruption information` 字段将记录这个异常的**delivery信息**(参见3.10.2.1节)，并且**有错误码**时，在`VM-exit interruption error code`字段里记录异常的错误码。

一般情况下， VMM可以直接将`VM-exit interruption information`字段的值复制给`VM-entry interruption information`字段，将`VM-exit interruption error code`字段的值复制给`VM-entry nterruption error code`字段(**存在错误码时**) .

# 处理NMI unblocking位

`VM-entry interruption information`字段的`bits 30:12`属于**保留位**，在注入事件时必须清为0值。

然而，`VM-exit interruption information` 字段的`bit 12`为"`NMI unbocking`" 位。当这个异常是在执行**IRET指令**时引发并导致`VM-exit`, `VM-exit interruption information`字段的`bit 12`被置位。此时，VMM需要将复制到`VM entry ineruption informatin` 字段的`bit 12`清0, 否则将会产生`VM-entry`失败。

因此，每次**反射异常给guest**时，VMM需要检查`VM-exit interruption information` 字段的`bit 12`, 做出相应的处理。

# 反射`#DF`异常

当 `IDT-vectring information` 字段的bit 31 (valid位) 为1时，表明这个字段所记录的向量事件并**不直接引发VM-exit**. 而是由于在**异常delivery 期间**遇到某些错误而导致`VM-exit`(参见3.10.3节). 

那么 `IDT-vectoring information` 字段记录**原始向量事件**的**delivery信息**, `IDT-vectoring error code`字段记录**原始异常的错误码**.

在如表 `7-1` 所示的情况下VMM需要反射一个`#DF`(Double Fault)异常给guest.

![2020-08-02-20-57-33.png](./images/2020-08-02-20-57-33.png)


......

# 处理 triple fault

下面的三种情况会产生**triple fault**(异常属于前面所说的第1类或者第2类情况):

(1) 当 guest 遇到**异常**但并**不导致**`VM-exit`, 继而在这个**异常delivery期间**引发了**另一个异常**，这个异常也不导致VM-exit,从而这两个异常被转化为#DF异常。#DF异常也不导致VM-exit,继而在#DF异常的delivery期间再次引发了-一个异常，最终转化为triplefault而导致VM-exit。

(2) VMM注入一个**硬件异常**，在这个注人异常的delivery 期间引发了一 个异常，这个异常并不导致VM-exit, 从而转化为#DF异常。#DF异常也不导致VM-exit, 继而在#DF异常的delivery期间再次引发了-一个异常，最终转化为triple fault而导致VM-exit。

(3) VMM注人一个硬件异常#DF,在这个注人的#DF异常delivery 期间引发了一 一个异常，最终转化为triple fault而导致VM-exit。

由triple fault 直接引发VM-exit时，VMM不应该注人任何事件给guest执行。VMM可以选择终止guest的运行，或者将VM置为shutdown状态。当VM处于shutdown状态时，NMI、SMI及INIT事件能唤醒shutdown状态转为active状态(参见4.17.3节)

# 直接反射异常

当异常由 guest **自身条件所引发**时，在下面的情况下VMM可以直接反射异常给guest处理。

(1)由异常直接导致`VM-exit`时， 也就是`IDT-vectoring information`字段`bit 31`**为0**。

(2)不属于表7-1中的第1类和第2类情况时(不产生#DF异常)，由于向量事件delivery期间遇到一 个异常而导致VM-exit。

例如，guest 运行过程中引发了#GP异常，#GP 异常不导致VM-xit。但在#GP异常delivery期间遇到了#PF异常而导致VM-exit。 这种情况下并不会产生#DF异常，VMM需要直接将#PF异常反射给guest处理。

VMM 可以直接将 VM-exit interruption information 字段的值赋值给 `VM-entryinterruption information` 字段, 将 `VM-exit interruption error code` 字段的值直接赋给 `VM-entry interruption error code` 字段(存在错误码时), 通过事件注入反射给 guest 处理.

7.1.2 tks guest 91

当guest引发异常的条件是host/VMM所设置时，VMM取消引发guest 异常的条件GfR VMRESUME H>R guest é9iäfi.

7.1.2.1 IietE

当异常直接引发VM-exit,也就是IDT-vectoring information 字段bit 31为0 (不是间5I2 VM-exit) Bt. 4 VM-exit iteruption information ŸRickT 5l2 VM-exit á95常。但是，由于异常是host的原因引发，并不是guest造成的，因此VMM无须反射异guest LH (2i↑9R) . aJVXTIRAfT VMRESUME tiety guest fT.

sba NMI unblocking 12

s VM-exit interruption information YEéJ "NMI unblocking" fZ95 1Bf, jdF#试执行IRET指令而解除了"blocking by NMI"阻塞状态，但是IRET指令并没有成功FT.

EEiRF, VMM tEAfi VMRESUME His 0, E interruptibility state 4段bit3置1,用来反馈guest在执行IRET指令前存在"blocking by NMI"阻塞状态。恢y guest BAfTlá, guest 9ER IRET 1i49fT ëJhNWPÔe "blocking by NMI" PHHtaS.a pin-based VM-execution control ŸEéJ virtual NMIs" 'y1 ( "NMI exiting" t,1) . VM-exit interruption information YE0J "NMI unblocking" 7h I Bf, 9ittAfiIRET 1i4 diM Y - blocking by virtual-NMl" LXS.