

也就是将中断注入给虚拟机???

# 两个字段: info和error code

由于异常而引发`VM-exit`时，
* `VM-exit interruption information` 字段将记录这个异常的**delivery信息**(参见`3.10.2.1`节)，
* 并且**有错误码**时，在`VM-exit interruption error code`字段里记录异常的错误码。

一般情况下， VMM可以直接
* 将`VM-exit interruption information`字段的值复制给`VM-entry interruption information`字段，
* 将`VM-exit interruption error code`字段的值复制给`VM-entry nterruption error code`字段(**存在错误码时**) .

# 1. 处理NMI unblocking位

`VM-entry interruption information`字段的`bits 30:12`属于**保留位**，在**注入事件时**必须清为0值。

然而，`VM-exit interruption information` 字段的`bit 12`为"`NMI unblocking`" 位。当这个异常是在执行**IRET指令**时引发并导致`VM-exit`, `VM-exit interruption information`字段的`bit 12`**被置位**。此时，VMM需要将复制到`VM entry ineruption informatin` 字段的`bit 12`清0, 否则将会产生`VM-entry`失败。

因此，每次**反射异常给guest** 时，VMM需要检查`VM-exit interruption information` 字段的`bit 12`, 做出相应的处理。

# 2. 反射`#DF`异常

当 `IDT-vectoring information` 字段的`bit 31` (valid位) 为1时，表明这个字段所记录的向量事件并**不直接引发VM-exit**, 而是由于在**原始异常delivery期间**遇到**某些错误**而导致`VM-exit`(参见3.10.3节). 

那么:
* `IDT-vectoring information` 字段记录**原始向量事件**的**delivery信息**, 
* `IDT-vectoring error code`字段记录**原始异常的错误码**.

在如表 `7-1` 所示的情况下VMM需要反射一个`#DF`(Double Fault)异常**给guest**.

![2020-08-02-20-57-33.png](./images/2020-08-02-20-57-33.png)

当 guest 在执行过程中引发了表 7-1 中 IDT- vectoring information 字段所记录的异常，或者注入了表中 IDT- vectoring information 字段所记录的硬件异常（中断类型为硬件异常），但这个异常并不直接导致 VM-exit，而在 delivery 期间遇到了表 7-1 中 VM-exit  interruption information 字段所记录的嵌套异常而导致 Vm-exit（另外参见 4.12.2 节）

也就是下面两类情况，#DF 异常最终会被产生。

第 1 类情况：

・遇到的异常（或者注入的硬件异常）是 DE（向量号 0)、#S（向量号 10) NP（向量号 11)、#SS（向量号 12) 或者#GP（向量号 13) 之

・异常 delivery 期间遇到了#DE（向量号 0)、#打 S（向量号 10)、#NP（向量号 11)、#SS（向量号 12) 或者#GP（向量号 13) 之

第 2 类情况：

遇到的异常（或者注入的硬件异常）是 PF（向量号 14)。

・异常 delivery 期间遇到了排 PF（向量号 14)、#DE（向量号 0)、#S（向量号

10)、NP（向量号 11)、#S（向量号 12) 或者#GP（向量号 13) 之

属于上面两类情况时，在正常情况下这两个异常会转化为一个 DF 异常  fault，双重故障）。但由于嵌套异常 delivery 期间引发的异常直接引发了 Vm-exit，为了模拟 guest 产生的 DF 异常，VMM 需要注入一个硬件异常 DF 给 guest，而不是嵌套异常。

举例来说，guest 在执行中产生了#SS 异常，但这个#S 异常并不引发 Vm-exit，继而

在这个#SS 异常的 delivery 期间遇到了一个#GP 异常而导致 VM-exit。此时 VMM 需要反
......

# 3. 处理 triple fault

下面的三种情况会产生**triple fault**(异常属于前面所说的第1类或者第2类情况):

(1) 当 guest 遇到**异常**但并**不导致**`VM-exit`, 继而在这个**异常delivery期间**引发了**另一个异常**，这个异常也不导致VM-exit,从而这两个异常被转化为#DF异常。#DF异常也不导致VM-exit,继而在#DF异常的delivery期间再次引发了-一个异常，最终转化为triplefault而导致VM-exit。

(2) VMM注入一个**硬件异常**，在这个注人异常的delivery 期间引发了一 个异常，这个异常并不导致VM-exit, 从而转化为#DF异常。#DF异常也不导致VM-exit, 继而在#DF异常的delivery期间再次引发了-一个异常，最终转化为triple fault而导致VM-exit。

(3) VMM注人一个硬件异常#DF,在这个注人的#DF异常delivery 期间引发了一 一个异常，最终转化为triple fault而导致VM-exit。

由triple fault 直接引发VM-exit时，VMM不应该注人任何事件给guest执行。VMM可以选择终止guest的运行，或者将VM置为shutdown状态。当VM处于shutdown状态时，NMI、SMI及INIT事件能唤醒shutdown状态转为active状态(参见4.17.3节)

# 4. 直接反射异常

当异常由 guest **自身条件所引发**时，在下面的情况下VMM可以直接反射异常给guest处理。

(1)由异常直接导致`VM-exit`时， 也就是`IDT-vectoring information`字段`bit 31`**为0**。

(2)不属于表7-1中的第1类和第2类情况时(不产生#DF异常)，由于向量事件delivery期间遇到一 个异常而导致VM-exit。

例如，guest 运行过程中引发了#GP异常，#GP 异常不导致VM-xit。但在#GP异常delivery期间遇到了#PF异常而导致VM-exit。 这种情况下并不会产生#DF异常，VMM需要直接将#PF异常反射给guest处理。

VMM 可以直接将 VM-exit interruption information 字段的值赋值给 `VM-entryinterruption information` 字段, 将 `VM-exit interruption error code` 字段的值直接赋给 `VM-entry interruption error code` 字段(存在错误码时), 通过事件注入反射给 guest 处理.