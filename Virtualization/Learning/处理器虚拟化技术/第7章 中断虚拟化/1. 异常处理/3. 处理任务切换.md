
# 

在 `VMX non-root operation` 模式内，尝试 **TSS 机制**的**任务切换**会产生 `VM-exit`。包括了下面的途径：

* guest 使用 `TSS selector` 或者 `Task-gate selector` 作为 **far pointer** 来执行 **CALL**、**JMP** 指。

* guest 执行 **IRET** 指令时, 由于 `EFLAGS.NT=1` 而发起任务切换。

* 在一个**向量事件**（中断或异常）**delivery 期间**尝试**任务切换**，即向量号在 **guest IDT** 对应的**描述符**是 `task-gate` 描述符。

由于 **VMX 不支持 guest 进行任务切换**（利用 **TSS** 机制），因此在 guest 由于尝试进行任务切换而产生 VM-exit 时，VMM 需要模拟 guest 的任务切换来代替处理器的操作（guest 运行在 legacy 模式下）。

VMM 整个模拟任务切换的过程大致可以分为三个阶段

(1) 处理器检查是否满足任务切换条件阶段。

(2) VMM 模拟处理器任务切换阶段。

(3) VMM 根据情况进行 guest 相应恢复执行阶段。

其中，在第 2 阶段的任务切换处理非常烦琐。而在第 3 阶段里，VMM 需要根据情况反射一个异常给 guest 处理，或者跳转去执行 guest 的新任务。第 1 阶段的工作由处理器自动完成，主要是检查是否允许进行任务切换。

# 检查任务切换条件

进行 TSS 任务切换是一个非常复杂的过程，在 Iong-mode (A-32c）模式下处理器不支持 TSS 的任务切换机制。在由于任务切换而导致 Vm-exit 之前，处理器进行一系列的检查，确认满足任务切换的条件。如果检查不通过则引发异常，如果检查通过则产生  Vm-exit.

## 使用 TSS selector 进行任务切换

CALL 或 JMP 指令使用 TSS selector 作为 far pointer 进行任务切换时，处理器进行下面的检查。

(1) 检查 selector 是否为 NULL selector。属于 NULL selector 时产生#GP 异常。

(2) 检查 selector 是否超过描述符表的 limit。超过 limit 则产生#GP 异常。

(3) 读取描述符进行类型检查：

* 属于 TSS 描述符，在 1A-32e 模式下则产生 #GP 异常

* 属于其他不支持的类型（非代码段描述符、TSS 描述符以及 Task-gate 描述符），则产生#GP 异常。

(4) 检査访问权限。假如 TSS 描述符的 DPL 小于 CPL 或者 RPL，则产生 GP 异常。

(5) 检查 TSS selector 的 T 位（bit2)。TI=1 时产生 GP 异常。

(6) 检査 TSS 描述符是否为 busy。属于 busy 则产生#GP 异常。

(7) 检查 TSS 描述符是否为 present。属于 not-present 则产生#NP 异常。

## 使用 Task-gate 进行任务切换

CALL 或 JMP 指令使用 Task- gate selector 作为 far pointer 尝试任务切换。中断、异常或注入事件 delivery 期间引用 IDT 的 ask-gate 描述符时，处理器进行下面的检查。

(1) CALL 或 JMP 指令检查 Task- gate selector

* 检查 Task gate selector 是否为 NULL selector。属于 NULL selector 时产生 GP 异

* 检查 Task- gate selector 是否超过描述符表的 limit。超过 limit I 时产生 GP 异常。

(2) 中断、异常或者注入事件 deliver I 时检查向量号。

* 检查向量号是否超过 IDT limit。超过 IDT limit 时产生#GP 异常。

(3) 根据 Task-gate selector 读取 Task-gate 描述符检查

* 在 IA-32e 模式下产生 `#GP` 异常。

(4) 检访问权限，产生或者注入的 NMI、外部中断、硬件异常不需要检查权限。

* 产生或者注入软件中断或软件异常（INT、INT3 及 INTO): Task-gate 描述符的 DPL 小于 CPL 时，产生 P 异常。

* 由 CALL 或 JMP 指令发起：Task-gate 描述符的 DPL 小于 CPL 或者 RPL 时，产生 #GP 异常。

(5) 检查 Task-gate 描述符是否为 present。属于 not-present 则产生排 NP 异常。

(6) 从 Task-gate 描述符里读取 TSS selector，检查 TSS selector

* TSS selector I 的 TI 位（bit2) 为 1 时，产生 GP 异常。

* TSS selector 超过 GDT limit 时，产生 GP 异常

(7) 根据 rss selector 读取 TSS 描述符检查。

* TSS描述符属于 busy时，产生 #GP 异常。

* TSS 描述符属于 not present 时，产生 #NP 异常。

## 使用 IRET 进行任务切换

当执行 IRET 指令，EFLAGS.NT=1 时，处理器进行下面的检查。

(1) 在 1A-32e 模式下，则产生 #GP 异常。

(2) 从当前 TSS 块内的 Task-link 读取 TSS selector 检查 TSS selector 的 T 位（bit2) 为 1 时，产生#GP 异常  TSS selector 超过 GDT limit 时，产生#GP 异常。

(3) 根据 TSS selector 读取 TSS 描述符检查。

* 如果不是 TSS 描述符，产生#TS 异常。

* TSS 描述符不属于 busy 时，产生#S 异常。

(4) TSS 描述符属于 not- present 时，产生 NP 异常。

在对上面三个途径下的任务切换进行相应的检查后，处理器确认允许执行任务切换的条件满足。但是如前面所述，VMX non- root operation 下不允许进行任务切换。因此接着会产生 VM-exit

# VMM 处理任务切换

guest 在尝试任务切换时，经过前面的满足条件检查后产生 VM-exit。VMM 拦截了  guest 任务切换动作，但是 VMM 必须支持 guest Os 进行任务切换。因此，在这个阶段里 VMM 的任务是帮助 guest 完成任务切换操作。

不能通过事件注入方式反射事件给 guest处理，VMM应该模拟处理器的任务切换动作。在 MIBVMXIVMXVMM.asm 文件里实现了 Dotask Switch 函数处理 guest 的任务切换。