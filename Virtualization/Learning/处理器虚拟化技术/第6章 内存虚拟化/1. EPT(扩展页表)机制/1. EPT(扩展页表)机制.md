
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [4. guest physical address](#4-guest-physical-address)
- [5. EPTP](#5-eptp)
  - [5.1. EP4TA 域](#51-ep4ta-域)
- [6. 4K 页面下的 EPT 页表结构](#6-4k-页面下的-ept-页表结构)
- [13. 实现 EPT 机制](#13-实现-ept-机制)

<!-- /code_chunk_output -->


# 4. guest physical address

每个GPA(guest-physical address)值为64位宽. 但是, 当前VMX架构实现最高48位有效的GPA值(`bits 47:0`)

# 5. EPTP

EPT 页表结构**顶层**的 **PML4T 物理地址**由 EPTP(Extended Page Table Pointer, 扩展页表指针)字段提供(见3.5.17). PML4T的物理地址也被称为 "EP4TA" (`EPTP[N-1:12]`), 它用于标识一个cache域. 注意, 这个物理地址属于HPA, 对齐在 4K 边界上. 如图6-3所示.

![2020-02-25-15-27-19.png](./images/2020-02-25-15-27-19.png)

- PML4T 的物理地址(host physical address)值由 EPTP 字段的 `bit N-1:12`提供(N=MAXPHYADDR). 例如, 当 MAXPHYADDR = 36 时, EPTP 的 bits 35:12 是PML4T 地址值, bits 63:36 是保留位.
- bits
- `bits 5:3`设置EPT页表的walk长度, 也就是访问EPT页表的级数. 这个值必须设置为3(指示需要经过4级页表的walk). EPT支持**4级EPT页表**可以从 `IA32_VMX_EPT_VPID_CAP` 寄存器bit6查询得到(参见 2.5.13 节).

当 "enable EPT" 为 1 时, EPTP 值在 VM-entry 时从EPTP字段里加载, 记录在处理器内部寄存器中(推测). EPTP字段的设置必须符合设置要求(见4.4.1.3).

注: `EPTP[2:0]`所指定的内存类型, 使用在 EPT paging structure(EPT的页表结构)数据本身中. 它属于

## 5.1. EP4TA 域




# 6. 4K 页面下的 EPT 页表结构

在 4K 页面下, guest physical address被分割为下面的部分.

(1)

guest physical address的`bits 63:48` 被忽略(见6.1.3). **GPA**转换到**HPA**需要经过 4 级 EPT 页表结构(walk 次数为 4), 如图6-4.

![2020-02-24-23-32-30.png](./images/2020-02-24-23-32-30.png)



















# 13. 实现 EPT 机制