
在系统平台上两个最重要的数据结构是: **PCB**(`Processor Control Block`, **处理器控制块**)以及**SDA**(`System Data Area`, **系统数据区域**).

它们定义在 `inc/system_manage_region.inc` 文件中.

注: PCB与SDA结构内所有的地址值都是64位宽. 这样的设计使得结构很容易适应于32位与64位环境.

# PCB结构

每个逻辑处理器对应一个PCB结构, 也就是每个逻辑处理器有独立的PCB结构. 用来维护管理与处理器相关的信息.

下面将介绍PCB结构内主要的数据.

## 访问GS段

我们使用**PCB结构基址**作为**GS段的基址**. 因此, **代码**总是使用**GS段** 来访问**PCB结构内的数据**. 

在`common/protected.asm`模块里将**32位**的`PCB.Base`值写入`GS.base`. 代码如下.

```

```

在`common/long.asm`模块里将**64位**的`PCB.base`值写入`GS.base`, 如下代码.

```asm
;;
;; 读 GS base 值，以备下一步更新
;;
mov esi, [gs: PCB.Base]
mov edi, [gs: PCB.Base + 4]

... ...


```

`PCB.base`存放64位的PCB基址, 只能通过`WRMSR`指令写`IA32_GS_BASE`寄存器来达到写入64位`GS.base`值.

在`stage1`阶段下(未分页保护模式), `GS.base`存放**PCB的物理基址**. 在进入`stage2`(**分页的保护模式**)或`stage3`阶段(`64-bit`模式)前, `GS.base`将写入**线性地址**.

## 引用的其他区域基址

在PCB结构内定义了若干个64位宽的地址值, 用来保存所引用的其他区域基址. 下面是PCB结构的部分定义.

```

```

**PCB结构偏移量**为`0`处是`PCB.Base`, 它指向**PCB块本身**. 因此, 在代码里任何使用都可以使用**下面指令**读取**PCB块基址**.

```
%ifdef __X64
    LoadGsBaseToRbp
%else
    mov ebp, [gs:PCB.Base]
%endif
```

`PCB.SdaBase`指向全局的SDA(System Data Area)区域, 在源码里, 通常像下面指令示例一样读取SDA基址.

```asm
%ifdef __X64
    LoadGsBaseToRbp
%else
    mov ebp, [gs:PCB.base]
%endif
    REX.Wrxb                        ; 用于x64
    Mov ebx, [ebp + PCB.SdaBase]    ; 读取SDA基址
```

## 描述符标管理记录

PCB结构内部分管理记录与描述符表相关.

代码如下.



## 处理器信息

PCB结构有很大一部分值用来维护和记录与处理器相关的信息. 代码如下.

