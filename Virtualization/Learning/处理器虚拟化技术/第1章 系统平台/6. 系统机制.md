
# 分页机制

可以参考: `Architecture/x86/IA32和x64架构分页数据结构`

系统运行在stage2阶段使用PAE分页模式, 运行在stage3阶段使用IA\-32e分页模式. 

PAE分页模式的页表结构很大程度参考了Windows NT的设计.

而**IA\-32e分页模式**在映射时**PDT**与**PT表**采用了**动态分配**的策略.

## PAE分页模式实现

2 + 9 + 9 + 12

PAE分页模式下存在`PDPT`、`PDT`和`PT`三级页表结构, 在 `inc/page.inc`文件中定义了PAE分页模式下的三个页表结构地址值:

- `PT_BASE` 与 `PT_TOP`, **值**分别为 `C0000000H` 与 `C07FFFFFH`, 这个PT区域共**8MB**, 是**整个PAE分页模式**下的**页表结构区域**, 这里是**虚拟地址**区域.
- `PT_PHYSICAL_BASE` 与 `PT_PHYSICAL_TOP`, 值分别为 `200000H` 与 `9FFFFFH`, 定义PT区域的**物理地址**.
- `PDT_BASE` 与 `PDT_TOP`, 值分别为 `C0600000H` 与 `C0603FFFH`, 共**16KB**. PDT区域**内嵌在PT区域内**, 这里是**虚拟地址**区域.
- `PDT_PHYSICAL_BASE` 与 `PDT_PHYSICAL_TOP`, 值分别为 `800000H` 与 `803FFFH`, 定义PDT区域的**物理地址**.

在Windows NT设计中, `PDPT_BASE` 与 `PDPT_TOP` 值分别为 `C0603000H` 与 `C060301FH`, 也嵌在PDT区域内. 但我们这里, 将这个 **32字节(4 x 8字节**)的PDPT区域移到了SDA.Ppt区域内, 并没有使用内嵌的PDPT区域.

注: 这个8MB、16KB和32字节, 可参照`Architecture/x86/IA32和x64架构分页数据结构 3.1 4Kb页面线性地址翻译`

SDA.Ppt存放在**4个PDPTE表项**, 在初始化时分别指向**4个PDT区域**, 如图1-7.

![2019-12-30-10-56-23.png](./images/2019-12-30-10-56-23.png)

**整个PT区域**的**物理地址**区域是从 `200000H` 到 `9FFFFFH`(共8MB), 对应**虚拟地址** `C0000000H` 到 `C07FFFFFFH`.

### 初始化页表结构

在 `pre-stage2` 阶段(protected模块头部, 参见 1.5.3 节代码片段 1-41)调用`init_ppt_area`函数初始化PDPT区域.

```assembly

```

`init_ppt_area`函数所做的工作是: 将**4个PDT区域**的**物理地址**写入`SDA.Ppt`区域内. 形成下面4个PDPTE的设置:

⓵ `PDPT[0]`(地址为SDA.Ppt)写入值 `800000H`.

⓶ `PDPT[1]`(地址为SDA.Ppt + 8)写入值 `801000H`.

⓷ `PDPT[2]`(地址为SDA.Ppt + 16)写入值 `802000H`.

⓸ `PDPT[3]`(地址为SDA.Ppt + 24)写入值 `803000H`.

注: 这里写入的是物理地址, 一个PDPTE占用空间是8字节(所以加8), 一个PDT占用空间是4KB(2\^12, 所以值每次加 1000H)

在 `pre-stage2` 阶段也调用了`init_pae_page`函数建立基本的页映射关系(参见`1.5.3`节代码片段`1-42`). `init_pae_page`函数内部调用`map_pae_