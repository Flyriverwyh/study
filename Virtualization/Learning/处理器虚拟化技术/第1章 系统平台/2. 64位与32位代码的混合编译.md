可以将本书源码编译为64位版本.

多数模块, 只需要维护一份代码, 即并不需要分别编写64位版本以及32位版本的代码. 极少部分才区分

# 使用符号__X64

为了做到64位和32位版本只维护一份代码, 需要将代码以32位形式进行编译. 同时, 引进__X64符号控制机器码的生成.

```assembly
bits 32             ;;重要, 以32位形式进行编译
        ... ...
%ifdef __X64
        ;;
        ;; 此处插入64位特定的代码!
        ;;
%else
        ;;
        ;; 此处插入32位特定的代码!
        ;;
%endif
        ... ...
```

注意: 由于在64-bit模式下, 绝大多数指令的操作位默认为32位, 导致多数指令机器码在64位和32位环境下是一样的! 只有少量的指令, 我们需要进行特别处理. 因此, 引进`__X64`是为了解决某些特定指令的使用.

代码统一在32位下编译后, 处理器无论运行在64-bit模式下, 还是32位保护模式下, 都能正确执行. 当然, 除了某些需要特殊处理器的指令, 下面了解一下.

# 指令操作数

64位和32位混合编译之前, 有必要先了解下x86/64体系中指令的operand size(操作数宽度), 以及address size(地址宽度)相关知识. 更详细介绍看 http://www.mouseos.com/x64/index.html .

指令的操作数大小及地址大小有default(默认)和effective(有效)两种情况. 表1\-1列出处理器各种工作模式下的default operand size(默认操作数宽度)与default address size(默认地址宽度), effective operand size(有效的操作数宽度)与effective address size(有效的地址宽度).

![2020-01-24-22-29-47.png](./images/2020-01-24-22-29-47.png)

![2020-01-24-22-33-24.png](./images/2020-01-24-22-33-24.png)

指令的默认operand size、address size由CS.D和CS.L位(IA\-32e/long\-mode可用)决定.

- 

...

# 64-bit模式下的其他指令处理

