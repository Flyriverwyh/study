

vmcb是一个4KB对齐的页面, 在创建vcpu时候

```cpp
// arch/x86/kvm/svm/svm.c
static int svm_create_vcpu(struct kvm_vcpu *vcpu)
{
        struct vcpu_svm *svm;
        struct page *vmcb_page;
        struct page *vmsa_page = NULL;
        ......
        vmcb_page = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO); // 分配了一个页面
        ......
        svm->vmcb = page_address(vmcb_page); // 虚拟地址
        svm->vmcb_pa = __sme_set(page_to_pfn(vmcb_page) << PAGE_SHIFT);
```



```cpp
static noinstr void svm_vcpu_enter_exit(struct kvm_vcpu *vcpu,
                                        struct vcpu_svm *svm)
{
        ......
        if (sev_es_guest(svm->vcpu.kvm)) {
                __svm_sev_es_vcpu_run(svm->vmcb_pa);
        } else {
                __svm_vcpu_run(svm->vmcb_pa, (unsigned long *)&svm->vcpu.arch.regs);
        ......
```

```x86asm
//arch/x86/kvm/svm/vmenter.S
/**
 * __svm_vcpu_run - Run a vCPU via a transition to SVM guest mode
 * @vmcb_pa:    unsigned long
 * @regs:       unsigned long * (to guest registers)
 */
SYM_FUNC_START(__svm_vcpu_run)
        ......
        /* Save @vmcb. */
        // 将vmcb_pa压栈
        push %_ASM_ARG1
        ......
        // vmcb_pa出栈, 赋值给RAX寄存器
        /* "POP" @vmcb to RAX. */
        pop %_ASM_AX

        /* Enter guest mode */
        sti
1:      vmload %_ASM_AX
        jmp 3f
2:      cmpb $0, kvm_rebooting
        jne 3f
        ud2
        _ASM_EXTABLE(1b, 2b)

3:      vmrun %_ASM_AX

```