
# 

在创建vcpu时候, 分配了一个4KB的页面用于vmcb

```cpp
// arch/x86/kvm/svm/svm.c
static int svm_create_vcpu(struct kvm_vcpu *vcpu)
{
        struct vcpu_svm *svm;
        struct page *vmcb_page;
        struct page *vmsa_page = NULL;
        ......
        svm = to_svm(vcpu); // 获取kvm_vcpu的vcpu_svm, 即获取vcpu对应的svm运行环境, 这两个一对一的
        vmcb_page = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO); // 分配了一个页面
        ......
        svm->vmcb = page_address(vmcb_page); // 虚拟地址
        svm->vmcb_pa = __sme_set(page_to_pfn(vmcb_page) << PAGE_SHIFT); // 物理地址
```

在后续vcpu run时候, 将这个物理地址作为参数传递, 然后作为`vmrun`命令的参数.

```cpp
static noinstr void svm_vcpu_enter_exit(struct kvm_vcpu *vcpu,
                                        struct vcpu_svm *svm)
{
        ......
        if (sev_es_guest(svm->vcpu.kvm)) {
                __svm_sev_es_vcpu_run(svm->vmcb_pa);
        } else {
                __svm_vcpu_run(svm->vmcb_pa, (unsigned long *)&svm->vcpu.arch.regs);
        ......
```

```x86asm
//arch/x86/kvm/svm/vmenter.S
/**
 * __svm_vcpu_run - Run a vCPU via a transition to SVM guest mode
 * @vmcb_pa:    unsigned long
 * @regs:       unsigned long * (to guest registers)
 */
SYM_FUNC_START(__svm_vcpu_run)
        ......
        /* Save @vmcb. */
        // 将vmcb_pa压栈
        push %_ASM_ARG1
        ......
        // vmcb_pa出栈, 赋值给RAX寄存器
        /* "POP" @vmcb to RAX. */
        pop %_ASM_AX

        /* Enter guest mode */
        sti
        /* 虚拟机状态还原 */
1:      vmload %_ASM_AX
        jmp 3f
2:      cmpb $0, kvm_rebooting
        jne 3f
        ud2
        _ASM_EXTABLE(1b, 2b)

3:      vmrun %_ASM_AX
```

# Writeback回写内存


# 主机状态保存区域

## per-cpu的svm_data

声明了`per-cpu`变量(指针)`svm_data`

```cpp
// arch/x86/kvm/svm/svm.h
struct svm_cpu_data {
        int cpu;

        u64 asid_generation;
        u32 max_asid;
        u32 next_asid;
        u32 min_asid;
        struct kvm_ldttss_desc *tss_desc;

        struct page *save_area;
        struct vmcb *current_vmcb;

        /* index = sev_asid, value = vmcb pointer */
        struct vmcb **sev_vmcbs;
};

DECLARE_PER_CPU(struct svm_cpu_data *, svm_data);
```

在模块初始化时候`svm_hardware_setup()`, 初始化了每个CPU的`svm_data`, 

```cpp
// arch/x86/kvm/svm/svm.c
static __init int svm_hardware_setup(void)
{
        ......
        for_each_possible_cpu(cpu) {
                r = svm_cpu_init(cpu);
                if (r)
                        goto err;
        }
        ......
}
```

`svm_cpu_init`如下:

```cpp
// arch/x86/kvm/svm/svm.c
static int svm_cpu_init(int cpu)
{
        struct svm_cpu_data *sd;
        // 分配结构体
        sd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL);
        if (!sd)
                return -ENOMEM;
        sd->cpu = cpu;
        sd->save_area = alloc_page(GFP_KERNEL); // 分配一个页面, 用于保存主机状态
        if (!sd->save_area)
                goto free_cpu_data;
        clear_page(page_address(sd->save_area)); // 清除主机状态页面内容

        if (svm_sev_enabled()) {
                sd->sev_vmcbs = kmalloc_array(max_sev_asid + 1,
                                              sizeof(void *),
                                              GFP_KERNEL);
                if (!sd->sev_vmcbs)
                        goto free_save_area;
        }

        per_cpu(svm_data, cpu) = sd; // 赋值

        return 0;

free_save_area:
        __free_page(sd->save_area);
free_cpu_data:
        kfree(sd);
        return -ENOMEM;

}
```

### 

`VM_HSAVE_PA MSR`中保存主机状态保存区域的物理地址

```cpp
#define MSR_VM_HSAVE_PA                 0xc0010117
```

在创建虚拟机时候, 需要打开硬件功能时候(如下)

```cpp
用户态ioctl(fd,KVM_CREATE_VM,..)
kvm_dev_ioctl() // kvm ioctl 指令入口
 ├─ kvm_dev_ioctl_create_vm() // 创建虚拟机
 |   ├─ kvm_create_vm() // 实现虚拟机创建的主要函数
 |   |   ├─ hardware_enable_all() // 使能硬件，架构相关操作
 |   |   |   └─ hardware_enable_nolock() // 
 |   |   |       └─ kvm_arch_hardware_enable() // 
 |   |   |           ├─ kvm_x86_ops->hardware_enable()  // 调用svm_hardware_enable, 打开硬件功能
```

```cpp
static int svm_hardware_enable(void)
{
        struct svm_cpu_data *sd;
        ......
        sd = per_cpu(svm_data, me); // 获取svm_data
        wrmsrl(MSR_VM_HSAVE_PA, __sme_page_pa(sd->save_area)); // 写主机状态区域页面的物理地址到 VM_HSAVE MSR
        ......
}
```

由此可见, host 