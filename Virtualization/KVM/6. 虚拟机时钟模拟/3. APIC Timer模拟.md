
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. APIC timer中断](#1-apic-timer中断)
- [2. 相关结构体](#2-相关结构体)
- [3. 创建和初始化虚拟定时器设备](#3-创建和初始化虚拟定时器设备)
- [4. 启动定时器](#4-启动定时器)
  - [4.1. 整体流程](#41-整体流程)
  - [4.2. 入口代码](#42-入口代码)
  - [4.3. set_target_expiration(): 设置目标过期时间](#43-set_target_expiration-设置目标过期时间)
  - [4.4. restart_apic_timer(): 重启apic timer定时器](#44-restart_apic_timer-重启apic-timer定时器)

<!-- /code_chunk_output -->

# 1. APIC timer中断

前面提到, APIC Timer的APIC定时器有3种定时器模式

下面分析QEMU-KVM模拟APIC Timer**周期触发**(periodic)**模式**中断过程

# 2. 相关结构体

# 3. 创建和初始化虚拟定时器设备

由于APIC Timer设备实际就是**lapic**的一个**功能**，所以在创建lapic设备同时，也就辅助设置了。

```cpp
int kvm_create_lapic(struct kvm_vcpu *vcpu, int timer_advance_ns)
{
        ......
        // 建立hrtimer定时器, 回调函数 apic_timer_fn
        hrtimer_init(&apic->lapic_timer.timer, CLOCK_MONOTONIC,
                     HRTIMER_MODE_ABS_HARD);
        // hrtimer定时器回调函数, 即APIC Timer设备产生中断的函数
        apic->lapic_timer.timer.function = apic_timer_fn;
        ......
}
```

该如何模拟APIC Timer设备呢？对于**周期性时钟中断**，我们可以采用**定时器方式**，**一定间隔**调用一次**中断源产生函数**，**模拟时钟中断发生**。

首先创建一个**定时器**，然后初始化**APIC Timer设备**产生**中断的函数**，实际就是定时器回调函数。

# 4. 启动定时器

启用上面的定时器, 产生调用回调函数

## 4.1. 整体流程

```cpp
start_apic_timer()  // 启动apic timer定时器
 ├─ __start_apic_timer(apic, APIC_TMICT); // 传入 IMICT 初始计数寄存器
 |   ├─ set_target_expiration(apic, count_reg); // 设置到期时间, 当前流程中, 周期性/一次性模式情况下才调用, tscdeadline不会调用
 |   |   ├─ ktime_t now = ktime_get(); // 获取当前ktime
 |   |   ├─ apic->lapic_timer.period = tmict_to_ns(apic, kvm_lapic_get_reg(apic, APIC_TMICT)); // 设置触发周期时间, 即IMICT初始计数寄存器值, 即TMICT寄存器的值(只不过转换成ns单位)
 |   |   ├─ apic->lapic_timer.tscdeadline = 0; return false; // IMICT为0的话, 意味着停止一次性/周期性timer, 则设置tscdeadline为0然后返回
 |   |   ├─ limit_periodic_timer_frequency(apic); //
 |   |   ├─ deadline = apic->lapic_timer.period; // 等于IMICT
 |   |   ├─ apic->lapic_timer.tscdeadline = kvm_read_l1_tsc(apic->vcpu, tscl) + nsec_to_cycles(apic->vcpu, deadline); // tscdeadline设置, tsc+deadline
 |   |   └─ apic->lapic_timer.target_expiration = ktime_add_ns(now, deadline); // target_expiration设置, now+deadline
 |   └─ restart_apic_timer();  // 重启定时器
 |   |   ├─  !period(apic) && pending; return;// 如果apic timer当前不是周期模式(即一次性/tscdeadline模式)而且有pending事件, 直接返回, 不重启
 |   |   ├─ start_hv_timer(); // 能使用hv timer, 则使用hv timer
 |   |       ├─ kvm_can_use_hv_timer(vcpu); // 不能使用hv timer, 则直接返回false
 |   |       ├─ !apic->lapic_timer->tscdeadline; return false// tscdeadline是0, 则直接返回false
 |   |       ├─ kvm_x86_ops.set_hv_timer(vcpu, ktimer->tscdeadline, &expired); // 设置hv timer, 失败则直接返回false
 |   |       ├─ hrtimer_cancel(&ktimer->timer); // 取消hrtimer定时器
 |   |       ├─ kvm_can_use_hv_timer(vcpu); // 不能使用hv timer, 则直接返回false
 |   |       ├─ kvm_can_use_hv_timer(vcpu); // 不能使用hv timer, 则直接返回false
 |   |   ├─ start_sw_timer(); // 不能使用hv timer, 则使用sw timer



 |   ├─ vcpu->arch.apic = apic;  // 
 |   ├─ apic->regs = (void *)get_zeroed_page(GFP_KERNEL_ACCOUNT); //
 |   ├─ hrtimer_init(&apic->lapic_timer.timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_HARD);  //初始化hrtimer定时器
 |   ├─ apic->lapic_timer.timer.function = apic_timer_fn;  // hrtimer定时器回调函数, 即APIC Timer设备产生中断的函数
 |   ├─ apic->lapic_timer.timer_advance_ns;  // advanced timer
 |   └─ kvm_iodevice_init(&apic->dev, &apic_mmio_ops);  // 
 ├─ kvm_vcpu_reset(vcpu, false); // 对vcpu结构进行初始化
 |   ├─ kvm_lapic_reset(vcpu, init_event); // 设置寄存器的值为默认值

handle_io()  // io vmexit入口
 ├─ dev->ops->write();     // pit设备的write调用
 |   ├─ pit_ioport_write();  // 写pit io入口
 |   |   ├─ struct kvm_pit *pit = dev_to_pit();  // 获取pit
 |   |   ├─ pit_load_count(); // 分配irq source id
 |   |   ├─ ps->channels[channel].count_load_time = ktime_get(); return; // 不是 通道0, 则获取时间然后直接返回
 |   |   └─ create_pit_timer(); // 创建pit timer定时器
 |   |       ├─ s64 interval = mul_u64_u32_div(val, NSEC_PER_SEC, KVM_PIT_FREQ); // 计算间隔时间, 即定时器超时时间
 |   |       ├─ hrtimer_cancel(&ps->timer); // 取消pit定时器
 |   |       ├─ kthread_flush_work(&pit->expired); // 清理pit超时的work
 |   |       ├─ ps->period = interval; // 设置pit的超时时间
 |   |       ├─ ps->is_periodic = is_period; // 是否周期触发
 |   |       └─ hrtimer_start(&ps->timer, ktime_add_ns(ktime_get(), interval), HRTIMER_MODE_ABS); // 启用pit的hrtimer定时器
```

## 4.2. 入口代码

```cpp
// Timer initial counter register, timer初始计数寄存器
#define APIC_TMICT 0x380

// arch/x86/kvm/lapic.c
static void start_apic_timer(struct kvm_lapic *apic)
{
        // APIC_TMICT 是初始计数寄存器
        __start_apic_timer(apic, APIC_TMICT);
}

static void __start_apic_timer(struct kvm_lapic *apic, u32 count_reg)
{
        atomic_set(&apic->lapic_timer.pending, 0);
        // APIC timer是周期性模式或者一次性模式 并且
        // 设置到期时间失败的话, 直接返回
        // 当前流程 count_reg 是 APIC_TMICT
        if ((apic_lvtt_period(apic) || apic_lvtt_oneshot(apic))
            && !set_target_expiration(apic, count_reg))
                return;
        // 重启apic timer定时器
        restart_apic_timer(apic);
}
```

只有**周期性/一次性**模式, 才会去调用`set_target_expiration()`**设置目标过期时间**, 再调用`restart_apic_timer()`, 启用apic timer定时器.

对于tscdeadline模式, 直接调用`restart_apic_timer()`, 启用apic timer定时器

## 4.3. set_target_expiration(): 设置目标过期时间

当前流程中, 只有**周期性/一次性**模式才调用, tscdeadline模式不调用

```cpp
// 这个函数本身是都会调用, 不限于周期性/一次性
// 根据传入的count_reg计数寄存器(apic的一个寄存器)设置到期时间
static bool set_target_expiration(struct kvm_lapic *apic, u32 count_reg)
{
        ktime_t now;
        // 读取tsc
        u64 tscl = rdtsc();
        s64 deadline;
        // 当前ktime
        now = ktime_get();
        // 获取IMICT寄存器值, 设置触发周期时间
        // 即, IMICT初始计数寄存器值(转换成ns单位)
        apic->lapic_timer.period =
                        tmict_to_ns(apic, kvm_lapic_get_reg(apic, APIC_TMICT));
        // 如果初始计数寄存器值为0, 则是停止one shot/period
        if (!apic->lapic_timer.period) {
                // 设置tscdeadline为0, 返回false, 因为
                apic->lapic_timer.tscdeadline = 0;
                return false;
        }

        // 再往下面, 说明period即IMICT不为0, 即已经有初始计数值了
        limit_periodic_timer_frequency(apic);
        // deadline就是IMICT初始计数寄存器的值(只不过转换成ns单位)
        deadline = apic->lapic_timer.period;
        // 周期性/一次性时
        if (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic)) {
                // 传入的不是IMICT寄存器时, 当前流程不进入
                if (unlikely(count_reg != APIC_TMICT)) {
                        // deadline是count_reg寄存器值(只不过转换成ns单位)
                        deadline = tmict_to_ns(apic,
                                     kvm_lapic_get_reg(apic, count_reg));
                        // count_reg寄存器值小于0的话, 还是使用IMICT寄存器值
                        if (unlikely(deadline <= 0))
                                // deadline 还是 IMICT
                                deadline = apic->lapic_timer.period;
                        // count_reg寄存器值大于IMICT值, 即大于初始计数器值
                        // 使用IMICT值
                        else if (unlikely(deadline > apic->lapic_timer.period)) {
                                pr_info_ratelimited(
                                    "kvm: vcpu %i: requested lapic timer restore with "
                                    "starting count register %#x=%u (%lld ns) > initial count (%lld ns). "
                                    "Using initial count to start timer.\n",
                                    apic->vcpu->vcpu_id,
                                    count_reg,
                                    kvm_lapic_get_reg(apic, count_reg),
                                    deadline, apic->lapic_timer.period);
                                // 设置传入的count_reg寄存器为0
                                kvm_lapic_set_reg(apic, count_reg, 0);
                                // deadline等于 IMICT
                                deadline = apic->lapic_timer.period;
                        }
                }
        }
        // tscdeadline值 = 虚拟机tsc + deadline
        apic->lapic_timer.tscdeadline = kvm_read_l1_tsc(apic->vcpu, tscl) +
                nsec_to_cycles(apic->vcpu, deadline);
        // 到期时间 = now + deadline
        apic->lapic_timer.target_expiration = ktime_add_ns(now, deadline);

        return true;
}
```

1. 将IMICT初始计数寄存器值(转换成ns单位)作为lapic timer的触发周期, `apic->lapic_timer.period`

`tmict_to_ns()` 用于将**初始计数值**转换成ns单位, 初始计数值类似于IMICT寄存器的值.

```cpp
#define APIC_BUS_CYCLE_NS 1
static inline u64 tmict_to_ns(struct kvm_lapic *apic, u32 tmict)
{
        // 根据clock时钟频率将tmict(初始计数)转换成ns单位
        return (u64)tmict * APIC_BUS_CYCLE_NS * (u64)apic->divide_count;
}
```

2. 计算deadline, 默认IMICT寄存器的值; 
3. 设置`apic->lapic_timer.tscdeadline`为 `虚拟机tsc + deadline`
4. 设置`apic->lapic_timer.target_expiration`为 `ktime_get() + deadline`

## 4.4. restart_apic_timer(): 重启apic timer定时器

```cpp
static void restart_apic_timer(struct kvm_lapic *apic)
{
        preempt_disable();
        // 不是周期性模式 并且
        // apic定时器有pending事件, 直接退出
        if (!apic_lvtt_period(apic) && atomic_read(&apic->lapic_timer.pending))
                goto out;

        if (!start_hv_timer(apic))
                start_sw_timer(apic);
out:
        preempt_enable();
}
```

如果**不是周期性模式**时(即**一次性/tscdeadline模式**), 而apic timer有pending事件, 则不重启timer, 直接退出.

先试图

```cpp

static bool start_hv_timer(struct kvm_lapic *apic)
{
        // 获取apic timer
        struct kvm_timer *ktimer = &apic->lapic_timer;
        struct kvm_vcpu *vcpu = apic->vcpu;
        bool expired;

        WARN_ON(preemptible());
        // 判断能不能使用hv_timer
        if (!kvm_can_use_hv_timer(vcpu))
                return false;
        // tscdeadline是0, 直接返回false
        if (!ktimer->tscdeadline)
                return false;
        // 对应vmx的vmx_set_hv_timer
        if (kvm_x86_ops.set_hv_timer(vcpu, ktimer->tscdeadline, &expired))
                return false;
        // 设定hv timer正在使用
        ktimer->hv_timer_in_use = true;
        // 取消lapic timer定时器
        hrtimer_cancel(&ktimer->timer);

        /*
         * To simplify handling the periodic timer, leave the hv timer running
         * even if the deadline timer has expired, i.e. rely on the resulting
         * VM-Exit to recompute the periodic timer's target expiration.
         */
        // 非周期性
        if (!apic_lvtt_period(apic)) {
                /*
                 * Cancel the hv timer if the sw timer fired while the hv timer
                 * was being programmed, or if the hv timer itself expired.
                 */
                if (atomic_read(&ktimer->pending)) {
                        // 取消hv timer
                        cancel_hv_timer(apic);
                } else if (expired) 
                        apic_timer_expired(apic, false);
                        cancel_hv_timer(apic);
                }
        }

        trace_kvm_hv_timer_state(vcpu->vcpu_id, ktimer->hv_timer_in_use);

        return true;
}
```

1. 判断能否使用hv timer, 不能使用即退出

```cpp
bool kvm_can_use_hv_timer(struct kvm_vcpu *vcpu)
{
        return kvm_x86_ops.set_hv_timer
               // mwait透传, kvm能够post timer interrupt
               && !(kvm_mwait_in_guest(vcpu->kvm) ||
                    kvm_can_post_timer_interrupt(vcpu));
}
```

mwait指令透传给虚拟机, 或者能够post timer interrupt, 这个都不成立, 则表明能够使用hv timer

2. 


```cpp
static int vmx_set_hv_timer(struct kvm_vcpu *vcpu, u64 guest_deadline_tsc,
                            bool *expired)
{
        struct vcpu_vmx *vmx;
        u64 tscl, guest_tscl, delta_tsc, lapic_timer_advance_cycles;
        // 获取lapic timer
        struct kvm_timer *ktimer = &vcpu->arch.apic->lapic_timer;

        vmx = to_vmx(vcpu);
        // 读取host tsc
        tscl = rdtsc();
        // 读取guest tsc
        guest_tscl = kvm_read_l1_tsc(vcpu, tscl);
        delta_tsc = max(guest_deadline_tsc, guest_tscl) - guest_tscl;
        lapic_timer_advance_cycles = nsec_to_cycles(vcpu,
                                                    ktimer->timer_advance_ns);

        if (delta_tsc > lapic_timer_advance_cycles)
                delta_tsc -= lapic_timer_advance_cycles;
        else
                delta_tsc = 0;

        /* Convert to host delta tsc if tsc scaling is enabled */
        if (vcpu->arch.tsc_scaling_ratio != kvm_default_tsc_scaling_ratio &&
            delta_tsc && u64_shl_div_u64(delta_tsc,
                                kvm_tsc_scaling_ratio_frac_bits,
                                vcpu->arch.tsc_scaling_ratio, &delta_tsc))
                return -ERANGE;

        /*
         * If the delta tsc can't fit in the 32 bit after the multi shift,
         * we can't use the preemption timer.
         * It's possible that it fits on later vmentries, but checking
         * on every vmentry is costly so we just use an hrtimer.
         */
        if (delta_tsc >> (cpu_preemption_timer_multi + 32))
                return -ERANGE;

        vmx->hv_deadline_tsc = tscl + delta_tsc;
        *expired = !delta_tsc;
        return 0;
}
```

```
static void start_sw_timer(struct kvm_lapic *apic)
{
        struct kvm_timer *ktimer = &apic->lapic_timer;

        WARN_ON(preemptible());
        if (apic->lapic_timer.hv_timer_in_use)
                cancel_hv_timer(apic);
        // 不是周期性并且存在pending, 直接返回
        if (!apic_lvtt_period(apic) && atomic_read(&ktimer->pending))
                return;
        // 周期性或一次性模式
        if (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic))
                start_sw_period(apic);
        // tscdeadline模式
        else if (apic_lvtt_tscdeadline(apic))
                start_sw_tscdeadline(apic);
        trace_kvm_hv_timer_state(apic->vcpu->vcpu_id, false);
}

static void cancel_hv_timer(struct kvm_lapic *apic)
{
        WARN_ON(preemptible());
        WARN_ON(!apic->lapic_timer.hv_timer_in_use);
        kvm_x86_ops.cancel_hv_timer(apic->vcpu);
        apic->lapic_timer.hv_timer_in_use = false;
}
```



http://chinaunix.net/uid-25739055-id-4092821.html

