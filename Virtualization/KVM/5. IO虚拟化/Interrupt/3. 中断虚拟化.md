
以时钟中断为例

一个操作系统要跑起来，必须有Time Tick，它就像是身体的脉搏。普通情况下，OS Time Tick由PIT(i8254)或APIC Timer设备提供—PIT定期(1ms in Linux)产生一个timer interrupt，作为global tick, APIC Timer产生一个local tick。在虚拟化情况下，必须为guest OS模拟一个PIT和APIC Timer。

模拟的PIT和APIC Timer不能像真正硬件那样物理计时，所以一般用HOST的某种系统服务或软件计时器来为这个模拟PIT提供模拟”时钟源”。

目前两种方案：1. 用户态模拟方案（QEMU）； 2. 内核态模拟方案（KVM）；



# 物理芯片介绍

## PIT主要为Intel 8254 PIT芯片

PIT(Programmable Interval Timer), 可编程间隔定时器

每个PC机中都有一个PIT, 通过IRQ产生周期性的时钟中断信号来充当系统定时器.

i386使用通常是Intel 8254 PIT芯片, 它的I/O端口地址范围是40h ~ 43h.

8254 PIT有**3个计时通道**, 每个通道都有其不同的用途:

- **通道0**用来负责**更新系统时钟**. 它在**每个时钟滴答**会通过**IRQ0**向系统发出一次**时钟中断信号**.
- **通道1**通常用来控制**DMAC对RAM的刷新**
- **通道3**被连接到**PC机的扬声器**, 以产生**方波信号**.

## PIC主要为8259A PIC芯片

PIC(Programmable Interrupt Controller), 可编程中断控制器

它具有IR0 ~ IR7共8个中断管脚连接到外部设备. 中断管脚具有优先级, 其中IR0优先级最高, IR7最低.

PIC有三个重要的寄存器:

(1) IRR(Interrupt Request Register, 中断请求寄存器)共8位, 对应IR0到IR7这8个中断管脚. 某位置为1表明收到了对应管脚的中断但未提交到CPU.

(2) ISR(Interrupt Service Register, 中断请求寄存器): 共8位, 某位置为1表明对应管脚的中断已经提交到CPU处理, 但CPU还未处理完.

(3) IMR(Interrupt Mask Register, 中断屏蔽寄存器): 共8位, 某位置为1表明对应的中断管脚被屏蔽.

# 整体流程

整个主要流程:

![2020-04-18-17-59.png](./images/2020-04-18-17-59.png)

修正: 重定向表中有目标lapic的id

# QEMU

PIC创建:

```cpp
// kvm-all.c/kvm_init/kvm_irqchip_create
kvm_vm_ioctl(s, KVM_CREATE_IRQCHIP)
```

PIT创建:

```cpp
// i8254.c
kvm_vm_ioctl(kvm_state, KVM_CREATE_PIT)
```

# PIC的创建

```cpp
kvm_vm_ioctl() // kvm ioctl vm指令入口
    kvm_vm_ioctl_create_vcpu() // 为虚拟机创建VCPU的ioctl调用的入口函数
        kvm_arch_vcpu_precreate() // stable tsc检查
        kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL); // 给kvm_vcpu分配内存, 该cache是kvm模块初始化时创建的
        page = alloc_page(); // 分配一页内存给vcpu->run(struct kvm_run)
        kvm_vcpu_init(vcpu, kvm, id); // vcpu结构体一些变量初始化
        kvm_arch_vcpu_create() // 初始化kvm_vcpu_arch结构体, 架构相关
            vcpu->arch.mp_state = KVM_MP_STATE_UNINITIALIZED/KVM_MP_STATE_RUNNABLE; // 设置vcpu状态
            kvm_set_tsc_khz() // tsc的设置
            kvm_mmu_create() // kvm_vcpu_arch中mmu相关初始化, 内存虚拟化, 地址转换的重点
                alloc_mmu_pages() // 给vcpu->arch的gust mmu和root mmu分配页面
            kvm_create_lapic() // 初始化lapic
            alloc_page(); // 给kvm_vcpu_arch的pio分配内存页
            vcpu->arch.mce_banks = kzalloc(); // 以及其他一些代码实现初始化mce_banks
            alloc_emulate_ctxt(vcpu); // 没有VMX时的软件模拟, 没人用...
            vcpu->arch.user_fpu = kmem_cache_zalloc(); //给用户态fpu分配kmem cache
            vcpu->arch.guest_fpu = kmem_cache_zalloc(); // 虚拟机fpu的kmem cache
            kvm_pmu_init(vcpu); // 
            kvm_hv_vcpu_init(vcpu); // 
            kvm_x86_ops->vcpu_create(vcpu); //对于intel x86来说，最终调用 vmx_create_vcpu
                vmx->vpid = allocate_vpid(); // 分配vpid
                vmx->pml_pg = alloc_page(); // 
                alloc_loaded_vmcs(&vmx->vmc01); // loaded_vmcs的分配以及初始化
                    loaded_vmcs->vmcs = alloc_vmcs(); // 分配一个页面
                    loaded_vmcs_init(loaded_vmcs); // 初始化 loaded_vmcs
                        vmcs_clear(loaded_vmcs->vmcs); // 调用vmclear 
                    loaded_vmcs->msr_bitmap = (unsigned long *)__get_free_page(GFP_KERNEL_ACCOUNT); // msr_bitmap 分配页面
                vmx_disable_intercept_for_msr();
                vmx_vcpu_load(); // 加载vcpu信息
                    vmx_vcpu_load_vmcs(); // 加载vmcs
                        already_loaded = vmx->loaded_vmcs->cpu == cpu; // 是否已经加载的判断
                            loaded_vmcs_clear(vmx->loaded_vmcs); // 没有加载时, 会调用vmclear命令(操作数为struct vmcs地址), 用于对该VMCS区域初始化, 包括将数据填充到VMCS区域和将VMCS状态(不可见字段)置为clear
                            list_add(&vmx->loaded_vmcs->loaded_vmcss_on_cpu_link, &per_cpu(loaded_vmcss_on_cpu, cpu)); // 没有加载时, 相应cpu上的loaded_vmcs链表
                        per_cpu(current_vmcs, cpu) = vmx->loaded_vmcs->vmcs; // 赋值cpu的current_vmcs
                        vmcs_load(vmx->loaded_vmcs->vmcs); // vmptrld指令, 加载这个vmcs为current-VMCS
                            kvm_make_request(KVM_REQ_TLB_FLUSH, vcpu); // 
                            vmcs_writel(HOST_TR_BASE, (unsigned long)&get_cpu_entry_area(cpu)->tss.x86_tss); // 没加载时, 写VMCS的TSS
                            vmcs_writel(HOST_GDTR_BASE, (unsigned long)gdt);   // 没加载时, 写GDT
                            vmx->loaded_vmcs->cpu = cpu; // 没加载时, 关联CPU
                        decache_tsc_multiplier(); 
                    vmx_vcpu_pi_load(); // 加载posted interrupt
                init_vmcs(vmx); // 初始化vmcs, 而guest-state在vmx_vcpu_reset()
                    vmcs_write32();
                    vmcs_write64(); // 一堆写入vmcs, 使用vmwrite指令
                    vmx_set_constant_host_state(vmx); // 设置host-state常量
                        vmcs_write1(HOST_RIP, (unsigned long)vmx_vmexit); //vmexit后vmm的入口地址, 这里面是个ret, 详细说明见下面VCPU_RUN
                vmx_vcpu_put();
                    vmx_vcpu_pi_put();
                    vmx_prepare_switch_to_host(); // 
                put_cpu();
            kvm_vcpu_mtrr_init(vcpu); // 初始化mtrr链表 
            vcpu_load(vcpu);  // 加载vcpu信息<参数为kvm_vcpu>, struct vmx_vcpu(vcpu的一个运行环境)加载, 
                kvm_arch_vcpu_load(vcpu, cpu)
                    kvm_x86_ops->vcpu_load(vcpu, cpu); // 实际调用vmx.c的 vmx_vcpu_load(), 见上面
            kvm_vcpu_reset(vcpu, false); // 对vcpu结构进行初始化
                kvm_lapic_reset(vcpu, init_event);
                vcpu(kvm_vcpu)的很多变量的初始化
                kvm_clear_interrupt_queue(vcpu);
                kvm_clear_exception_queue(vcpu);
                kvm_make_request(KVM_REQ_EVENT, vcpu);
                kvmclock_reset(vcpu);
                kvm_x86_ops->vcpu_reset(vcpu, init_event);
            kvm_init_mmu(vcpu, false); // 初始化mmu
            vcpu_put(vcpu);
                kvm_arch_vcpu_put(vcpu);
                preempt_notifier_unregister(&vcpu->preempt_notifier);
                __this_cpu_write(kvm_running_vcpu, NULL);
        kvm_create_vcpu_debugfs() // 创建vcpu的debugfs
        kvm_get_kvm() // 增加kvm的引用计数
        create_vcpu_fd() // 为新创建的vcpu创建对应的fd，以便于后续通过该fd进行ioctl操作
        kvm->vcpus[vcpu->vcpu_idx]=vcpu; //添加到虚拟机的vcpus数组
        atomic_inc(&kvm->online_vcpus); //增加kvm->online_vcpus数目
        kvm_arch_vcpu_postcreate() // 架构相关的善后工作，比如再次调用vcpu_load，以及tsc相关处理
            vcpu_load();
            kvm_write_tsc();
```

## 