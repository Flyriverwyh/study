<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [中断虚拟化](#中断虚拟化)
- [物理中断](#物理中断)
  - [vcpu运行时的截获和注入](#vcpu运行时的截获和注入)
- [虚拟中断](#虚拟中断)
- [参考](#参考)

<!-- /code_chunk_output -->

# 中断虚拟化

中断虚拟化，有两方面：

1. **如何保证物理中断只由host来处理**；
2. host如何将一个**虚拟中断注入到guest**中。

# 物理中断

首先看物理中断情况:

在**没有guest**情况下，一旦CPU检测到**中断信号**，将在**下一条指令之前响应中断**，根据**中断号**从**host OS IDT**中取到对应的中断向量，然后调用**interrupt handler**。

但是，假如**guest vcpu**正在**执行中**来了**物理中断**，此时的**物理IDTR**指向的是**guest OS的IDT**。原则上肯定**不会是由guest handler**去处理**物理中断**，所以必须通过**某种机制**来处理，这个机制由两部分配合：

1. 首先是**vmx规定**，只要此**虚拟机vmcs**的"`VM-Execution control field`"中的"`External -interrupt exiting`"**位设置为1**，**物理中断**将**导致VMExit**(vmcs的配置可以参考“IA32 Intel Architecture Software Developer’s Manual Volume 3B System Programming Guide”)。

2. 知道了1. 后，**物理中断不是应该立刻由硬件来响应**么，那么是**响应中断在前**，还是**VMExit在前**呢？如果**响应在前**，此时**IDTR还没有恢复为host**的，将导致取guest IDT，所以**显然不行**，**只能是VMExit在前**，但是**VMExit过程**中**硬件只能恢复host的非通用寄存器！！！**，**通用寄存器**还得由**软件！！！来恢复(vmx_vcpu_run函数代码**)，**物理中断**却要在**恢复通用寄存器之间**了，显然也不行。

后来才发现，原来在**进入guest执行前**，**kvm是关中断的**，在**VMExit完全恢复了host上下文**后，**才开中断**——关中断是`vcpu_enter_guest`函数中调用了`local_irq_disable`，**开中断**是在这个函数从`kvm_x86_ops->run`**返回后**(即**VMExit后**)调用`local_irq_enable`。

现在一切都明白了：**guest vcpu执行时**，**物理中断来了**，它可以导致**VMExit**，但是此时是**关中断**，所以**硬件不会响应中断**，中断处于**pending**，在**中断开后**，硬件发现**pending中断并开始响应**，此时已经是在**host上下文**中，**IDTR已经指向host的IDT**，因此物理中断实际上是由**host handler来处理**了。

## vcpu运行时的截获和注入

假如在**guest运行期间**发生了一个**物理中断**，kvm是**如何截获**进入将其**注入到guest**中去的呢？有两个步骤：

1. 在`vmx_vcpu_run`中，从**guest mode返回！！！** 后会**调用**`complete_interrupt`函数。因为硬件会将**中断类型**和那个**中断号**写入到**VMCS**中，所以`complete_interrupt`的任务就是**从VMCS中取出中断信息**，然后**写入vcpu的控制块**中去，使得这个中断变成一种**pending event**。

2. 在`vcpu_enter_guest`中，在**进入guest mode前！！！** 会调用`inject_pending_event`。`inject_pending_event`发现**vcpu控制块**中**有pending的中断信息**，就调用`vmx_inject_irq`将其**写入VMCS中**去，就相当于**将中断注入到guest**中去了。

对于1. 情况，暂时也还不知道KVM具体是如何实现的。不过vmx倒也是支持这种注入操作。只要vmcs的"`VM-Execution control field`"中的"`Interrupt-window exiting`"位设**置为1**，**只要guest IF=1**，在**下一条任意指令前**，会发生**VMExit**，就像**普通情况下发生了一次中断**一样。也就是说，**kvm**应该可以通过设置"`Interrupt-window exiting`"**中断guest vcpu的执行**，然后像后一种情况一样，**把虚拟中断注入到虚拟机中**。

# 虚拟中断

再来看虚拟中断的情况；

KVM用QEMU来提供**设备模拟**，与物理设备一样，**模拟的设备**也可以**发出中断信号**，但是这个**中断信号是软件虚拟**的，那么这个虚拟中断是怎样注入到虚拟机中去的呢？这个又要分两种情况：

1. 此时**guest vcpu正在执行**；

2. **guest vcpu**刚到**用户模式**执行完**IO指令模拟操作**，还**没有开始VMEntry**。

对于2. 情况，可以参考`vmx_inject_irq`和`vmx_inject_nmi`(`vmx.c`)，可以发现，kvm是利用**vmx支持**这种**注入操作的特性**：vmcs中有"`VM-Entry control fields`"，其中又包含"`VM-entry interruption-information field`"，可以将**中断类型**和**中断号**记录到其中，在**VMEntry过程**中，硬件会**自动检测这个信息域**，如果有效，就会在**真正执行任何guest指令之前**，像原来硬件一样**响应此中断**(包括**压IP,CS,FLAGS**；从**IDT中取interrupt vector**等)，注意此操作是在**恢复了guest上下文之后**，所以**物理IDTR**已经是指向**guest OS IDT**了，因此这个虚拟中断就由guest handler来处理了。

# 参考

https://blog.csdn.net/xidianjiapei001/article/details/89293842