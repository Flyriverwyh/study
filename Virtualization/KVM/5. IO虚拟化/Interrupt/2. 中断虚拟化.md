
**虚拟机**的**中断源**大致有两种方式，来自于**用户空间qemu**和来自于**KVM内部**。

中断虚拟化**起始关键**在于**对中断控制器的虚拟化**，中断控制器目前主要有**APIC**，这种架构下**设备控制器**通过**某种触发方式**通知**IO APIC**，**IO APIC**根据**自身维护**的**重定向表pci irq routing table**格式化出**一条中断消息**，把中断消息发送给**local APIC**，local APIC局部于CPU，即**每个CPU一个**，local APIC 具备**传统中断控制器的相关功能**以及各个寄存器，中断请求寄存器IRR，中断屏蔽寄存器IMR，中断服务寄存器ISR等，针对这些关键部件的虚拟化是中断虚拟化的重点。

在**KVM架构**下，**每个KVM虚拟机**维护一个**IO APIC**，但是**每个VCPU**有**一个local APIC**。

核心数据结构介绍：

```cpp
#define KVM_NR_IRQCHIPS 3
#define KVM_IOAPIC_NUM_PINS 24
#define KVM_IRQCHIP_NUM_PINS  KVM_IOAPIC_NUM_PINS

#ifdef CONFIG_HAVE_KVM_IRQ_ROUTING
struct kvm_irq_routing_table {
        // 3个IRQ芯片, 分别有24个引脚
        // 引脚的GSI号
        int chip[KVM_NR_IRQCHIPS][KVM_IRQCHIP_NUM_PINS];
        u32 nr_rt_entries;
        /*
         * Array indexed by gsi. Each entry contains list of irq chips
         * the gsi is connected to.
         */
        struct hlist_head map[0];
};
#endif
```

这个是一个**中断路由表**，**每个KVM**都有一个.

**chip**是一个**二维数组**，表示**三个芯片**的**各个管脚**，**每个芯片**有**24个管脚**，**每个数组项**纪录对应管脚的**GSI号**；

**GSI**(Global System Interrupt): **ACPI引入的概念**, 它为系统中**每个中断源**指定了一个**唯一的中断号**. IRQ和GSI在APIC系统中常被混用, 实际上对于**15以上的IRQ**, 它**和GSI相等**.

`rt_entries`是一个指针，指向一个`kvm_kernel_irq_routing_entry`**数组**，数组中共有**nr_rt_entries**项，每项对应一个IRQ；

map其实可以理解为一个**链表头数组**，可以根据**GSI号**作为索引，找到**同一IRQ**关联的所有`kvm_kernel_irq_routing_entry`。

具体中断路由表的初始化部分见本文最后一节

```cpp
struct kvm_kernel_irq_routing_entry {
        // 该entry对应的GSI号
        u32 gsi;
        u32 type;
        // 该GSI关联的触发方式
        int (*set)(struct kvm_kernel_irq_routing_entry *e,
                   struct kvm *kvm, int irq_source_id, int level,
                   bool line_status);
        union {
                struct {
                        unsigned irqchip;
                        unsigned pin;
                } irqchip;
                struct {
                        u32 address_lo;
                        u32 address_hi;
                        u32 data;
                        u32 flags;
                        u32 devid;
                } msi;
                struct kvm_s390_adapter_int adapter;
                struct kvm_hv_sint hv_sint;
        };
        // 
        struct hlist_node link;
};
```

GSI是该entry对应的**GSI号**，一般和IRQ是一样，

set方法是该IRQ关联的触发方法，通过该方法把**IRQ传递给IO-APIC**，；

link就是**连接点**，连接在上面**同一IRQ**对应的**map**上；

## 中断注入在KVM内部流程起始于一个函数kvm_set_irq

```cpp
/*
 * Return value:
 *  < 0   Interrupt was ignored (masked or not delivered for other reasons)
 *  = 0   Interrupt was coalesced (previous irq is still pending)
 *  > 0   Number of CPUs interrupt was delivered to
 */
int kvm_set_irq(struct kvm *kvm, int irq_source_id, u32 irq, int level,
                bool line_status)
{
        struct kvm_kernel_irq_routing_entry irq_set[KVM_NR_IRQCHIPS];
        int ret = -1, i, idx;

        trace_kvm_set_irq(irq, level, irq_source_id);

        /* Not possible to detect if the guest uses the PIC or the
         * IOAPIC.  So set the bit in both. The guest will ignore
         * writes to the unused one.
         */
        idx = srcu_read_lock(&kvm->irq_srcu);
        // 同一个irq注册的所有设备, 存于irq_set, 返回数量
        i = kvm_irq_map_gsi(kvm, irq_set, irq);
        srcu_read_unlock(&kvm->irq_srcu, idx);
        /* 依次调用同一个irq上的所有芯片的set方法 */
        while (i--) {
                int r;
                r = irq_set[i].set(&irq_set[i], kvm, irq_source_id, level,
                                   line_status);
                if (r < 0)
                        continue;

                ret = r + ((ret < 0) ? 0 : ret);
        }

        return ret;
}
```

各个参数的意思:

- **kvm**指定特定的虚拟机，
- `irq_source_id`是**中断源ID**，一般有`KVM_USERSPACE_IRQ_SOURCE_ID`和`KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID`；
- **irq**是**全局的中断号**，
- **level**指定**高低电平**，需要注意的是，针对**边沿触发**，需要**两个电平触发来模拟**，**先高电平再低电平**。

回到函数中，首先要收集的是**同一irq**上注册的**所有的设备信息**，这主要在于**irq共享**的情况，非共享的情况下最多就一个。**设备信息**抽象成一个`kvm_kernel_irq_routing_entry`，这里临时放到`irq_set`数组中。

然后对于数组中的**每个元素**，调用**其set方法**，目前大都是**APIC架构**，因此set方法基本都是`kvm_set_ioapic_irq`，在**传统pic**情况下，是`kvm_set_pic_irq`。

我们以`kvm_set_ioapic_irq`为例进行分析，该函数**没有实质性的操作**，就调用了`kvm_ioapic_set_irq`函数

```cpp
static int kvm_set_ioapic_irq(struct kvm_kernel_irq_routing_entry *e,
                              struct kvm *kvm, int irq_source_id, int level,
                              bool line_status)
{
        struct kvm_ioapic *ioapic = kvm->arch.vioapic;
        return kvm_ioapic_set_irq(ioapic, e->irqchip.pin, irq_source_id, level,
                                line_status);
}

int kvm_ioapic_set_irq(struct kvm_ioapic *ioapic, int irq, int irq_source_id,
                       int level, bool line_status)
{
        int ret, irq_level;

        BUG_ON(irq < 0 || irq >= IOAPIC_NUM_PINS);

        spin_lock(&ioapic->lock);
        /*判断请求高电平还是低电平*/
        irq_level = __kvm_irq_line_state(&ioapic->irq_states[irq],
                                         irq_source_id, level);
        ret = ioapic_set_irq(ioapic, irq, irq_level, line_status);

        spin_unlock(&ioapic->lock);

        return ret;
}

static int ioapic_set_irq(struct kvm_ioapic *ioapic, unsigned int irq,
                int irq_level, bool line_status)
{
        union kvm_ioapic_redirect_entry entry;
        //irq对应的位
        u32 mask = 1 << irq;
        u32 old_irr;
        int edge, ret;

        entry = ioapic->redirtbl[irq];
        /*判断触发方式*/
        edge = (entry.fields.trig_mode == IOAPIC_EDGE_TRIG);
        /* 如果低电平, 表明是边沿触发的第二次触发??? */
        if (!irq_level) {
                // 清理
                ioapic->irr &= ~mask;
                ret = 1;
                goto out;
        }

        /*
         * AMD SVM AVIC accelerate EOI write and do not trap,
         * in-kernel IOAPIC will not be able to receive the EOI.
         * In this case, we do lazy update of the pending EOI when
         * trying to set IOAPIC irq.
         */
        if (kvm_apicv_activated(ioapic->kvm))
                ioapic_lazy_update_eoi(ioapic, irq);

        /*
         * Return 0 for coalesced interrupts; for edge-triggered interrupts,
         * this only happens if a previous edge has not been delivered due
         * to masking.  For level interrupts, the remote_irr field tells
         * us if the interrupt is waiting for an EOI.
         *
         * RTC is special: it is edge-triggered, but userspace likes to know
         * if it has been already ack-ed via EOI because coalesced RTC
         * interrupts lead to time drift in Windows guests.  So we track
         * EOI manually for the RTC interrupt.
         */
        if (irq == RTC_GSI && line_status &&
                rtc_irq_check_coalesced(ioapic)) {
                ret = 0;
                goto out;
        }

        old_irr = ioapic->irr;
        ioapic->irr |= mask;
        // 如果是边沿触发
        if (edge) {
                ioapic->irr_delivered &= ~mask;
                // 边沿触发且旧的irr寄存器与请求的irr相等
                if (old_irr == ioapic->irr) {
                        ret = 0;
                        goto out;
                }
        }
        // 旧的irr寄存器与请求的irr不等
        ret = ioapic_service(ioapic, irq, line_status);

out:
        trace_kvm_ioapic_set_irq(entry.bits, irq, ret == 0);
        return ret;
}
```

到这里，中断已经到达**模拟的IO-APIC**了，IO-APIC最重要的就是它的**重定向表**，针对重定向表的操作主要在`ioapic_service`中，之前都是做一些准备工作，在进入`ioapic_service`函数之前，主要有**两个任务**：

1、**判断触发方式**，主要是区分**电平触发**和**边沿触发**。

2、设置**ioapic的irr寄存器**。之前我们说过，**边沿触发**需要**两个水平触发**来**模拟**，**前后电平相反**。这里就要先做判断是对应哪一次。**只有首次触发**才会进行后续的操作，而**二次触发**相当于**reset操作**，就是把**ioapic的irr寄存器清除**。在**电平触发**模式下且请求的irq和ioapic中保存的irq不一致，就会对其进行更新，进入ioapic_service函数。

