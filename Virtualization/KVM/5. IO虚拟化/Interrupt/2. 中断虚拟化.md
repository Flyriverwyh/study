
**虚拟机**的**中断源**大致有两种方式，来自于**用户空间qemu**和来自于**KVM内部**。

中断虚拟化**起始关键**在于**对中断控制器的虚拟化**，中断控制器目前主要有**APIC**，这种架构下**设备控制器**通过**某种触发方式**通知**IO APIC**，**IO APIC**根据**自身维护**的**重定向表pci irq routing table**格式化出**一条中断消息**，把中断消息发送给**local APIC**，local APIC局部于CPU，即**每个CPU一个**，local APIC 具备**传统中断控制器的相关功能**以及各个寄存器，中断请求寄存器IRR，中断屏蔽寄存器IMR，中断服务寄存器ISR等，针对这些关键部件的虚拟化是中断虚拟化的重点。

在**KVM架构**下，**每个KVM虚拟机**维护一个**IO APIC**，但是**每个VCPU**有**一个local APIC**。

核心数据结构介绍：

```cpp
#define KVM_NR_IRQCHIPS 3
#define KVM_IOAPIC_NUM_PINS 24
#define KVM_IRQCHIP_NUM_PINS  KVM_IOAPIC_NUM_PINS

#ifdef CONFIG_HAVE_KVM_IRQ_ROUTING
struct kvm_irq_routing_table {
        // 3个IRQ芯片, 分别有24个引脚
        // 引脚的GSI号
        int chip[KVM_NR_IRQCHIPS][KVM_IRQCHIP_NUM_PINS];
        u32 nr_rt_entries;
        /*
         * Array indexed by gsi. Each entry contains list of irq chips
         * the gsi is connected to.
         */
        struct hlist_head map[0];
};
#endif
```

这个是一个**中断路由表**，每个KVM都有一个.

**chip**是一个**二维数组**，表示**三个芯片**的**各个管脚**，**每个芯片**有**24个管脚**，**每个数组项**纪录对应管脚的**GSI号**；

**GSI**(Global System Interrupt): **ACPI引入的概念**, 它为系统中**每个中断源**指定了一个**唯一的中断号**. IRQ和GSI在APIC系统中常被混用, 实际上对于**15以上的IRQ**, 它**和GSI相等**.

`rt_entries`是一个指针，指向一个`kvm_kernel_irq_routing_entry`**数组**，数组中共有**nr_rt_entries**项，每项对应一个IRQ；

map其实可以理解为一个**链表头数组**，可以根据**GSI号**作为索引，找到**同一IRQ**关联的所有`kvm_kernel_irq_routing_entry`。

具体中断路由表的初始化部分见本文最后一节

```cpp
struct kvm_kernel_irq_routing_entry {
        // 该entry对应的GSI号
        u32 gsi;
        u32 type;
        // 该GSI关联的触发方式
        int (*set)(struct kvm_kernel_irq_routing_entry *e,
                   struct kvm *kvm, int irq_source_id, int level,
                   bool line_status);
        union {
                struct {
                        unsigned irqchip;
                        unsigned pin;
                } irqchip;
                struct {
                        u32 address_lo;
                        u32 address_hi;
                        u32 data;
                        u32 flags;
                        u32 devid;
                } msi;
                struct kvm_s390_adapter_int adapter;
                struct kvm_hv_sint hv_sint;
        };
        // 
        struct hlist_node link;
};
```

GSI是该entry对应的**GSI号**，一般和IRQ是一样，

set方法是该IRQ关联的触发方法，通过该方法把**IRQ传递给IO-APIC**，；

link就是**连接点**，连接在上面**同一IRQ**对应的**map**上；

## 中断注入在KVM内部流程起始于一个函数kvm_set_irq

```cpp
/*
 * Return value:
 *  < 0   Interrupt was ignored (masked or not delivered for other reasons)
 *  = 0   Interrupt was coalesced (previous irq is still pending)
 *  > 0   Number of CPUs interrupt was delivered to
 */
int kvm_set_irq(struct kvm *kvm, int irq_source_id, u32 irq, int level,
                bool line_status)
{
        struct kvm_kernel_irq_routing_entry irq_set[KVM_NR_IRQCHIPS];
        int ret = -1, i, idx;

        trace_kvm_set_irq(irq, level, irq_source_id);

        /* Not possible to detect if the guest uses the PIC or the
         * IOAPIC.  So set the bit in both. The guest will ignore
         * writes to the unused one.
         */
        idx = srcu_read_lock(&kvm->irq_srcu);
        i = kvm_irq_map_gsi(kvm, irq_set, irq);
        srcu_read_unlock(&kvm->irq_srcu, idx);
        /* 依次调用同一个irq上的所有芯片的set方法 */
        while (i--) {
                int r;
                r = irq_set[i].set(&irq_set[i], kvm, irq_source_id, level,
                                   line_status);
                if (r < 0)
                        continue;

                ret = r + ((ret < 0) ? 0 : ret);
        }

        return ret;
}
```

**kvm**指定特定的虚拟机，`irq_source_id`是**中断源ID**，一般有`KVM_USERSPACE_IRQ_SOURCE_ID`和`KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID`；**irq**是**全局的中断号**，**level**指定**高低电平**，需要注意的是，针对**边沿触发**，需要**两个电平触发来模拟**，**先高电平再低电平**。回到函数中，首先要收集的是同一irq上注册的所有的设备信息，这主要在于irq共享的情况，非共享的情况下最多就一个。设备信息抽象成一个kvm_kernel_irq_routing_entry，这里临时放到irq_set数组中。然后对于数组中的每个元素，调用其set方法，目前大都是APIC架构，因此set方法基本都是kvm_set_ioapic_irq，在传统pic情况下，是kvm_set_pic_irq。我们以kvm_set_ioapic_irq为例进行分析，该函数没有实质性的操作，就调用了kvm_ioapic_set_irq函数