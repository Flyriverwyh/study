
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 硬件基础](#1-硬件基础)
- [2. Time Tick](#2-time-tick)
  - [2.1. 物理环境下的timer](#21-物理环境下的timer)
  - [2.2. 虚拟化下的timer](#22-虚拟化下的timer)
- [3. PIT(8254)模拟](#3-pit8254模拟)
  - [3.1. 相关结构体](#31-相关结构体)
    - [3.1.1. struct kvm_pit: pit芯片](#311-struct-kvm_pit-pit芯片)
    - [struct hrtimer](#struct-hrtimer)
  - [5. 初始化虚拟PIT](#5-初始化虚拟pit)
    - [5.1. QEMU](#51-qemu)
    - [5.2. 整体流程](#52-整体流程)
    - [5.3. 入口代码](#53-入口代码)
    - [5.4. kvm_create_pit(): 创建pit(8254)](#54-kvm_create_pit-创建pit8254)
    - [5.5. pit_timer_fn(): 中断流程](#55-pit_timer_fn-中断流程)
- [6. 参考](#6-参考)

<!-- /code_chunk_output -->

# 1. 硬件基础

参见`Architecture/x86/7. 时钟.md`

- rtc: 
- pit:
- hpet
- tsc
- local timer
- kvmclock

# 2. Time Tick

## 2.1. 物理环境下的timer

一个操作系统要跑起来，必须有**Time Tick**，它就像是身体的脉搏。

普通情况下，**OS Time Tick**由**PIT**(i8254)或**APIC Timer**设备提供产生中断源

- PIT(i8254)定期(**1ms in Linux**)产生一个**timer interrupt**，作为**global tick**, 
- **APIC Timer**产生一个**local tick**。

两者电子线路连接不同:
- 对于**i8254设备**来说首先连接到**i8259中断控制器**，i8259中断控制器再连接到**ioapic设备**中，送到**lapic**, 最后**注入到vcpu**中。
- 对于APIC Timer设备实际就是lapic的一个功能，意思就是通过编程可以触发lapic设备周期产生中断，然后注入到vcpu。

通过上面了解知道两者区别了**APIC Timer**的是**每个cpu**内核都有**一个定时器**，而**PIT是共用的一个**。

APIC Timer的模式APIC定时器包含**3种定时器模式**，
- 周期触发`periodic`
- 一次性触发`one-shot`
- `TSC-Deadline`模式(最新的CPU里面支持)。

## 2.2. 虚拟化下的timer

在虚拟化情况下，必须为**guest OS**模拟一个**PIT**和**APIC Timer**。

模拟的**PIT**和**APIC Timer**不能像真正硬件那样**物理计时**，所以一般用**HOST的某种系统服务**或**软件计时器**来为这个模拟 PIT 提供模拟”**时钟源**”。

目前两种方案：1. **用户态模拟方案**（QEMU）； 2. **内核态模拟方案**（KVM）；

在**QEMU**中，用**SIGALARM信号**来实现：QEMU利用**某种机制**，使**timer interrupt handler**会向**QEMU process**发送一个**SIGALARM信号**，处理该信号过程中再**模拟PIT**中**产生一次时钟**。QEMU再通过某种机制，将**此模拟PIT**发出的**模拟中断交付给kvm**，再由kvm**注入**到虚拟机中去。

目前的kvm版本支持**内核PIT**、**APIC**和**内核PIC**，因为这几个设备是**频繁使用**的，在**内核模式中模拟**比在**用户模式模拟**性能更高。

kvm支持的时钟有8254, local apic timer,kvmclock等

这里重点是讲内核PIT的模拟实现，弄清楚它是如何为guest OS提供时钟的。

# 3. PIT(8254)模拟

Programmable Interval Timer, **可编程中断/间隔时钟**

KVM很多设备都是使用QEMU进行模拟的, 但是时钟已经在KVM重做了, 为了提升性能.

## 3.1. 相关结构体

### 3.1.1. struct kvm_pit: pit芯片

```cpp
struct kvm_kpit_channel_state {
        u32 count; /* can be 65536 */
        u16 latched_count;
        u8 count_latched;
        u8 status_latched;
        u8 status;
        u8 read_state;
        u8 write_state;
        u8 write_latch;
        u8 rw_mode;
        u8 mode;
        u8 bcd; /* not supported */
        u8 gate; /* timer start */
        ktime_t count_load_time;
};

struct kvm_kpit_state {
        /* All members before "struct mutex lock" are protected by the lock. */
        // pit的3个通道
        struct kvm_kpit_channel_state channels[3];
        u32 flags;
        // 是否周期性触发
        bool is_periodic;
        // 触发周期, 即超时时间, 单位是 ns
        s64 period;                             /* unit: ns */
        // pit对应的hrtimer定时器
        struct hrtimer timer;
        u32    speaker_data_on;

        struct mutex lock;
        atomic_t reinject;
        atomic_t pending; /* accumulated triggered timers */
        atomic_t irq_ack;
        struct kvm_irq_ack_notifier irq_ack_notifier;
};

struct kvm_pit {
        // 设备操作函数
        struct kvm_io_device dev;
        // 扬声器的操作函数
        struct kvm_io_device speaker_dev;
        // 所属的虚拟机
        struct kvm *kvm;
        // 内核pit信息域
        struct kvm_kpit_state pit_state;
        int irq_source_id;
        struct kvm_irq_mask_notifier mask_notifier;
        // 工作worker, 一个内核线程
        struct kthread_worker *worker;
        // 超时work, 工作
        struct kthread_work expired;
};
```

### struct hrtimer

hrtimer，不是时钟源，只是一种高精准软件时钟计算方法，Linux现在一般时钟这个来计算ticker。

注: 不仅仅是kvm使用

详细参见`Linux/Time`

## 5. 初始化虚拟PIT

真实物理pit有3个通道, 虚拟的PIT其实也是要符合这个设定, 进行全功能模拟, 所以一定要先看下PIT的功能描述.

### 5.1. QEMU

PIT创建:

```cpp
// i8254.c
kvm_vm_ioctl(kvm_state, KVM_CREATE_PIT2, &config);
kvm_vm_ioctl(kvm_state, KVM_CREATE_PIT)
```

### 5.2. 整体流程

```cpp
kvm_vm_ioctl()  // vm ioctl的入口
 ├─  kvm_arch_vm_ioctl()     
 |   ├─ kvm->arch.vpit = kvm_create_pit(kvm, u.pit_config.flags);  // 创建pit, 赋值给kvm->arch.vpit
 |   |   ├─ kzalloc(sizeof(struct kvm_pit), GFP_KERNEL_ACCOUNT);  // 给pit分配空间
 |   |   ├─ pit->irq_source_id = kvm_request_irq_source_id(kvm); // 分配irq source id
 |   |   ├─ pid = get_pid(task_tgid(current)); // 
 |   |   ├─ pit->worker = kthread_create_worker(0, "kvm-pit/%d", pid_nr); // 在cpu0上创建work内核线程
 |   |   ├─ kthread_init_work(&pit->expired, pit_do_work); // 这个 pit_do_work 是一个函数，用来向客户机注入时钟中断
 |   |   ├─ hrtimer_init(&pit_state->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS); // pit hrtimer的初始化, 这个高精准定时器就作为虚拟时钟的时钟源
 |   |   ├─ it_state->timer.function = pit_timer_fn; // pit hrtimer的处理函数
 |   |   ├─ pit_state->irq_ack_notifier.irq_acked = kvm_pit_ack_irq; // 时钟中断模拟ack
 |   |   ├─ pit->mask_notifier.func = pit_mask_notifer; // 
 |   |   ├─ kvm_pit_reset(pit); // 重置pit, 会创建pit定时器
 |   |   |   ├─ for (i = 0; i < 3; i++) { // 3个通道
 |   |   |   ├─ pit_load_count(pit, i, 0); // 
 |   |   |   |   ├─ ps->channels[channel].count_load_time = ktime_get(); return; // 不是 通道0, 则获取时间然后直接返回
 |   |   |   |   └─ destroy_pit_timer(); // 是timer无效
 |   |   |   |       ├─ hrtimer_cancel(); // 删除一个正在排队定时器
 |   |   |   |       └─ kthread_flush_work(); // 
 |   |   |   ├─ } // 循环3次
 |   |   |   └─ kvm_pit_reset_reinject(pit); // 
 |   |   ├─ kvm_pit_set_reinject(pit, true); // 
 |   |   ├─ kvm_iodevice_init(&pit->dev, &pit_dev_ops); // 注册时钟的IO读写函数
 |   |   ├─ kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, KVM_PIT_BASE_ADDRESS, KVM_PIT_MEM_LENGTH, &pit->dev);// 注册时钟到bus总线上, PIO类型
 |   |   ├─ kvm_iodevice_init(&pit->speaker_dev, &speaker_dev_ops); // speaker 设备的操作注册
 |   |   └─ kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, KVM_SPEAKER_BASE_ADDRESS, 4, &pit->speaker_dev);   // 
```

### 5.3. 入口代码

```cpp
case KVM_CREATE_PIT:
        u.pit_config.flags = KVM_PIT_SPEAKER_DUMMY;
        goto create_pit;
case KVM_CREATE_PIT2:
        r = -EFAULT;
        if (copy_from_user(&u.pit_config, argp,
                                sizeof(struct kvm_pit_config)))
                goto out;
create_pit:
        mutex_lock(&kvm->lock);
        r = -EEXIST;
        if (kvm->arch.vpit)
                goto create_pit_unlock;
        r = -ENOMEM;
        kvm->arch.vpit = kvm_create_pit(kvm, u.pit_config.flags);
        if (kvm->arch.vpit)
                r = 0;
create_pit_unlock:
        mutex_unlock(&kvm->lock);
        break;
```

创建pit并赋值给 `kvm->arch.vpit`

### 5.4. kvm_create_pit(): 创建pit(8254)

```cpp
struct kvm_pit *kvm_create_pit(struct kvm *kvm, u32 flags)
{
        struct kvm_pit *pit;
        struct kvm_kpit_state *pit_state;
        struct pid *pid;
        pid_t pid_nr;
        int ret;
        // 给 kvm_pit 分配空间
        pit = kzalloc(sizeof(struct kvm_pit), GFP_KERNEL_ACCOUNT);
        if (!pit)
                return NULL;
        // 返回kvm中irq_sources_bitmap中没有被占用的第一位，作为irq_source_id
        // 分配irq id
        pit->irq_source_id = kvm_request_irq_source_id(kvm);
        if (pit->irq_source_id < 0)
                goto fail_request;

        mutex_init(&pit->pit_state.lock);

        pid = get_pid(task_tgid(current));
        pid_nr = pid_vnr(pid);
        put_pid(pid);
        // 在cpu0上创建work, 会建立一个内核线程并唤醒
        pit->worker = kthread_create_worker(0, "kvm-pit/%d", pid_nr);
        if (IS_ERR(pit->worker))
                goto fail_kthread;
        // 分配一个work(工作), 这个 pit_do_work 是工作函数，用来向客户机注入时钟中断
        // 此时还未开始工作, 需要先将该work(工作)挂到某个worker(内核线程)工作队列(即调用kthread_queue_work)
        kthread_init_work(&pit->expired, pit_do_work);
        // pit所属的虚拟机
        pit->kvm = kvm;
        // pit的信息域
        pit_state = &pit->pit_state;
        // 初始化hrtimer, 这个高精准定时器就作为虚拟PIT时钟的时钟源
        // 然而定时器的真实物理时钟源根据不同的硬件而不同
        hrtimer_init(&pit_state->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
        // hrtimer的中断处理函数
        pit_state->timer.function = pit_timer_fn;

        pit_state->irq_ack_notifier.gsi = 0;
        // 时钟中断ack模拟函数
        pit_state->irq_ack_notifier.irq_acked = kvm_pit_ack_irq;
        pit->mask_notifier.func = pit_mask_notifer;
        // 重置pit, 会启用定时器
        kvm_pit_reset(pit);

        kvm_pit_set_reinject(pit, true);

        mutex_lock(&kvm->slots_lock);
        // 注册时钟的IO读写函数
        kvm_iodevice_init(&pit->dev, &pit_dev_ops);
        // 注册时钟到bus总线上, 注册PIO型设备
        ret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, KVM_PIT_BASE_ADDRESS,
                                      KVM_PIT_MEM_LENGTH, &pit->dev);
        if (ret < 0)
                goto fail_register_pit;
        /* speaker的模拟 */
        if (flags & KVM_PIT_SPEAKER_DUMMY) {
                // 注册pit
                kvm_iodevice_init(&pit->speaker_dev, &speaker_dev_ops);
                // PIO类型
                ret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS,
                                              KVM_SPEAKER_BASE_ADDRESS, 4,
                                              &pit->speaker_dev);
                if (ret < 0)
                        goto fail_register_speaker;
        }
        mutex_unlock(&kvm->slots_lock);

        return pit;

fail_register_speaker:
        kvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &pit->dev);
fail_register_pit:
        mutex_unlock(&kvm->slots_lock);
        kvm_pit_set_reinject(pit, false);
        kthread_destroy_worker(pit->worker);
fail_kthread:
        kvm_free_irq_source_id(kvm, pit->irq_source_id);
fail_request:
        kfree(pit);
        return NULL;
}
```

大概总结一下:

1. 注册了一段IO，用来接收客户机的读写请求。
2. 给pit创建了一个worker(内核线程)和超时work(工作), 用来向客户机注入时钟中断
3. 注册一个**高精度定时器**并启用它, 作为**时钟中断**的**中断源**(触发源), 定时器的真实物理时钟源根据不同的硬件而不同

从这里可以得出一个结论，**没有真正的时钟源**，是**没有办法模拟时钟的**。而关键就在于**时钟中断**，有了时钟中断，其他的**定时器计数**都可以通过**软件来实现**，所以在i8254.c里面的其他代码基本上是怎么实现模拟定时器的。

初始化**hrtimer**，hrtimer中断处理函数为`pit_timer_fn`，hrtimer的启动在`kvm_pit_reset`里，每个1ms产生一次中断, 这个是符合物理真实pit功能的

所以**内核虚拟PIT**实际是利用**HOST**的**hrtimer实际时钟源**来提供**虚拟时钟**的。 

传统的低精度的为时间轮方案; hrtimer为高精度定时器，管理机制为红黑树管理方案；

此处注册的时间为**1ms一次**，并为**周期性**的；注册的中断处理函数`pit_timer_fn`;

```cpp
static void kvm_pit_reset(struct kvm_pit *pit)
{
        int i;
        struct kvm_kpit_channel_state *c;

        pit->pit_state.flags = 0;
        // 3个通道
        for (i = 0; i < 3; i++) {
                c = &pit->pit_state.channels[i];
                // disable timer, 不会启用timer
                c->mode = 0xff;
                // true, true, false
                c->gate = (i != 2);
                // val是0
                pit_load_count(pit, i, 0);
        }

        kvm_pit_reset_reinject(pit);
}
```



```cpp
static void pit_load_count(struct kvm_pit *pit, int channel, u32 val)
{
        struct kvm_kpit_state *ps = &pit->pit_state;

        pr_debug("load_count val is %u, channel is %d\n", val, channel);

        /*
         * The largest possible initial count is 0; this is equivalent
         * to 216 for binary counting and 104 for BCD counting.
         */
        if (val == 0)
                val = 0x10000;
        // 通道计数为 0x10000
        ps->channels[channel].count = val;
        // 非 0 通道, 返回
        if (channel != 0) {
                // 获取系统启动以来所经过的时间，不包含休眠时间
                ps->channels[channel].count_load_time = ktime_get();
                return;
        }
        // 往下都是通道0
        /* Two types of timer
         * mode 1 is one shot, mode 2 is period, otherwise del timer */
        // 通道0的mode, 这里是0xff
        // 注意, 这里没有调用创建定时器
        switch (ps->channels[0].mode) {
        case 0:
        case 1:
        /* FIXME: enhance mode 4 precision */
        case 4:
                // 单次触发
                create_pit_timer(pit, val, 0);
                break;
        case 2:
        case 3:
                // 周期性触发
                create_pit_timer(pit, val, 1);
                break;
        default:
                // 这里走的是这个流程, 删除定时器
                destroy_pit_timer(pit);
        }
}
```

```cpp

```

```cpp
#define NSEC_PER_SEC 1000000000L
#define KVM_PIT_FREQ 1193181

static void create_pit_timer(struct kvm_pit *pit, u32 val, int is_period)
{
        struct kvm_kpit_state *ps = &pit->pit_state;
        struct kvm *kvm = pit->kvm;
        s64 interval;

        if (!ioapic_in_kernel(kvm) ||
            ps->flags & KVM_PIT_FLAGS_HPET_LEGACY)
                return;
        // 间隔时间, 定时器超时时间
        // 这里 val 是 0x10000
        interval = mul_u64_u32_div(val, NSEC_PER_SEC, KVM_PIT_FREQ);

        pr_debug("create pit timer, interval is %llu nsec\n", interval);

        /* TODO The new value only affected after the retriggered */
        // 取消之前的定时器
        hrtimer_cancel(&ps->timer);
        kthread_flush_work(&pit->expired);
        // 设置定时器的超时时间
        ps->period = interval;
        // 是否周期触发
        ps->is_periodic = is_period;

        kvm_pit_reset_reinject(pit);

        /*
         * Do not allow the guest to program periodic timers with small
         * interval, since the hrtimers are not throttled by the host
         * scheduler.
         */
        if (ps->is_periodic) {
                s64 min_period = min_timer_period_us * 1000LL;

                if (ps->period < min_period) {
                        pr_info_ratelimited(
                            "kvm: requested %lld ns "
                            "i8254 timer period limited to %lld ns\n",
                            ps->period, min_period);
                        ps->period = min_period;
                }
        }
        /*启用真正的高精准时钟*/
        hrtimer_start(&ps->timer, ktime_add_ns(ktime_get(), interval),
                      HRTIMER_MODE_ABS);
}
```

1. 根据

### 5.5. pit_timer_fn(): 中断流程

虚拟PIT注册了一个高精度定时器，1ms周期，注册的定时器处理函数为：

```cpp
static enum hrtimer_restart pit_timer_fn(struct hrtimer *data)
{
        struct kvm_kpit_state *ps = container_of(data, struct kvm_kpit_state, timer);
        struct kvm_pit *pt = pit_state_to_pit(ps);

        if (atomic_read(&ps->reinject))
                atomic_inc(&ps->pending);
        // 将这个工作(work)挂载到worker(内核线程)的工作列表(work->list)
        // 让worker(pt->worker, 内核线程)开始工作(pt->expired)
        // 工作的处理函数是pt->expired->func
        kthread_queue_work(pt->worker, &pt->expired);

        if (ps->is_periodic) {
                hrtimer_add_expires_ns(&ps->timer, ps->period);
                return HRTIMER_RESTART;
        } else
                return HRTIMER_NORESTART;
}
```

这里的work(工作)在`kvm_create_pit`函数里设置好（`kthread_init_work(&pit->expired, pit_do_work)`）

```cpp
static void pit_do_work(struct kthread_work *work)
{
        struct kvm_pit *pit = container_of(work, struct kvm_pit, expired);
        struct kvm *kvm = pit->kvm;
        struct kvm_vcpu *vcpu;
        int i;
        struct kvm_kpit_state *ps = &pit->pit_state;

        if (atomic_read(&ps->reinject) && !atomic_xchg(&ps->irq_ack, 0))
                return;

        kvm_set_irq(kvm, pit->irq_source_id, 0, 1, false);
        kvm_set_irq(kvm, pit->irq_source_id, 0, 0, false);

        /*
         * Provides NMI watchdog support via Virtual Wire mode.
         * The route is: PIT -> LVT0 in NMI mode.
         *
         * Note: Our Virtual Wire implementation does not follow
         * the MP specification.  We propagate a PIT interrupt to all
         * VCPUs and only when LVT0 is in NMI mode.  The interrupt can
         * also be simultaneously delivered through PIC and IOAPIC.
         */
        if (atomic_read(&kvm->arch.vapics_in_nmi_mode) > 0)
                kvm_for_each_vcpu(i, vcpu, kvm)
                        kvm_apic_nmi_wd_deliver(vcpu);
}
```

`kvm_apic_nmi_wd_deliver`最终会调用到`__apic_accept_irq`，在该函数里，设置**中断标志位**，然后通过`kvm_kick_vcpu`将**vcpu拉回到host**，等到**vcpu重新进入guest**时，将**中断信息**注入到**vmcs结构体**里，这样**vcpu回到guest**后就可以**处理tick中断**了。




# 6. 参考

