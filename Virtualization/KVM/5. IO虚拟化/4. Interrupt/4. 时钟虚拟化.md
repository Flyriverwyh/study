
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 硬件基础](#1-硬件基础)
- [2. Time Tick](#2-time-tick)
- [3. 虚拟化时钟](#3-虚拟化时钟)
- [4. struct hrtimer](#4-struct-hrtimer)
- [5. PIT(8254)模拟](#5-pit8254模拟)
  - [5.1. 相关结构体](#51-相关结构体)
    - [5.1.1. struct kvm_pit: pit芯片](#511-struct-kvm_pit-pit芯片)
  - [5.2. 初始化虚拟PIT](#52-初始化虚拟pit)
    - [5.2.1. QEMU](#521-qemu)
    - [5.2.2. 整体流程](#522-整体流程)
    - [5.2.3. 入口代码](#523-入口代码)
    - [5.2.4. kvm_create_pit(): 创建pit(8254)](#524-kvm_create_pit-创建pit8254)
      - [5.2.4.1. 初始化PIT的worker和work](#5241-初始化pit的worker和work)
      - [5.2.4.2. 初始化PIT的定时器hrtimer](#5242-初始化pit的定时器hrtimer)
      - [5.2.4.3. 重置pit](#5243-重置pit)
  - [5.3. 注册pit设备和pio接口](#53-注册pit设备和pio接口)
  - [5.4. pit的time tick和timer](#54-pit的time-tick和timer)
  - [5.5. 创建定时器](#55-创建定时器)
    - [5.5.1. 整体流程](#551-整体流程)
    - [5.5.2. 入口代码](#552-入口代码)
    - [5.5.3. create_pit_timer(): 创建定时器](#553-create_pit_timer-创建定时器)
    - [5.5.4. pit_timer_fn(): 定时器中断函数](#554-pit_timer_fn-定时器中断函数)
    - [pit_do_work(): 时钟中断注入](#pit_do_work-时钟中断注入)
- [6. 参考](#6-参考)

<!-- /code_chunk_output -->

# 1. 硬件基础

参见`Architecture/x86/7. 时钟.md`

- rtc
- pit
- hpet
- tsc
- local timer
- kvmclock

APIC Timer的模式APIC定时器包含**3种定时器模式**，
- 周期触发`periodic`
- 一次性触发`one-shot`
- `TSC-Deadline`模式(最新的CPU里面支持)。

# 2. Time Tick

一个操作系统要跑起来，必须有**Time Tick**，它就像是身体的脉搏。

普通情况下，**OS Time Tick**由**PIT**(i8254)或**APIC Timer**设备提供产生中断源

- PIT(i8254)定期(**每1ms**)产生一个**timer interrupt**，作为**global tick**, 
- **APIC Timer**产生一个**local tick**。

两者电子线路连接不同:
- 对于**i8254设备**来说首先连接到**i8259中断控制器**，i8259中断控制器再连接到**ioapic设备**中，送到**lapic**, 最后**注入到vcpu**中。
- 对于APIC Timer设备实际就是lapic的一个功能，意思就是通过编程可以触发lapic设备周期产生中断，然后注入到vcpu。

通过上面了解知道两者区别了**APIC Timer**的是**每个cpu**内核都有**一个定时器**，而**PIT是共用的一个**。

# 3. 虚拟化时钟

在虚拟化情况下，必须为**guest OS**模拟一个**PIT**和**APIC Timer**。

模拟的**PIT**和**APIC Timer**不能像真正硬件那样**物理计时**，所以一般用**HOST的某种系统服务**或**软件计时器**来为这个模拟 PIT/APIC Timer 提供模拟”**时钟源**”。

目前两种方案：1. **用户态模拟方案**（QEMU）； 2. **内核态模拟方案**（KVM）；

在**QEMU**中，用**SIGALARM信号**来实现：QEMU利用**某种机制**，使**timer interrupt handler**会向**QEMU process**发送一个**SIGALARM信号**，处理该信号过程中再**模拟PIT**中**产生一次时钟**。QEMU再通过某种机制，将**此模拟PIT**发出的**模拟中断交付给kvm**，再由kvm**注入**到虚拟机中去。

目前的kvm版本支持**内核PIT**、**APIC**和**内核PIC**，因为这几个设备是**频繁使用**的，在**内核模式中模拟**比在**用户模式模拟**性能更高。

kvm支持的时钟有8254, local apic timer, kvmclock等

# 4. struct hrtimer

hrtimer，不是时钟源，只是一种高精准**软件时钟**定时器，Linux一般用这个来计算ticker, 定时器的真实物理时钟源根据不同的硬件而不同

可作为超时或周期性定时器使用

传统的低精度的为时间轮方案; hrtimer为高精度定时器，管理机制为红黑树管理方案；

注: 不仅仅是kvm使用

主要涉及接口:

1. `hrtimer_init()`: 初始化定时器, 设置工作模式
2. `hrtimer_start()`: 启用一个定时器, 第二个参数用于设置超时参数
3. `hrtimer_cancel()`: 取消一个定时器

详细参见`Linux/Time`

# 5. PIT(8254)模拟

Programmable Interval Timer, **可编程中断/间隔时钟**

KVM很多设备都是使用QEMU进行模拟的, 但是时钟已经在KVM重做了, 为了提升性能.

## 5.1. 相关结构体

### 5.1.1. struct kvm_pit: pit芯片

```cpp
struct kvm_kpit_channel_state {
        u32 count; /* can be 65536 */
        u16 latched_count;
        u8 count_latched;
        u8 status_latched;
        u8 status;
        u8 read_state;
        u8 write_state;
        u8 write_latch;
        u8 rw_mode;
        u8 mode;
        u8 bcd; /* not supported */
        u8 gate; /* timer start */
        ktime_t count_load_time;
};

struct kvm_kpit_state {
        /* All members before "struct mutex lock" are protected by the lock. */
        // pit的3个通道
        struct kvm_kpit_channel_state channels[3];
        u32 flags;
        // 是否周期性触发
        bool is_periodic;
        // 触发周期, 即超时时间, 单位是 ns
        s64 period;                             /* unit: ns */
        // pit对应的hrtimer定时器
        struct hrtimer timer;
        u32    speaker_data_on;

        struct mutex lock;
        atomic_t reinject;
        atomic_t pending; /* accumulated triggered timers */
        atomic_t irq_ack;
        struct kvm_irq_ack_notifier irq_ack_notifier;
};

struct kvm_pit {
        // 设备操作函数
        struct kvm_io_device dev;
        // 扬声器的操作函数
        struct kvm_io_device speaker_dev;
        // 所属的虚拟机
        struct kvm *kvm;
        // 内核pit信息域
        struct kvm_kpit_state pit_state;
        int irq_source_id;
        struct kvm_irq_mask_notifier mask_notifier;
        // 工作worker, 一个内核线程
        struct kthread_worker *worker;
        // 超时work, 工作
        struct kthread_work expired;
};
```

## 5.2. 初始化虚拟PIT

真实物理pit有3个通道, 虚拟的PIT其实也是要符合这个设定, 进行全功能模拟, 所以一定要先看下PIT的功能描述.

### 5.2.1. QEMU

PIT创建:

```cpp
// i8254.c
kvm_vm_ioctl(kvm_state, KVM_CREATE_PIT2, &config);
kvm_vm_ioctl(kvm_state, KVM_CREATE_PIT)
```

### 5.2.2. 整体流程

```cpp
kvm_vm_ioctl()  // vm ioctl的入口
 ├─  kvm_arch_vm_ioctl()     
 |   ├─ kvm->arch.vpit = kvm_create_pit(kvm, u.pit_config.flags);  // 创建pit, 赋值给kvm->arch.vpit
 |   |   ├─ kzalloc(sizeof(struct kvm_pit), GFP_KERNEL_ACCOUNT);  // 给pit分配空间
 |   |   ├─ pit->irq_source_id = kvm_request_irq_source_id(kvm); // 分配irq source id
 |   |   ├─ pid = get_pid(task_tgid(current)); // 
 |   |   ├─ pit->worker = kthread_create_worker(0, "kvm-pit/%d", pid_nr); // 在cpu0上创建PIT的worker内核线程
 |   |   ├─ kthread_init_work(&pit->expired, pit_do_work); // 超时work, pit_do_work用来向客户机注入时钟中断
 |   |   ├─ hrtimer_init(&pit_state->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS); // pit hrtimer的初始化, 这个高精准定时器就作为虚拟时钟的时钟源
 |   |   ├─ it_state->timer.function = pit_timer_fn; // pit hrtimer的处理函数
 |   |   ├─ pit_state->irq_ack_notifier.irq_acked = kvm_pit_ack_irq; // 时钟中断模拟ack
 |   |   ├─ pit->mask_notifier.func = pit_mask_notifer; // 
 |   |   ├─ kvm_pit_reset(pit); // 重置pit, 会创建pit定时器
 |   |   |   ├─ for (i = 0; i < 3; i++) { // 3个通道
 |   |   |   ├─ pit_load_count(pit, i, 0); // 
 |   |   |   |   ├─ ps->channels[channel].count_load_time = ktime_get(); return; // 不是 通道0, 则获取时间然后直接返回
 |   |   |   |   └─ destroy_pit_timer(); // 使timer无效
 |   |   |   |       ├─ hrtimer_cancel(&pit->pit_state.timer); // 取消pit的定时器, 但是因为hrtimer没有start, 所以这个动作也就没作用
 |   |   |   |       └─ kthread_flush_work(&pit->expired); // 停止worker前, 保证pit的超时work已完成, 因为pit的work没有执行, 所以不涉及
 |   |   |   ├─ } // 循环3次
 |   |   |   └─ kvm_pit_reset_reinject(pit); // 
 |   |   ├─ kvm_pit_set_reinject(pit, true); // 
 |   |   ├─ kvm_iodevice_init(&pit->dev, &pit_dev_ops); // 注册pit的IO读写函数
 |   |   ├─ kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, KVM_PIT_BASE_ADDRESS, KVM_PIT_MEM_LENGTH, &pit->dev);// 注册pit的io到bus总线上, PIO类型
 |   |   ├─ kvm_iodevice_init(&pit->speaker_dev, &speaker_dev_ops); // speaker 设备的io操作注册
 |   |   └─ kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, KVM_SPEAKER_BASE_ADDRESS, 4, &pit->speaker_dev);   // 注册pit的speaker读写函数
```

### 5.2.3. 入口代码

```cpp
case KVM_CREATE_PIT:
        u.pit_config.flags = KVM_PIT_SPEAKER_DUMMY;
        goto create_pit;
case KVM_CREATE_PIT2:
        r = -EFAULT;
        if (copy_from_user(&u.pit_config, argp,
                                sizeof(struct kvm_pit_config)))
                goto out;
create_pit:
        mutex_lock(&kvm->lock);
        r = -EEXIST;
        if (kvm->arch.vpit)
                goto create_pit_unlock;
        r = -ENOMEM;
        kvm->arch.vpit = kvm_create_pit(kvm, u.pit_config.flags);
        if (kvm->arch.vpit)
                r = 0;
create_pit_unlock:
        mutex_unlock(&kvm->lock);
        break;
```

创建pit并赋值给 `kvm->arch.vpit`

### 5.2.4. kvm_create_pit(): 创建pit(8254)

```cpp
struct kvm_pit *kvm_create_pit(struct kvm *kvm, u32 flags)
{
        struct kvm_pit *pit;
        struct kvm_kpit_state *pit_state;
        struct pid *pid;
        pid_t pid_nr;
        int ret;
        // 给 kvm_pit 分配空间
        pit = kzalloc(sizeof(struct kvm_pit), GFP_KERNEL_ACCOUNT);
        if (!pit)
                return NULL;
        // 返回kvm中irq_sources_bitmap中没有被占用的第一位，作为irq_source_id
        // 分配irq id
        pit->irq_source_id = kvm_request_irq_source_id(kvm);
        if (pit->irq_source_id < 0)
                goto fail_request;

        mutex_init(&pit->pit_state.lock);

        pid = get_pid(task_tgid(current));
        pid_nr = pid_vnr(pid);
        put_pid(pid);
        // 在cpu0上创建work, 会建立一个内核线程并唤醒
        pit->worker = kthread_create_worker(0, "kvm-pit/%d", pid_nr);
        if (IS_ERR(pit->worker))
                goto fail_kthread;
        // 分配一个work(工作), 这个 pit_do_work 是工作函数，用来向客户机注入时钟中断
        // 此时还未开始工作, 需要先将该work(工作)挂到某个worker(内核线程)工作队列(即调用kthread_queue_work)
        kthread_init_work(&pit->expired, pit_do_work);
        // pit所属的虚拟机
        pit->kvm = kvm;
        // pit的信息域
        pit_state = &pit->pit_state;
        // 初始化hrtimer, 这个高精准定时器就作为虚拟PIT时钟的时钟源
        // 然而定时器的真实物理时钟源根据不同的硬件而不同
        hrtimer_init(&pit_state->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
        // hrtimer的中断处理函数
        pit_state->timer.function = pit_timer_fn;

        pit_state->irq_ack_notifier.gsi = 0;
        // 时钟中断ack模拟函数
        pit_state->irq_ack_notifier.irq_acked = kvm_pit_ack_irq;
        pit->mask_notifier.func = pit_mask_notifer;
        // 重置pit, 这里面不会启用hrtimer
        kvm_pit_reset(pit);

        kvm_pit_set_reinject(pit, true);

        mutex_lock(&kvm->slots_lock);
        // 注册时钟的IO读写函数
        kvm_iodevice_init(&pit->dev, &pit_dev_ops);
        // 注册时钟到bus总线上, 注册PIO型设备
        ret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, KVM_PIT_BASE_ADDRESS,
                                      KVM_PIT_MEM_LENGTH, &pit->dev);
        if (ret < 0)
                goto fail_register_pit;
        /* speaker的模拟 */
        if (flags & KVM_PIT_SPEAKER_DUMMY) {
                // 注册pit
                kvm_iodevice_init(&pit->speaker_dev, &speaker_dev_ops);
                // PIO类型
                ret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS,
                                              KVM_SPEAKER_BASE_ADDRESS, 4,
                                              &pit->speaker_dev);
                if (ret < 0)
                        goto fail_register_speaker;
        }
        mutex_unlock(&kvm->slots_lock);

        return pit;

fail_register_speaker:
        kvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &pit->dev);
fail_register_pit:
        mutex_unlock(&kvm->slots_lock);
        kvm_pit_set_reinject(pit, false);
        kthread_destroy_worker(pit->worker);
fail_kthread:
        kvm_free_irq_source_id(kvm, pit->irq_source_id);
fail_request:
        kfree(pit);
        return NULL;
}
```

大概总结一下:

1. 注册了一段IO，用来接收客户机的读写请求。
2. 给pit创建了一个worker(内核线程)和超时work(工作), 用来向客户机注入时钟中断
3. 注册一个**高精度定时器**, 作为**时钟中断**的**中断源**(触发源), 定时器的真实物理时钟源根据不同的硬件而不同

从这里可以得出一个结论，**没有真正的时钟源**，是**没有办法模拟时钟的**。而关键就在于**时钟中断**，有了时钟中断，其他的**定时器计数**都可以通过**软件来实现**，所以在i8254.c里面的其他代码基本上是怎么实现模拟定时器的。

#### 5.2.4.1. 初始化PIT的worker和work

```cpp
pit->worker = kthread_create_worker(0, "kvm-pit/%d", pid_nr);
kthread_init_work(&pit->expired, pit_do_work);
```

先给PIT创建了worker(内核线程); 然后初始化了一个work(工作), 用于向客户机注入时钟中断

worker主要函数有3个:
- `pool->worker = kthread_create_worker()`: 
创建一个worker, 其实就是创建一个内核线程并唤醒
- `kthread_init_work(&pool->work, work_func);`: 创建一个work, 工作函数是`work_func`
- `kthread_queue_work(pool->worker, &pool->work);`: 将这个work添加到worker的工作队列, 让worker开始工作
- `kthread_flush_work()`: 用来在最后要停止worker的处理线程之前,保证所有的work都已经处理了

#### 5.2.4.2. 初始化PIT的定时器hrtimer

初始化一个高精准定时器，这个定时器就作为我们**虚拟时钟的时钟源**, 然而定时器的物理时钟源根据不同的硬件而不同

```cpp
hrtimer_init(&pit_state->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
pit_state->timer.function = pit_timer_fn;
```

这里调用了前两步, 还没开始让worker工作(参见前面hrtimer的介绍)

- 给PIT初始化了**hrtimer**，初始化工作模式, 作为**PIT的时钟源**
- 设置hrtimer中断处理函数为`pit_timer_fn`，注意该回调函数为原子操作不能被中断

注: 这里没有启用hrtimer(`hrtimer_start`), 而且其实整个创建流程都没有启用hrtimer

由此可见, 所以**内核虚拟PIT**实际是利用**HOST**的**hrtimer实际时钟源**来提供**虚拟时钟**的。 

#### 5.2.4.3. 重置pit

```cpp
static void kvm_pit_reset(struct kvm_pit *pit)
{
        int i;
        struct kvm_kpit_channel_state *c;

        pit->pit_state.flags = 0;
        // 3个通道
        for (i = 0; i < 3; i++) {
                c = &pit->pit_state.channels[i];
                // disable timer, 不会启用timer
                c->mode = 0xff;
                // true, true, false
                c->gate = (i != 2);
                // val是0
                pit_load_count(pit, i, 0);
        }

        kvm_pit_reset_reinject(pit);
}
```

调用`pit_load_count()`, 注意这里面没有启用定时器, 反而清理了这个定时器

```cpp
static void pit_load_count(struct kvm_pit *pit, int channel, u32 val)
{
        struct kvm_kpit_state *ps = &pit->pit_state;

        pr_debug("load_count val is %u, channel is %d\n", val, channel);

        /*
         * The largest possible initial count is 0; this is equivalent
         * to 216 for binary counting and 104 for BCD counting.
         */
        if (val == 0)
                val = 0x10000;
        // 通道计数为 0x10000
        ps->channels[channel].count = val;
        // 非 0 通道, 返回
        if (channel != 0) {
                // 获取系统启动以来所经过的时间，不包含休眠时间
                ps->channels[channel].count_load_time = ktime_get();
                return;
        }
        // 往下都是通道0
        /* Two types of timer
         * mode 1 is one shot, mode 2 is period, otherwise del timer */
        // 通道0的mode, 这里是0xff
        // 注意, 这里没有调用创建定时器
        switch (ps->channels[0].mode) {
        case 0:
        case 1:
        /* FIXME: enhance mode 4 precision */
        case 4:
                // 单次触发
                create_pit_timer(pit, val, 0);
                break;
        case 2:
        case 3:
                // 周期性触发
                create_pit_timer(pit, val, 1);
                break;
        default:
                // 这里走的是这个流程, 取消定时器
                destroy_pit_timer(pit);
        }
}
```

调用`destroy_pit_timer()`使PIT的timer(定时器)无效

```cpp
static void destroy_pit_timer(struct kvm_pit *pit)
{
        // 取消一个正在排队定时器, 但是因为hrtimer没有start, 所以这个动作在当前流程也就没作用
        // 取消pit的定时器
        hrtimer_cancel(&pit->pit_state.timer);
        // 停止worker前, 保证所有work已完成, 因为pit的work没有执行, 所以在当前流程不涉及
        // 清理pit的超时work
        kthread_flush_work(&pit->expired);
}
```

`hrtimer_cancel`函数的作用是**删除一个正在排队的定时器**。这里分三种情况，一种是定时器**已到期**，并且设置了软中断模式；第二种是没有到期，还在红黑树中；第三种是定时器正在执行。

- 第一种情况，定时器被挂在`hrtimer_cpu_base`的`cb_pending`队列中，所以需要把它从pending队列中移出。

- 第二种情况，定时器还在红黑树中，那么把它**从红黑树中移出**。由于本文暂时只考虑高精度没有打开的情况，所以先不研究定时器正好排在红黑树第一个时的情况（即代码中调用hrtimer_force_reprogram函数的部分）。

- 第三种情况删除失败，`hrtimer_cancel`函数会循环重试，等到定时器**执行完**的时候再删除。（这在多CPU系统中可能会发生)

## 5.3. 注册pit设备和pio接口

```cpp
#define KVM_PIT_BASE_ADDRESS 0x40
#define KVM_PIT_MEM_LENGTH 4
#define KVM_SPEAKER_BASE_ADDRESS 0x61

// 初始化pit的io操作函数
kvm_iodevice_init(&pit->dev, &pit_dev_ops);
// 注册pit设备到bus总线上, 注册PIO型设备
// 0x40 ~ 0x43
ret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, KVM_PIT_BASE_ADDRESS,
                                KVM_PIT_MEM_LENGTH, &pit->dev);

// 注册pit speaker的io操作函数
kvm_iodevice_init(&pit->speaker_dev, &speaker_dev_ops);
// PIO类型
// 0x61 ~ 0x64
ret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS,
                                KVM_SPEAKER_BASE_ADDRESS, 4,
                                &pit->speaker_dev);
```

查看虚拟机的ioports

```
[root@lihaiwei-vm ~]# cat /proc/ioports
0000-0cf7 : PCI Bus 0000:00
  0000-001f : dma1
  0020-0021 : pic1
  0040-0043 : timer0 // pit设备操作接口
  0050-0053 : timer1
  0060-0060 : keyboard
  0064-0064 : keyboard
  0070-0071 : rtc0
  0080-008f : dma page reg
  00a0-00a1 : pic2
  ...
```

因为没有speaker, 所以看不到

## 5.4. pit的time tick和timer

pit的原本语义中, 频率为**1000Hz左右**, 即**每次中断间隔约为1ms**, 通常接**IRQ0**产生**周期性的时钟中断信号！！！** 来充当**系统定时器**, 软件可以通过`0x40~0x43 I/O`端口进行操作. 

不过在linux中, 已经被高精度时钟取代了, 所以可以看到, 哪怕基于KVM的虚拟机也已经**放弃**了基于PIT的**time tick**.

目前仅仅保留了计数器系统, 通过**时钟中断**来满足程序的**定时器需求**.

## 5.5. 创建定时器

可以看到, 因为取消了基于PIT的time tick功能, 所以前面创建PIT没有真正创建定时器.

那什么时候创建定时器? 

当guest os通过**寄存器操作**启动时, 即**客户机读写了8254的IO**，写了PIT channel的IO，说我需要一个定时器, 从而启动一个hrtimer来模拟**时钟中断源**.

```cpp
static const struct kvm_io_device_ops pit_dev_ops = {
        .read     = pit_ioport_read,
        .write    = pit_ioport_write,
};
```

在前面创建pit中初始化了pit设备的读写函数.

PIT的操作属于Port IO, 整体流程是`handle_io() -> kvm_fast_pio_out() -> emulator_pio_out_emulated() -> emulator_pio_in_out() -> kernel_pio() -> kvm_io_bus_write() -> __kvm_io_bus_write() -> kvm_iodevice_write() -> dev->ops->write()`, 详细见PIO部分内容

那么我们在`pit_ioport_write`里面就需要分析这些IO，看用户是否需要创建定时器，如果需要就调用`create_pit_timer`函数创建一个PIT。

### 5.5.1. 整体流程

```cpp
handle_io()  // io vmexit入口
 ├─ dev->ops->write();     // pit设备的write调用
 |   ├─ pit_ioport_write();  // 写pit io入口
 |   |   ├─ struct kvm_pit *pit = dev_to_pit();  // 获取pit
 |   |   ├─ pit_load_count(); // 分配irq source id
 |   |   ├─ ps->channels[channel].count_load_time = ktime_get(); return; // 不是 通道0, 则获取时间然后直接返回
 |   |   ├─ create_pit_timer(); // 创建pit timer定时器
 |   |   |   ├─ s64 interval = mul_u64_u32_div(val, NSEC_PER_SEC, KVM_PIT_FREQ); // 计算间隔时间, 即定时器超时时间
 |   |   |   ├─ hrtimer_cancel(&ps->timer); // 取消pit定时器
 |   |   |   ├─ kthread_flush_work(&pit->expired); // 清理pit超时的work
 |   |   |   ├─ ps->period = interval; // 设置pit的超时时间
 |   |   |   ├─ ps->is_periodic = is_period; // 是否周期触发
 |   |   |   └─ hrtimer_start(&ps->timer, ktime_add_ns(ktime_get(), interval), HRTIMER_MODE_ABS); // 启用pit的hrtimer定时器
```

### 5.5.2. 入口代码

```cpp
static int pit_ioport_write(struct kvm_vcpu *vcpu,
                                struct kvm_io_device *this,
                            gpa_t addr, int len, const void *data)
{
        // 获取pit
        struct kvm_pit *pit = dev_to_pit(this);
        struct kvm_kpit_state *pit_state = &pit->pit_state;
        int channel, access;
        struct kvm_kpit_channel_state *s;
        u32 val = *(u32 *) data;
        if (!pit_in_range(addr))
                return -EOPNOTSUPP;

        val  &= 0xff;
        // &0x3, 通道号
        addr &= KVM_PIT_CHANNEL_MASK;

        mutex_lock(&pit_state->lock);

        if (val != 0)
                pr_debug("write addr is 0x%x, len is %d, val is 0x%x\n",
                         (unsigned int)addr, len, val);
        // 通道3
        if (addr == 3) {
                channel = val >> 6;
                if (channel == 3) {
                        /* Read-Back Command. */
                        for (channel = 0; channel < 3; channel++) {
                                s = &pit_state->channels[channel];
                                if (val & (2 << channel)) {
                                        if (!(val & 0x20))
                                                pit_latch_count(pit, channel);
                                        if (!(val & 0x10))
                                                pit_latch_status(pit, channel);
                                }
                        }
                } else {
                        /* Select Counter <channel>. */
                        s = &pit_state->channels[channel];
                        access = (val >> 4) & KVM_PIT_CHANNEL_MASK;
                        if (access == 0) {
                                pit_latch_count(pit, channel);
                        } else {
                                s->rw_mode = access;
                                s->read_state = access;
                                s->write_state = access;
                                s->mode = (val >> 1) & 7;
                                if (s->mode > 5)
                                        s->mode -= 4;
                                s->bcd = val & 1;
                        }
                }
        } else {
                // addr不为3
                /* Write Count. */
                s = &pit_state->channels[addr];
                switch (s->write_state) {
                default:
                case RW_STATE_LSB:
                        pit_load_count(pit, addr, val);
                        break;
                case RW_STATE_MSB:
                        pit_load_count(pit, addr, val << 8);
                        break;
                case RW_STATE_WORD0:
                        s->write_latch = val;
                        s->write_state = RW_STATE_WORD1;
                        break;
                case RW_STATE_WORD1:
                        pit_load_count(pit, addr, s->write_latch | (val << 8));
                        s->write_state = RW_STATE_WORD0;
                        break;
                }
        }

        mutex_unlock(&pit_state->lock);
        return 0;
}
```
关于`pit_load_count()`查看上面的函数详细说明, 会调用`create_pit_timer`

### 5.5.3. create_pit_timer(): 创建定时器

注册的中断处理函数`pit_timer_fn`;

```cpp
#define NSEC_PER_SEC 1000000000L
#define KVM_PIT_FREQ 1193181

static void create_pit_timer(struct kvm_pit *pit, u32 val, int is_period)
{
        struct kvm_kpit_state *ps = &pit->pit_state;
        struct kvm *kvm = pit->kvm;
        s64 interval;

        if (!ioapic_in_kernel(kvm) ||
            ps->flags & KVM_PIT_FLAGS_HPET_LEGACY)
                return;
        // 间隔时间, 定时器超时时间
        interval = mul_u64_u32_div(val, NSEC_PER_SEC, KVM_PIT_FREQ);

        pr_debug("create pit timer, interval is %llu nsec\n", interval);

        /* TODO The new value only affected after the retriggered */
        // 取消pit定时器
        hrtimer_cancel(&ps->timer);
        // 清理pit超时的work
        kthread_flush_work(&pit->expired);
        // 设置的超时时间
        ps->period = interval;
        // 是否周期触发
        ps->is_periodic = is_period;

        kvm_pit_reset_reinject(pit);

        /*
         * Do not allow the guest to program periodic timers with small
         * interval, since the hrtimers are not throttled by the host
         * scheduler.
         */
        // 周期性定时器
        if (ps->is_periodic) {
                // 最小周期时间
                s64 min_period = min_timer_period_us * 1000LL;

                if (ps->period < min_period) {
                        pr_info_ratelimited(
                            "kvm: requested %lld ns "
                            "i8254 timer period limited to %lld ns\n",
                            ps->period, min_period);
                        ps->period = min_period;
                }
        }
        // 启用真正的高精准时钟, 第二个参数是超时时间
        hrtimer_start(&ps->timer, ktime_add_ns(ktime_get(), interval),
                      HRTIMER_MODE_ABS);
}
```

这里的pit定时器`&ps->timer`是在pit初始化时候创建的, `hrtimer_init(&pit_state->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);`, 这里通过`hrtimer_start();`启用, 第二个参数是**设置超时参数**

这个函数也做了几件事情，可以总结如下2点：

1. 根据用户的需求，设置了一个**定时器**，作为**时钟中断触发的源头**。
2. 清空定时器中断参数。

说白了时钟定时器创建就是初始化了时钟中断。 

pit初始化时候也注册了定时器的中断处理函数`it_state->timer.function = pit_timer_fn;`

### 5.5.4. pit_timer_fn(): 定时器中断函数

注册的定时器处理函数为：

```cpp
static enum hrtimer_restart pit_timer_fn(struct hrtimer *data)
{
        // 得到pit
        struct kvm_kpit_state *ps = container_of(data, struct kvm_kpit_state, timer);
        struct kvm_pit *pt = pit_state_to_pit(ps);
        //如果时钟中断需要重新注入，就直接累加
        if (atomic_read(&ps->reinject))
                // 累加中断
                atomic_inc(&ps->pending);
        // 将这个工作(work)挂载到worker(内核线程)的工作列表(work->list)
        // 让worker(pt->worker, 内核线程)开始工作(pt->expired)
        // 工作的处理函数是pt->expired->func
        kthread_queue_work(pt->worker, &pt->expired);
        // 定时器是周期性触发
        if (ps->is_periodic) {
                // 再次启动定时器
                hrtimer_add_expires_ns(&ps->timer, ps->period);
                return HRTIMER_RESTART;
        } else
                return HRTIMER_NORESTART;
}
```

将超时work(`&pt->expired`)添加到工作线程(`pt->worker`), 这里的work(工作)在初始化pit中设置好（`kthread_init_work(&pit->expired, pit_do_work)`）

如果定时器周期触发，则再次启动定时器，否则销毁, 详细看hrtimer的机制

### pit_do_work(): 时钟中断注入

当定时器将时钟中断pending增加，并且添加完工作队列以后，接着就触发下面的时钟中断注入，如果上一个中断被接收，接着触发下一个。

```cpp
static void pit_do_work(struct kthread_work *work)
{
        struct kvm_pit *pit = container_of(work, struct kvm_pit, expired);
        struct kvm *kvm = pit->kvm;
        struct kvm_vcpu *vcpu;
        int i;
        struct kvm_kpit_state *ps = &pit->pit_state;

        if (atomic_read(&ps->reinject) && !atomic_xchg(&ps->irq_ack, 0))
                return;

        kvm_set_irq(kvm, pit->irq_source_id, 0, 1, false);
        kvm_set_irq(kvm, pit->irq_source_id, 0, 0, false);

        /*
         * Provides NMI watchdog support via Virtual Wire mode.
         * The route is: PIT -> LVT0 in NMI mode.
         *
         * Note: Our Virtual Wire implementation does not follow
         * the MP specification.  We propagate a PIT interrupt to all
         * VCPUs and only when LVT0 is in NMI mode.  The interrupt can
         * also be simultaneously delivered through PIC and IOAPIC.
         */
        if (atomic_read(&kvm->arch.vapics_in_nmi_mode) > 0)
                kvm_for_each_vcpu(i, vcpu, kvm)
                        kvm_apic_nmi_wd_deliver(vcpu);
}
```

`kvm_apic_nmi_wd_deliver`最终会调用到`__apic_accept_irq`，在该函数里，设置**中断标志位**，然后通过`kvm_kick_vcpu`将**vcpu拉回到host**，等到**vcpu重新进入guest**时，将**中断信息**注入到**vmcs结构体**里，这样**vcpu回到guest**后就可以**处理tick中断**了。




# 6. 参考

