
# 硬件基础



# 虚拟中断子系统逻辑图

KVM中断系统逻辑图如下

![2020-05-03-18-49-41.png](./images/2020-05-03-18-49-41.png)

KVM将**所有类型**的**IRQ CHIP**抽象出**一个接口**，类似于C++的interface抽象基类，定义了**中断的触发方法**`set()`以及**每个引脚**和**GSI**的**映射关系**，这些都是**和芯片类型无关**的，**具体的芯片**都是**继承和实现接口**，**虚拟设备的中断**发送给**IRQ CHIP接口**开始中断的模拟；分别实现了**PIC**、**IOAPIC**以及**MSI**的**set方法**进行，通过set方法完成对于**VCPU的中断注入**。

其中**IOAPIC**中对于**每个引脚**，又定义了**PRT**，**IOAPIC**收到中断后根据**RTE格式化**出**中断消息**并发送给**目标LAPIC**，LAPIC完成**中断的选举和注入实现**。

# 虚拟中断子系统的关系

## IRQ抽象接口层

![2020-05-03-19-01-08.png](./images/2020-05-03-19-01-08.png)

KVM中irq_routing指向了IRQ CHIP抽象接口的表kvm_irq_routing_table结构体。

kvm_irq_routing_table .chip每个成员对应一个引脚，内容记录了该引脚的GSI号，其实该成员已经不用了。kvm_irq_routing_table.map成员指向一个hash桶，桶上的每个元素对应一个抽象引脚，即每个链对一个IRQ号，链上的每个元素指向kvm_kernel_irq_routing_entry结构体，每个该结构体代表了一个具体芯片的set()方法的实现，在进行中断注入的时候，每种芯片的set方法都会被调用一下，在guest中会忽略没有实现的芯片类型发送的中断消息(其实这里是可以优化的，必经不需要多次的中断注入，在QEMU注册中断设备的时候就不要注册不需要的中断芯片类型)

 

kvm_kernel_irq_routing_entry结构体对应具体芯片的一个引脚，按照芯片类型实现kvm_kernel_irq_routing_entry.set接口，kvm_kernel_irq_routing_entry.chip成员记录了该结构体对应的具体是哪种芯片的那个引脚，kvm_kernel_irq_routing_entry.gsi记录了该引脚的gsi号。

 

可以参考kvm_set_routing_entry()、kvm_set_irq()函数

## PIC 芯片结构

![2020-05-03-19-02-53.png](./images/2020-05-03-19-02-53.png)

PIC是系统一个，由kvm.arch.vpic成员指向

Kvm_pic结构体就是虚拟PIC的实现dev_master、dev_slave、dev_eclr实现了虚拟PIC设备的PIO地址空间，并注册在KVM内核的PIO总线上，以便完成设备的IO操作，这个我会在后面的博文中对大家介绍，ECLR就是控制中断触发方式的寄存器; pics执行一个数组，每个元素指向kvm_kpic_state结构体，kvm_kpic_state结构体芯片的所有寄存器和状态，包括IRR，ISR，IMR等

## IOAPIC芯片结构

![2020-05-03-19-03-18.png](./images/2020-05-03-19-03-18.png)

IOAPIC在KVM实现中只有一个，由kvm.arch.vioapic指向kvm_ioapic结构体。

kvm_ioapic结构体就是虚拟IOAPIC。irr成员就是IRR寄存器。redirtbl[IOAPIC_NUM_PINS]是一个数组，构成PRT表，每个成员对一个IOAPIC的引脚，执行kvm_ioapic_redirect_entry结构体。

kvm_ioapic_redirect_entry结构体就是一个RTE，fields成员执行了RTE中的各个域，如dest_id和dest_mode用来确定目标CPU，vector用来确定中断向量号，remote_irr在level触发时候保证中断共享情况下可以处理到所有设备的中断请求。Fields和kvm_kernel_irq_routing_entry的gsi配合起来确定了一个完整的中断信息内容

## LAPIC芯片结构体

![2020-05-03-19-04-10.png](./images/2020-05-03-19-04-10.png)



# kvm_pic: PIC 芯片结构

```cpp
struct kvm_kpic_state {
        u8 last_irr;    /* edge detection */
        u8 irr;         /* interrupt request register */
        u8 imr;         /* interrupt mask register */
        u8 isr;         /* interrupt service register */
        u8 priority_add;        /* highest irq priority */
        u8 irq_base;
        u8 read_reg_select;
        u8 poll;
        u8 special_mask;
        u8 init_state;
        u8 auto_eoi;
        u8 rotate_on_auto_eoi;
        u8 special_fully_nested_mode;
        u8 init4;               /* true if 4 byte init */
        u8 elcr;                /* PIIX edge/trigger selection */
        u8 elcr_mask;
        u8 isr_ack;     /* interrupt ack detection */
        struct kvm_pic *pics_state;
};

struct kvm_pic {
        spinlock_t lock;
        bool wakeup_needed;
        unsigned pending_acks;
        struct kvm *kvm;
        struct kvm_kpic_state pics[2]; /* 0 is master pic, 1 is slave pic */
        int output;             /* intr from master PIC */
        struct kvm_io_device dev_master;
        struct kvm_io_device dev_slave;
        struct kvm_io_device dev_eclr;
        void (*ack_notifier)(void *opaque, int irq);
        unsigned long irq_states[PIC_NUM_PINS];
};
```

# 参考

https://blog.csdn.net/leoufung/article/details/53081207