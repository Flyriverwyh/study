
# 虚拟中断子系统逻辑图

KVM中断系统逻辑图如下

![2020-05-03-18-49-41.png](./images/2020-05-03-18-49-41.png)

KVM将**所有类型**的**IRQ CHIP**抽象出**一个接口**，类似于C++的interface抽象基类，定义了**中断的触发方法**`set()`以及**每个引脚**和**GSI**的**映射关系**，这些都是**和芯片类型无关**的，具体的芯片都是继承和实现接口，虚拟设备的中断发送给IRQ CHIP接口开始中断的模拟；分别实现了PIC、IOAPIC以及MSI的set方法进行，通过set方法完成对于VCPU的中断注入。其中IOAPIC中对于每个引脚，又定义了PRT，IOAPIC收到中断后根据RTE格式化出中断消息并发送给目标LAPIC，LAPIC完成中断的选举和注入实现。




# kvm_pic: PIC 芯片结构

```cpp
struct kvm_kpic_state {
        u8 last_irr;    /* edge detection */
        u8 irr;         /* interrupt request register */
        u8 imr;         /* interrupt mask register */
        u8 isr;         /* interrupt service register */
        u8 priority_add;        /* highest irq priority */
        u8 irq_base;
        u8 read_reg_select;
        u8 poll;
        u8 special_mask;
        u8 init_state;
        u8 auto_eoi;
        u8 rotate_on_auto_eoi;
        u8 special_fully_nested_mode;
        u8 init4;               /* true if 4 byte init */
        u8 elcr;                /* PIIX edge/trigger selection */
        u8 elcr_mask;
        u8 isr_ack;     /* interrupt ack detection */
        struct kvm_pic *pics_state;
};

struct kvm_pic {
        spinlock_t lock;
        bool wakeup_needed;
        unsigned pending_acks;
        struct kvm *kvm;
        struct kvm_kpic_state pics[2]; /* 0 is master pic, 1 is slave pic */
        int output;             /* intr from master PIC */
        struct kvm_io_device dev_master;
        struct kvm_io_device dev_slave;
        struct kvm_io_device dev_eclr;
        void (*ack_notifier)(void *opaque, int irq);
        unsigned long irq_states[PIC_NUM_PINS];
};
```

# 参考

https://blog.csdn.net/leoufung/article/details/53081207