
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 硬件基础](#1-硬件基础)
  - [1.1. PIC: 8259A](#11-pic-8259a)
  - [1.2. APIC](#12-apic)
  - [1.3. MSI](#13-msi)
  - [1.4. 中断触发方式](#14-中断触发方式)
  - [1.5. GSI](#15-gsi)
- [2. 资料](#2-资料)

<!-- /code_chunk_output -->

# 1. 硬件基础

**中断虚拟化**的关键在于**对中断控制器的模拟**，我们知道x86上中断控制器主要有**旧的中断控制器**PIC(intel 8259a)和适应于SMP框架的IOAPIC/LAPIC两种。

## 1.1. PIC: 8259A

最老的中断控制芯片就是**8259A**了，也就是PIC芯片，该种芯片8个引脚，为了扩展引脚数目，引入了主从两块芯片，利用一个引脚连接**主从两个芯片**，这样就一共有**15个引脚**了。

**IRQ = 起始base号 + pin**。**接收到设备中断**后，通过**拉高引脚**通知**CPU**，CPU收到中断发送**两个INT ACK**到**INTA**，第二个INTA期间，PIC向CPU提交中断vector。

## 1.2. APIC

后来出现了APIC，APIC分为IOAPIC和LAPIC。

**IOAPIC**位于**南桥**，有**24个引脚针**，LAPIC位与CPU内部。

LAPIC每CPU一个；IO APIC可以一个系统里面有多个，但是KVM中只实现了一个，可以根据自己的需要进行添加。设备发送中断，发送到IO APIC；IO APIC中存在着一个PRT表，每个PRT的表项成为RTE，RTE是每个引脚一个，IOAPIC引脚收到中断消息后，根据RTE得到目标LAPIC，并格式化出一个中断消息发送给LAPIC，同时置位remote irr(level)。

LAPIC接受到中断消息后，提取其中的VECTOR并设置IRR后，进行中断的选取，取得优先级最高的中断后，清除IRR，设置ISR，提交CPU进行中断处理，CPU处理完中断后，写LAPIC的EOI，通知IOAPIC清除remote irr(level且deassert)。

## 1.3. MSI

后来又出来的MSI中断，设备直接如果支持MSI的话，直接构造出MSI消息，MSI有个字段**Address**标明了**中断目标地址**，然后**设备直接发送中断给LAPIC**提交CPU，这种方式下，直接**绕过了IOAPIC**，效率更高。

## 1.4. 中断触发方式

这里需要额外说明一下，中断的触发方式分为level触发和edge触发；

- **level触发**就是一直将**引脚**保持在**高电平**（电平为**1**）直到**中断完成**，现在**PCI/PCIE设备**都是**level触发**；
- **edge**就是通过**一个电平边缘跳变**来触发的中断, 电平**从0到1**，或者**从1到0**，原来的**ISA设备**都是**edge触发**，在**kvm**中通过发送**level = 0**和**level = 1**的两个中断来**模拟一个edge中断**。

## 1.5. GSI

GSI 是ACPI 引入的概念，全称是Global System Interrupt。它为系统中**每个中断源**指定一个**唯一的中断号**。

如果GSI base 为0，**每个管脚**的·，**15以上的GSI号和IRQ值相等**，但是`[0~15]`是**按照规范映射！！！** 的，其实是GSI 2映射到了IRQ 0上了，在**KVM**中**引脚号就是IRQ号**。

中断和异常会打断顺序执行的程序流, 转而进入一条完全不同的执行路径.

# 2. 资料

参照: `Architecture` 和 `Architecture/x86/4. x86中断与异常.md`