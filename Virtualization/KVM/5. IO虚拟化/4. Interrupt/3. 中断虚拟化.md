
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 基本原理](#1-基本原理)
- [2. Time Tick](#2-time-tick)
  - [2.1. 物理环境下的timer](#21-物理环境下的timer)
  - [2.2. 虚拟化下的timer](#22-虚拟化下的timer)
  - [2.3. 相关物理芯片](#23-相关物理芯片)
    - [2.3.1. PIT主要为Intel 8254 PIT芯片](#231-pit主要为intel-8254-pit芯片)
    - [2.3.2. PIC主要为8259A PIC芯片](#232-pic主要为8259a-pic芯片)
    - [2.3.3. APIC](#233-apic)
- [3. 相关代码](#3-相关代码)
  - [struct kvm_pit: pit芯片](#struct-kvm_pit-pit芯片)
- [4. 整体流程](#4-整体流程)
- [5. 初始化中断控制器](#5-初始化中断控制器)
  - [5.1. LAPIC的创建](#51-lapic的创建)
    - [5.1.1. 整体流程](#511-整体流程)
    - [5.1.2. 代码入口](#512-代码入口)
  - [5.2. PIC和IOAPIC的创建](#52-pic和ioapic的创建)
    - [5.2.1. QEMU](#521-qemu)
    - [5.2.2. 整体流程](#522-整体流程)
    - [5.2.3. 入口代码](#523-入口代码)
    - [5.2.4. kvm_pic_init(): 虚拟pic(8259A)的初始化](#524-kvm_pic_init-虚拟pic8259a的初始化)
      - [5.2.4.1. kvm_io_bus_register_dev(): 在相应的io_bus总线上注册设备](#5241-kvm_io_bus_register_dev-在相应的io_bus总线上注册设备)
      - [5.2.4.2. 三种设备在虚拟bus上的结构](#5242-三种设备在虚拟bus上的结构)
    - [5.2.5. kvm_ioapic_init(): ioapic的初始化](#525-kvm_ioapic_init-ioapic的初始化)
    - [5.2.6. kvm_setup_default_irq_routing(): 默认中断路由表的初始化](#526-kvm_setup_default_irq_routing-默认中断路由表的初始化)
- [6. 初始化虚拟PIT](#6-初始化虚拟pit)
  - [6.1. QEMU](#61-qemu)
  - [6.2. 整体流程](#62-整体流程)
  - [6.3. 入口代码](#63-入口代码)
  - [6.4. kvm_create_pit(): 创建pit(8254)](#64-kvm_create_pit-创建pit8254)
  - [kvm_timer_fn(): 中断流程](#kvm_timer_fn-中断流程)
- [7. 参考](#7-参考)

<!-- /code_chunk_output -->

# 1. 基本原理

中断虚拟化**起始关键**在于**对中断控制器的虚拟化**.

在正常系统中:

中断控制器目前主要有**APIC**，这种架构下**设备控制器**通过**某种触发方式**通知**IO APIC**，**IO APIC**根据**自身维护**的**重定向表pci irq routing table**格式化出**一条中断消息**，把中断消息发送给**local APIC**，local APIC局部于CPU，即**每个CPU一个**，local APIC 具备**传统中断控制器的相关功能**以及各个寄存器，中断请求寄存器IRR，中断屏蔽寄存器IMR，中断服务寄存器ISR等.

针对这些关键部件的虚拟化是中断虚拟化的重点。

该文章以time tick的模拟为例, 

# 2. Time Tick

## 2.1. 物理环境下的timer

一个操作系统要跑起来，必须有**Time Tick**，它就像是身体的脉搏。

普通情况下，**OS Time Tick**由**PIT**(i8254)或**APIC Timer**设备提供产生中断源

- PIT(i8254)定期(**1ms in Linux**)产生一个**timer interrupt**，作为**global tick**, 
- **APIC Timer**产生一个**local tick**。

两者电子线路连接不同:
- 对于**i8254设备**来说首先连接到**i8259中断控制器**，i8259中断控制器再连接到**ioapic设备**中，送到**lapic**, 最后**注入到vcpu**中。
- 对于APIC Timer设备实际就是lapic的一个功能，意思就是通过编程可以触发lapic设备周期产生中断，然后注入到vcpu。

通过上面了解知道两者区别了**APIC Timer**的是**每个cpu**内核都有**一个定时器**，而**PIT是共用的一个**。

APIC Timer的模式APIC定时器包含**3种定时器模式**，
- 周期触发`periodic`
- 一次性触发`one-shot`
- `TSC-Deadline`模式(最新的CPU里面支持)。

## 2.2. 虚拟化下的timer

在虚拟化情况下，必须为**guest OS**模拟一个**PIT**和**APIC Timer**。

模拟的**PIT**和**APIC Timer**不能像真正硬件那样**物理计时**，所以一般用**HOST的某种系统服务**或**软件计时器**来为这个模拟 PIT 提供模拟”**时钟源**”。

目前两种方案：1. **用户态模拟方案**（QEMU）； 2. **内核态模拟方案**（KVM）；

在**QEMU**中，用**SIGALARM信号**来实现：QEMU利用**某种机制**，使**timer interrupt handler**会向**QEMU process**发送一个**SIGALARM信号**，处理该信号过程中再**模拟PIT**中**产生一次时钟**。QEMU再通过某种机制，将**此模拟PIT**发出的**模拟中断交付给kvm**，再由kvm**注入**到虚拟机中去。

目前的kvm版本支持**内核PIT**、**APIC**和**内核PIC**，因为这两个设备是**频繁使用**的，在**内核模式中模拟**比在**用户模式模拟**性能更高。

kvm支持的时钟有8254,local apic timer,kvmclock等

这里重点是讲内核PIT的模拟实现，弄清楚它是如何为guest OS提供时钟的。

## 2.3. 相关物理芯片

### 2.3.1. PIT主要为Intel 8254 PIT芯片

参见`Architecture/x86/7. 时钟.md`

### 2.3.2. PIC主要为8259A PIC芯片

**PIC**(**Programmable Interrupt Controller**), **可编程中断控制器**

它具有`IR0 ~ IR7`共**8个中断管脚**连接到**外部设备**. **中断管脚**具有**优先级**, 其中IR0优先级最高, IR7最低.

PIC有三个重要的寄存器:

(1) IRR(Interrupt Request Register, 中断请求寄存器)共8位, 对应IR0到IR7这8个中断管脚. 某位置为1表明收到了对应管脚的中断但未提交到CPU.

(2) ISR(Interrupt Service Register, 中断请求寄存器): 共8位, 某位置为1表明对应管脚的中断已经提交到CPU处理, 但CPU还未处理完.

(3) IMR(Interrupt Mask Register, 中断屏蔽寄存器): 共8位, 某位置为1表明对应的中断管脚被屏蔽.

### 2.3.3. APIC

见硬件基础

# 3. 相关代码

![2020-05-04-13-06-31.png](./images/2020-05-04-13-06-31.png)

## struct kvm_pit: pit芯片

```cpp
struct kvm_pit {
        struct kvm_io_device dev;
        struct kvm_io_device speaker_dev;
        struct kvm *kvm;
        struct kvm_kpit_state pit_state;
        int irq_source_id;
        struct kvm_irq_mask_notifier mask_notifier;
        struct kthread_worker *worker;
        struct kthread_work expired;
};
```

# 4. 整体流程

整个主要流程:

![2020-04-18-17-59.png](./images/2020-04-18-17-59.png)

修正: 重定向表中有目标lapic的id

# 5. 初始化中断控制器

考虑到中断实时性对性能的影响，**PIC和IOAPIC**的**设备模拟主要逻辑！！！** 都放到了**kvm模块**进行实现，**每个VCPU**的**LAPIC**则**完全！！！放到kvm**中进行实现。 

**i8259控制器**和**IOAPIC**的创建和初始化由**qemu和kvm配合完成**，包括了2个方面：

- **kvm**中**设备相关数据结构初始化！！！**
- **qemu中设备模拟的初始化！！！**

**中断处理的逻辑**放在**kvm内核模块**中进行实现，但**设备的模拟**呈现还是需要**qemu设备模拟器**来搞定，最后qemu和kvm一起配合完成快速中断处理的流程。

所以在**qemu**中也会创建**i8259A**和**ioapic**

## 5.1. LAPIC的创建

由于**APIC Timer设备**实际就是**lapic的一个功能**，所以在创建lapic设备同时，也就辅助设置了。

不存在qemu侧流程

### 5.1.1. 整体流程

```cpp
kvm_arch_vcpu_create()  // vcpu创建中创建lapic
 ├─ kvm_create_lapic() // lapic创建入口 
 |   ├─ kzalloc(sizeof(*apic), GFP_KERNEL_ACCOUNT);  // 如果irqchip在kvm中实现, 则直接返回, 不执行任何动作
 |   ├─ vcpu->arch.apic = apic;  // 
 |   ├─ apic->regs = (void *)get_zeroed_page(GFP_KERNEL_ACCOUNT); //
 |   ├─ hrtimer_init(&apic->lapic_timer.timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_HARD);  //初始化hrtimer
 |   ├─ apic->lapic_timer.timer.function = apic_timer_fn;  // hrtimer回调函数
 |   ├─ apic->lapic_timer.timer_advance_ns;  // advanced timer
 |   └─ kvm_iodevice_init(&apic->dev, &apic_mmio_ops);  // 
 ├─ kvm_vcpu_reset(vcpu, false); // 对vcpu结构进行初始化
 |   ├─ kvm_lapic_reset(vcpu, init_event); // 设置寄存器的值为默认值
```

### 5.1.2. 代码入口

lapic是每个vcpu一个, 所以在创建vcpu流程中创建了lapic

```cpp
int kvm_create_lapic(struct kvm_vcpu *vcpu, int timer_advance_ns)
{
        struct kvm_lapic *apic;

        ASSERT(vcpu != NULL);
        // 分配apic结构体
        apic = kzalloc(sizeof(*apic), GFP_KERNEL_ACCOUNT);
        if (!apic)
                goto nomem;

        vcpu->arch.apic = apic;

        apic->regs = (void *)get_zeroed_page(GFP_KERNEL_ACCOUNT);
        if (!apic->regs) {
                printk(KERN_ERR "malloc apic regs error for vcpu %x\n",
                       vcpu->vcpu_id);
                goto nomem_free_apic;
        }
        apic->vcpu = vcpu;
        // 建立hrtimer, 回调函数 apic_timer_fn
        hrtimer_init(&apic->lapic_timer.timer, CLOCK_MONOTONIC,
                     HRTIMER_MODE_ABS_HARD);
        apic->lapic_timer.timer.function = apic_timer_fn;
        if (timer_advance_ns == -1) {
                apic->lapic_timer.timer_advance_ns = LAPIC_TIMER_ADVANCE_NS_INIT;
                lapic_timer_advance_dynamic = true;
        } else {
                apic->lapic_timer.timer_advance_ns = timer_advance_ns;
                lapic_timer_advance_dynamic = false;
        }

        /*
         * APIC is created enabled. This will prevent kvm_lapic_set_base from
         * thinking that APIC state has changed.
         */
        vcpu->arch.apic_base = MSR_IA32_APICBASE_ENABLE;
        static_key_slow_inc(&apic_sw_disabled.key); /* sw disabled at reset */
        kvm_iodevice_init(&apic->dev, &apic_mmio_ops);

        return 0;
nomem_free_apic:
        kfree(apic);
        vcpu->arch.apic = NULL;
nomem:
        return -ENOMEM;
}
```

其中`hrtimer_init`是创建了一个时钟定时器，用来实现时钟的模拟

因为**APIC Timer设备**实际就是lapic的一个功能，所以在创建lapic设备**同时创建**了。





## 5.2. PIC和IOAPIC的创建

### 5.2.1. QEMU

qemu代码中中断控制器的kvm内核初始化流程为：

```cpp
configure_accelerator
    |--> accel_init_machine
        |--> kvm_init
            |--> kvm_irqchip_create
                |--> kvm_vm_ioctl(s, KVM_CREATE_IRQCHIP)
                |--> kvm_init_irq_routing

// kvm-all.c/kvm_init/kvm_irqchip_create
kvm_vm_ioctl(s, KVM_CREATE_IRQCHIP)
```

qemu通过kvm的ioctl命令`KVM_CREATE_IRQCHIP`调用到kvm内核模块中，在**内核模块**中**创建和初始化PIC/IOAPIC设备**（创建设备对应的数据结构并将设备注册到总线上）。

### 5.2.2. 整体流程

```cpp
kvm_vm_ioctl()  // vm ioctl的入口
 ├─  kvm_arch_vm_ioctl()     
 |   ├─ irqchip_in_kernel(kvm)  // 如果irqchip在kvm中实现, 则直接返回, 不执行任何动作
 |   ├─ kvm_pic_init()   // pic创建, 8259
 |   |   ├─ struct kvm_pic *s = kzalloc(sizeof(struct kvm_pic), GFP_KERNEL_ACCOUNT);   // 创建kvm_pic结构
 |   |   ├─ kvm_iodevice_init(&s->dev_master, &picdev_master_ops); // 注册master的IO端口读写函数
 |   |   ├─ kvm_iodevice_init(&s->dev_slave, &picdev_slave_ops); // 注册slave的IO端口读写函数
 |   |   ├─ kvm_iodevice_init(&s->dev_eclr, &picdev_eclr_ops); // 注册eclr的IO端口读写函数
 |   |   ├─ kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0x20, 2, &s->dev_master); // 注册了PIO型的bus访问形式；另一种IO形式为MMIO；
 |   |   ├─ kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0xa0, 2, &s->dev_slave); // 注册了PIO型的bus访问形式；另一种IO形式为MMIO；
 |   |   ├─ kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0x4d0, 2, &s->dev_eclr); // 注册了PIO型的bus访问形式；另一种IO形式为MMIO；
 |   |   └─ kvm->arch.vpic = s;   // 将s赋值给kvm->arch.vpic
 |   ├─ kvm_ioapic_init()   // ioapic的初始化
 |   |   ├─ struct kvm_ioapic *ioapic = kzalloc(sizeof(struct kvm_ioapic), GFP_KERNEL_ACCOUNT);  // 创建kvm_pic结构
 |   ├─ kvm_setup_default_irq_routing();   // 设置默认的irq路由表
 |   |   └─ x86_emulate_instruction(vcpu, cr2_or_gpa, emulation_type, insn, insn_len);   // 
 |   |       ├─ kzalloc(struct_size(new, map, nr_rt_entries), GFP_KERNEL_ACCOUNT); // 为中断路由表分配空间
 |   |       ├─ for (i = 0; i < nr; ++i)  // 循环默认的24个路由项
 |   |       ├─ kzalloc(sizeof(*e), GFP_KERNEL_ACCOUNT); // 为每个中断路由项分配空间
 |   |       ├─ setup_routing_entry(kvm, new, e, ue) // 设置路由项
 |   |       |    ├─ kvm_set_routing_entry(kvm, e, ue);;   // 设置路由项的set方法
 |   |       |    └─ hlist_add_head(&e->link, &rt->map[e->gsi]);   // 设置gsi对应的哈希链表
 |   |       └─ rcu_assign_pointer(kvm->irq_routing, new);   // 设置虚拟机中断路由表
 |   └─ kvm->arch.irqchip_mode = KVM_IRQCHIP_KERNEL;  // irqchip为kernel模式, 即在kernel中实现
```

### 5.2.3. 入口代码

```cpp
        case KVM_CREATE_IRQCHIP: {
                mutex_lock(&kvm->lock);

                r = -EEXIST;
                // 如果irqchip在kvm中实现, 则不用创建
                if (irqchip_in_kernel(kvm))
                        goto create_irqchip_unlock;

                r = -EINVAL;
                if (kvm->created_vcpus)
                        goto create_irqchip_unlock;
                // 主要过程, 是8259A pic初始化
                r = kvm_pic_init(kvm);
                if (r)
                        goto create_irqchip_unlock;
                // ioapic的初始化
                r = kvm_ioapic_init(kvm);
                if (r) {
                        kvm_pic_destroy(kvm);
                        goto create_irqchip_unlock;
                }
                // 建立默认中断路由表
                r = kvm_setup_default_irq_routing(kvm);
                if (r) {
                        kvm_ioapic_destroy(kvm);
                        kvm_pic_destroy(kvm);
                        goto create_irqchip_unlock;
                }
                /* Write kvm->irq_routing before enabling irqchip_in_kernel. */
                smp_wmb();
                // irq属于内核实现
                kvm->arch.irqchip_mode = KVM_IRQCHIP_KERNEL;
        create_irqchip_unlock:
                mutex_unlock(&kvm->lock);
                break;
        }
```

### 5.2.4. kvm_pic_init(): 虚拟pic(8259A)的初始化

`arch/x86/kvm/i8259.c`

```cpp
// arch/x86/kvm/i8259.c
int kvm_pic_init(struct kvm *kvm)
{
        struct kvm_pic *s;
        int ret;
        // 分配 kvm_pic 结构体
        s = kzalloc(sizeof(struct kvm_pic), GFP_KERNEL_ACCOUNT);
        if (!s)
                return -ENOMEM;
        spin_lock_init(&s->lock);
        // 该pic所属的kvm虚拟机
        s->kvm = kvm;
        s->pics[0].elcr_mask = 0xf8;
        s->pics[1].elcr_mask = 0xde;
        s->pics[0].pics_state = s;
        s->pics[1].pics_state = s;

        /*
         * Initialize PIO device
         */
        // 注册master的IO端口读写函数
        kvm_iodevice_init(&s->dev_master, &picdev_master_ops);
        kvm_iodevice_init(&s->dev_slave, &picdev_slave_ops);
        kvm_iodevice_init(&s->dev_eclr, &picdev_eclr_ops);
        mutex_lock(&kvm->slots_lock);
        // 注册了PIO型的bus访问形式；另一种IO形式为MMIO；
        ret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0x20, 2,
                                      &s->dev_master);
        if (ret < 0)
                goto fail_unlock;
        // 注册PIO类型bus的访问
        ret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0xa0, 2, &s->dev_slave);
        if (ret < 0)
                goto fail_unreg_2;
        // 注册PIO类型bus的访问
        ret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0x4d0, 2, &s->dev_eclr);
        if (ret < 0)
                goto fail_unreg_1;

        mutex_unlock(&kvm->slots_lock);

        kvm->arch.vpic = s;

        return 0;

fail_unreg_1:
        kvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &s->dev_slave);

fail_unreg_2:
        kvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &s->dev_master);

fail_unlock:
        mutex_unlock(&kvm->slots_lock);

        kfree(s);

        return ret;
}
```

#### 5.2.4.1. kvm_io_bus_register_dev(): 在相应的io_bus总线上注册设备

8259A PIC属于PIO访问类型.

```cpp
int kvm_io_bus_register_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr,
                            int len, struct kvm_io_device *dev)
{
        int i;
        struct kvm_io_bus *new_bus, *bus;
        struct kvm_io_range range;
        // 获取io_bus总线
        bus = kvm_get_bus(kvm, bus_idx);
        if (!bus)
                return -ENOMEM;

        /* exclude ioeventfd which is limited by maximum fd */
        if (bus->dev_count - bus->ioeventfd_count > NR_IOBUS_DEVS - 1)
                return -ENOSPC;
        // 分配新的io_bus
        new_bus = kmalloc(struct_size(bus, range, bus->dev_count + 1),
                          GFP_KERNEL_ACCOUNT);
        if (!new_bus)
                return -ENOMEM;

        range = (struct kvm_io_range) {
                .addr = addr,
                .len = len,
                .dev = dev,
        };

        for (i = 0; i < bus->dev_count; i++)
                if (kvm_io_bus_cmp(&bus->range[i], &range) > 0)
                        break;

        memcpy(new_bus, bus, sizeof(*bus) + i * sizeof(struct kvm_io_range));
        new_bus->dev_count++;
        new_bus->range[i] = range;
        memcpy(new_bus->range + i + 1, bus->range + i,
                (bus->dev_count - i) * sizeof(struct kvm_io_range));
        rcu_assign_pointer(kvm->buses[bus_idx], new_bus);
        synchronize_srcu_expedited(&kvm->srcu);
        kfree(bus);

        return 0;
}
```

#### 5.2.4.2. 三种设备在虚拟bus上的结构

虚拟bus总线结构如下, 注意IO端口地址与设备读写函数的关联

![2020-05-04-17-34-05.png](./images/2020-05-04-17-34-05.png)

每个`kvm_io_device`的设备都有对应的读写函数

### 5.2.5. kvm_ioapic_init(): ioapic的初始化

```cpp
int kvm_ioapic_init(struct kvm *kvm)
{
        struct kvm_ioapic *ioapic;
        int ret;
        // 分配 kmv_ioapic 结构体
        ioapic = kzalloc(sizeof(struct kvm_ioapic), GFP_KERNEL_ACCOUNT);
        if (!ioapic)
                return -ENOMEM;
        spin_lock_init(&ioapic->lock);
        // 
        INIT_DELAYED_WORK(&ioapic->eoi_inject, kvm_ioapic_eoi_inject_work);
        kvm->arch.vioapic = ioapic;
        // 重置ioapic
        kvm_ioapic_reset(ioapic);
        // 
        kvm_iodevice_init(&ioapic->dev, &ioapic_mmio_ops);
        ioapic->kvm = kvm;
        mutex_lock(&kvm->slots_lock);
        ret = kvm_io_bus_register_dev(kvm, KVM_MMIO_BUS, ioapic->base_address,
                                      IOAPIC_MEM_LENGTH, &ioapic->dev);
        mutex_unlock(&kvm->slots_lock);
        if (ret < 0) {
                kvm->arch.vioapic = NULL;
                kfree(ioapic);
        }

        return ret;
}
```

在MMIO_BUS上注册了ioapic设备

![2020-05-04-17-58-37.png](./images/2020-05-04-17-58-37.png)

### 5.2.6. kvm_setup_default_irq_routing(): 默认中断路由表的初始化

**中断路由表的初始化**通过`kvm_setup_default_irq_routing`函数实现，

```cpp
// 默认有24个表项
static const struct kvm_irq_routing_entry default_routing[] = {
        ROUTING_ENTRY2(0), ROUTING_ENTRY2(1),
        ROUTING_ENTRY2(2), ROUTING_ENTRY2(3),
        ROUTING_ENTRY2(4), ROUTING_ENTRY2(5),
        ROUTING_ENTRY2(6), ROUTING_ENTRY2(7),
        ROUTING_ENTRY2(8), ROUTING_ENTRY2(9),
        ROUTING_ENTRY2(10), ROUTING_ENTRY2(11),
        ROUTING_ENTRY2(12), ROUTING_ENTRY2(13),
        ROUTING_ENTRY2(14), ROUTING_ENTRY2(15),
        ROUTING_ENTRY1(16), ROUTING_ENTRY1(17),
        ROUTING_ENTRY1(18), ROUTING_ENTRY1(19),
        ROUTING_ENTRY1(20), ROUTING_ENTRY1(21),
        ROUTING_ENTRY1(22), ROUTING_ENTRY1(23),
};

int kvm_setup_default_irq_routing(struct kvm *kvm)
{
        return kvm_set_irq_routing(kvm, default_routing,
                                   ARRAY_SIZE(default_routing), 0);
}
```

首个参数kvm指定特定的虚拟机，后面`default_routing`是一个**全局**的`kvm_irq_routing_entry`**数组**，一共24项，该数组没别的作用，就是初始化`kvm_irq_routing_table`**路由表**

看一下这个**表项宏**：

```cpp
#define IOAPIC_ROUTING_ENTRY(irq) \
        { .gsi = irq, .type = KVM_IRQ_ROUTING_IRQCHIP,  \
          .u.irqchip = { .irqchip = KVM_IRQCHIP_IOAPIC, .pin = (irq) } }
#define ROUTING_ENTRY1(irq) IOAPIC_ROUTING_ENTRY(irq)
```

注意看这个结构体, `kvm_irq_routing_entry`, 不是`kvm_kernel_irq_routing_entry`

这是**初始化**`default_routing`的一个关键宏，**每一项**都是通过该宏**传递irq号**（`0-23`）64位下是`0-47`, 可见
- **gsi**就是**irq号**; 
- type是`KVM_IRQ_ROUTING_IRQCHIP`, irq芯片, 而非MSI.
- irqchip:
        - irqchip指明**芯片**, 有三种, pic master、pic slave和ioapic， 这里是**ioapic**
        - pin是引脚号， 等于irq

所以这里的**默认中断路由项**, 一共24项, 全部是**芯片类型**(非MSI), 而且是**ioapic**, gsi和引脚都是`0-24`

看`kvm_set_irq_routing`,

```cpp
int kvm_set_irq_routing(struct kvm *kvm,
                        const struct kvm_irq_routing_entry *ue,
                        unsigned nr,
                        unsigned flags)
{
        // 路由表
        struct kvm_irq_routing_table *new, *old;
        // 路由表项
        struct kvm_kernel_irq_routing_entry *e;
        u32 i, j, nr_rt_entries = 0;
        int r;
        /*正常情况下，nr_rt_entries=nr*/
        // 这里是 24
        for (i = 0; i < nr; ++i) {
                if (ue[i].gsi >= KVM_MAX_IRQ_ROUTES)
                        return -EINVAL;
                nr_rt_entries = max(nr_rt_entries, ue[i].gsi);
        }

        nr_rt_entries += 1;
        /* 为中断路由表申请空间 */
        new = kzalloc(struct_size(new, map, nr_rt_entries), GFP_KERNEL_ACCOUNT);
        if (!new)
                return -ENOMEM;
        /* 设置路由表的表项数目 */
        new->nr_rt_entries = nr_rt_entries;
        // 初始化路由表的每个芯片的每个引脚为GSI号, 为-1, 不再使用 
        for (i = 0; i < KVM_NR_IRQCHIPS; i++)
                for (j = 0; j < KVM_IRQCHIP_NUM_PINS; j++)
                        new->chip[i][j] = -1;
        /*初始化每一个路由项*/
        for (i = 0; i < nr; ++i) {
                r = -ENOMEM;
                // 为每个路由项申请空间
                e = kzalloc(sizeof(*e), GFP_KERNEL_ACCOUNT);
                if (!e)
                        goto out;

                r = -EINVAL;
                switch (ue->type) {
                // MSI类型的中断
                case KVM_IRQ_ROUTING_MSI:
                        if (ue->flags & ~KVM_MSI_VALID_DEVID)
                                goto free_entry;
                        break;
                default:
                        if (ue->flags)
                                goto free_entry;
                        break;
                }
                // 设置每一个路由项
                r = setup_routing_entry(kvm, new, e, ue);
                if (r)
                        goto free_entry;
                // 到下一项
                ++ue;
        }

        mutex_lock(&kvm->irq_lock);
        old = rcu_dereference_protected(kvm->irq_routing, 1);
        // 更新虚拟机路由表, 设置虚拟机中断路由表为new
        rcu_assign_pointer(kvm->irq_routing, new);
        kvm_irq_routing_update(kvm);
        kvm_arch_irq_routing_update(kvm);
        mutex_unlock(&kvm->irq_lock);

        kvm_arch_post_irq_routing_update(kvm);

        synchronize_srcu_expedited(&kvm->irq_srcu);
        /*释放old*/
        new = old;
        r = 0;
        goto out;

free_entry:
        kfree(e);
out:
        free_irq_routing_table(new);

        return r;
}
```

所以实际上，回到函数中`nr_rt_entries`就是数组中**项数**，接着为`kvm_irq_routing_table`**分配空间**，注意分配的空间包含**三部分**：

- `kvm_irq_routing_table`**结构**、
- `map`
- **nr个**`kvm_kernel_irq_routing_entry`

所以`kvm_irq_routing_table`的**大小**是和**全局数组的大小**一样的。

整个结构如下图所示

![2020-05-03-13-18-31.png](./images/2020-05-03-13-18-31.png)

根据上图就可以理解`new->rt_entries = (void *)&new->map[nr_rt_entries];`这行代码的含义. (注, 新代码已经不是这样, 但是这部分内容保留, 便于了解发展演进)

接下来是对table的chip数组做初始化，这里初始化为`-1`. 

接下来就是一个循环，对**每一个中断路由项**做初始化，该过程是通过`setup_routing_entry`函数实现的，这里看下该函数

```cpp
static int setup_routing_entry(struct kvm *kvm,
                               struct kvm_irq_routing_table *rt,
                               struct kvm_kernel_irq_routing_entry *e,
                               const struct kvm_irq_routing_entry *ue)
{
        struct kvm_kernel_irq_routing_entry *ei;
        int r;
        // 获取到这个路由项的gsi号
        u32 gsi = array_index_nospec(ue->gsi, KVM_MAX_IRQ_ROUTES);

        /*
         * Do not allow GSI to be mapped to the same irqchip more than once.
         * Allow only one to one mapping between GSI and non-irqchip routing.
         */
        // 遍历这个gsi对应的路由项链表
        hlist_for_each_entry(ei, &rt->map[gsi], link)
                // 如果不是芯片
                if (ei->type != KVM_IRQ_ROUTING_IRQCHIP ||
                    ue->type != KVM_IRQ_ROUTING_IRQCHIP ||
                    ue->u.irqchip.irqchip == ei->irqchip.irqchip)
                        return -EINVAL;
        // 路由项的gsi
        e->gsi = gsi;
        // 路由项的类型
        e->type = ue->type;
        // 设置该路由项的set方法
        r = kvm_set_routing_entry(kvm, e, ue);
        if (r)
                return r;
        // irq芯片, 而非MSI时候
        if (e->type == KVM_IRQ_ROUTING_IRQCHIP)
                // 设置路由表的chip. 即引脚号
                rt->chip[e->irqchip.irqchip][e->irqchip.pin] = e->gsi;
        // 添加到路由表的哈希链表
        hlist_add_head(&e->link, &rt->map[e->gsi]);

        return 0;
}
```

之前的初始化过程我们已经看见了，`.type`为`KVM_IRQ_ROUTING_IRQCHIP`，所以这里实际上就是把`e->gsi = ue->gsi; e->type = ue->type;`.

然后调用了`kvm_set_routing_entry`，该函数中主要是设置了`kvm_kernel_irq_routing_entry`中的**set函数**
- **IOAPIC**的话设置的是`kvm_set_ioapic_irq`函数，
- **pic**的话设置`kvm_set_pic_irq`函数

然后设置**irqchip的类型**和**管脚**，对于**IOAPIC**也是直接复制过来，PIC由于**管脚计算**是`irq%8`，所以这里需要**加上8的偏移**。之后**设置table的chip为gis号**。

最后就把`kvm_kernel_irq_routing_entry`**以gsi号位索引**，加入到了**map数组**中对应的**哈希链表**中。

```cpp
int kvm_set_routing_entry(struct kvm *kvm,
                          struct kvm_kernel_irq_routing_entry *e,
                          const struct kvm_irq_routing_entry *ue)
{
        /* We can't check irqchip_in_kernel() here as some callers are
         * currently inititalizing the irqchip. Other callers should therefore
         * check kvm_arch_can_set_irq_routing() before calling this function.
         */
        switch (ue->type) {
        // 芯片类型
        case KVM_IRQ_ROUTING_IRQCHIP:
                if (irqchip_split(kvm))
                        return -EINVAL;
                e->irqchip.pin = ue->u.irqchip.pin;
                switch (ue->u.irqchip.irqchip) {
                // pic slave, 注意没有break
                case KVM_IRQCHIP_PIC_SLAVE:
                        e->irqchip.pin += PIC_NUM_PINS / 2;
                        /* fall through */
                // pic master
                case KVM_IRQCHIP_PIC_MASTER:
                        if (ue->u.irqchip.pin >= PIC_NUM_PINS / 2)
                                return -EINVAL;
                        // set方法
                        e->set = kvm_set_pic_irq;
                        break;
                // ioapic
                case KVM_IRQCHIP_IOAPIC:
                        if (ue->u.irqchip.pin >= KVM_IOAPIC_NUM_PINS)
                                return -EINVAL;
                        // set 方法
                        e->set = kvm_set_ioapic_irq;
                        break;
                default:
                        return -EINVAL;
                }
                e->irqchip.irqchip = ue->u.irqchip.irqchip;
                break;
        // MSI类型
        case KVM_IRQ_ROUTING_MSI:
                e->set = kvm_set_msi;
                e->msi.address_lo = ue->u.msi.address_lo;
                e->msi.address_hi = ue->u.msi.address_hi;
                e->msi.data = ue->u.msi.data;

                if (kvm_msi_route_invalid(kvm, e))
                        return -EINVAL;
                break;
        // HV SINT类型, 不懂
        case KVM_IRQ_ROUTING_HV_SINT:
                e->set = kvm_hv_set_sint;
                e->hv_sint.vcpu = ue->u.hv_sint.vcpu;
                e->hv_sint.sint = ue->u.hv_sint.sint;
                break;
        default:
                return -EINVAL;
        }

        return 0;
}
```

# 6. 初始化虚拟PIT

## 6.1. QEMU

PIT创建:

```cpp
// i8254.c
kvm_vm_ioctl(kvm_state, KVM_CREATE_PIT2, &config);
kvm_vm_ioctl(kvm_state, KVM_CREATE_PIT)
```

## 6.2. 整体流程

```cpp
kvm_vm_ioctl()  // vm ioctl的入口
 ├─  kvm_arch_vm_ioctl()     
 |   ├─ kvm->arch.vpit = kvm_create_pit(kvm, u.pit_config.flags);  // 创建pit, 赋值给kvm->arch.vpit
 |   |   ├─ kzalloc(sizeof(struct kvm_pit), GFP_KERNEL_ACCOUNT);  // 给pit分配空间
 |   |   ├─ pit->irq_source_id = kvm_request_irq_source_id(kvm); // 返回kvm中irq_sources_bitmap中没有被占用的第一位，作为irq_source_id
 |   |   ├─ pid = get_pid(task_tgid(current)); // 
 |   |   ├─ pit->worker = kthread_create_worker(0, "kvm-pit/%d", pid_nr); // 建立内核线程
 |   |   ├─ kthread_init_work(&pit->expired, pit_do_work); // 这个 pit_do_work 是一个函数，用来向客户机注入时钟中断
 |   |   ├─ hrtimer_init(&pit_state->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS); // pit hrtimer的初始化, 这个高精准定时器就作为虚拟时钟的时钟源
 |   |   ├─ it_state->timer.function = pit_timer_fn; // pit hrtimer的处理函数
 |   |   ├─ pit_state->irq_ack_notifier.irq_acked = kvm_pit_ack_irq; // 时钟中断模拟ack
 |   |   ├─ pit->mask_notifier.func = pit_mask_notifer; // 
 |   |   ├─ kvm_pit_reset(pit); // 
 |   |   |   ├─ for (i = 0; i < 3; i++) { // 3个通道
 |   |   |   ├─ pit_load_count(pit, i, 0); // 
 |   |   |   |   ├─ ps->channels[channel].count_load_time = ktime_get(); return; // 不是 通道0, 获取时间, 直接返回
 |   |   |   |   └─ create_pit_timer();
 |   |   |   |       ├─ interval = mul_u64_u32_div(val, NSEC_PER_SEC, KVM_PIT_FREQ); // 间隔时间
 |   |   |   |       └─ hrtimer_start(&ps->timer, ktime_add_ns(ktime_get(), interval), HRTIMER_MODE_ABS); // 
 |   |   |   ├─ } // 循环3次
 |   |   |   └─ kvm_pit_reset_reinject(pit); // 
 |   |   ├─ kvm_pit_set_reinject(pit, true); // 
 |   |   ├─ kvm_iodevice_init(&pit->dev, &pit_dev_ops); // 注册时钟的IO读写函数
 |   |   ├─ kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, KVM_PIT_BASE_ADDRESS, KVM_PIT_MEM_LENGTH, &pit->dev);// 注册时钟到bus总线上, PIO类型
 |   |   ├─ kvm_iodevice_init(&pit->speaker_dev, &speaker_dev_ops); // speaker 设备的操作注册
 |   |   └─ kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, KVM_SPEAKER_BASE_ADDRESS, 4, &pit->speaker_dev);   // 
```

## 6.3. 入口代码

```cpp
case KVM_CREATE_PIT:
        u.pit_config.flags = KVM_PIT_SPEAKER_DUMMY;
        goto create_pit;
case KVM_CREATE_PIT2:
        r = -EFAULT;
        if (copy_from_user(&u.pit_config, argp,
                                sizeof(struct kvm_pit_config)))
                goto out;
create_pit:
        mutex_lock(&kvm->lock);
        r = -EEXIST;
        if (kvm->arch.vpit)
                goto create_pit_unlock;
        r = -ENOMEM;
        kvm->arch.vpit = kvm_create_pit(kvm, u.pit_config.flags);
        if (kvm->arch.vpit)
                r = 0;
create_pit_unlock:
        mutex_unlock(&kvm->lock);
        break;
```

创建pit并赋值给 `kvm->arch.vpit`

## 6.4. kvm_create_pit(): 创建pit(8254)

```cpp
struct kvm_pit *kvm_create_pit(struct kvm *kvm, u32 flags)
{
        struct kvm_pit *pit;
        struct kvm_kpit_state *pit_state;
        struct pid *pid;
        pid_t pid_nr;
        int ret;
        // 分配空间
        pit = kzalloc(sizeof(struct kvm_pit), GFP_KERNEL_ACCOUNT);
        if (!pit)
                return NULL;
        // 返回kvm中irq_sources_bitmap中没有被占用的第一位，作为irq_source_id
        pit->irq_source_id = kvm_request_irq_source_id(kvm);
        if (pit->irq_source_id < 0)
                goto fail_request;

        mutex_init(&pit->pit_state.lock);

        pid = get_pid(task_tgid(current));
        pid_nr = pid_vnr(pid);
        put_pid(pid);
        // 建立内核线程
        pit->worker = kthread_create_worker(0, "kvm-pit/%d", pid_nr);
        if (IS_ERR(pit->worker))
                goto fail_kthread;
        // 这个 pit_do_work 是一个函数，用来向客户机注入时钟中断
        // 准备workqueue ?
        kthread_init_work(&pit->expired, pit_do_work);
        // pit所属的虚拟机
        pit->kvm = kvm;

        pit_state = &pit->pit_state;
        // 初始化hrtimer, 这个高精准定时器就作为虚拟时钟的时钟源
        hrtimer_init(&pit_state->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
        // hrtimer的处理函数
        pit_state->timer.function = pit_timer_fn;

        pit_state->irq_ack_notifier.gsi = 0;
        // 时钟中断模拟ack
        pit_state->irq_ack_notifier.irq_acked = kvm_pit_ack_irq;
        pit->mask_notifier.func = pit_mask_notifer;

        kvm_pit_reset(pit);

        kvm_pit_set_reinject(pit, true);

        mutex_lock(&kvm->slots_lock);
        // 注册时钟的IO读写函数
        kvm_iodevice_init(&pit->dev, &pit_dev_ops);
        // 注册时钟到bus总线上, 注册PIO型设备
        ret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, KVM_PIT_BASE_ADDRESS,
                                      KVM_PIT_MEM_LENGTH, &pit->dev);
        if (ret < 0)
                goto fail_register_pit;
        /* speaker的模拟 */
        if (flags & KVM_PIT_SPEAKER_DUMMY) {
                // 注册pit
                kvm_iodevice_init(&pit->speaker_dev, &speaker_dev_ops);
                // PIO类型
                ret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS,
                                              KVM_SPEAKER_BASE_ADDRESS, 4,
                                              &pit->speaker_dev);
                if (ret < 0)
                        goto fail_register_speaker;
        }
        mutex_unlock(&kvm->slots_lock);

        return pit;

fail_register_speaker:
        kvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &pit->dev);
fail_register_pit:
        mutex_unlock(&kvm->slots_lock);
        kvm_pit_set_reinject(pit, false);
        kthread_destroy_worker(pit->worker);
fail_kthread:
        kvm_free_irq_source_id(kvm, pit->irq_source_id);
fail_request:
        kfree(pit);
        return NULL;
}
```

这里的worker在`kvm_create_pit`函数里设置好（kthread_init_work(&pit->expired,pit_do_work)）

kvm_apic_nmi_wd_deliver最终会调用到__apic_accept_irq，在该函数里，设置中断标志位，然后通过kvm_kick_vcpu将vcpu拉回到host，等到vcpu重新进入guest时，将中断信息注入到vmcs结构体里，这样vcpu回到guest后就可以处理tick中断了。


内核虚拟PIT实际是利用**HOST**的**hrtimer实际时钟源**来提供**虚拟时钟**的。 

hrtimer为高精度定时器，管理机制为: 
- 传统的低精度的为时间轮方案；
- 高精度方案为红黑树管理方案；

此处注册的时间为**1ms一次**，并为**周期性**的；注册的中断处理函数`pit_timer_fn`;

```cpp
static void kvm_pit_reset(struct kvm_pit *pit)
{
        int i;
        struct kvm_kpit_channel_state *c;

        pit->pit_state.flags = 0;
        for (i = 0; i < 3; i++) {
                c = &pit->pit_state.channels[i];
                c->mode = 0xff;
                c->gate = (i != 2);
                pit_load_count(pit, i, 0);
        }

        kvm_pit_reset_reinject(pit);
}
```



```cpp
static void pit_load_count(struct kvm_pit *pit, int channel, u32 val)
{
        struct kvm_kpit_state *ps = &pit->pit_state;

        pr_debug("load_count val is %u, channel is %d\n", val, channel);

        /*
         * The largest possible initial count is 0; this is equivalent
         * to 216 for binary counting and 104 for BCD counting.
         */
        if (val == 0)
                val = 0x10000;

        ps->channels[channel].count = val;

        if (channel != 0) {
                ps->channels[channel].count_load_time = ktime_get();
                return;
        }

        /* Two types of timer
         * mode 1 is one shot, mode 2 is period, otherwise del timer */
        switch (ps->channels[0].mode) {
        case 0:
        case 1:
        /* FIXME: enhance mode 4 precision */
        case 4:
                create_pit_timer(pit, val, 0);
                break;
        case 2:
        case 3:
                create_pit_timer(pit, val, 1);
                break;
        default:
                destroy_pit_timer(pit);
        }
}
```

```cpp
static void create_pit_timer(struct kvm_pit *pit, u32 val, int is_period)
{
        struct kvm_kpit_state *ps = &pit->pit_state;
        struct kvm *kvm = pit->kvm;
        s64 interval;

        if (!ioapic_in_kernel(kvm) ||
            ps->flags & KVM_PIT_FLAGS_HPET_LEGACY)
                return;

        interval = mul_u64_u32_div(val, NSEC_PER_SEC, KVM_PIT_FREQ);

        pr_debug("create pit timer, interval is %llu nsec\n", interval);

        /* TODO The new value only affected after the retriggered */
        hrtimer_cancel(&ps->timer);
        kthread_flush_work(&pit->expired);
        ps->period = interval;
        ps->is_periodic = is_period;

        kvm_pit_reset_reinject(pit);

        /*
         * Do not allow the guest to program periodic timers with small
         * interval, since the hrtimers are not throttled by the host
         * scheduler.
         */
        if (ps->is_periodic) {
                s64 min_period = min_timer_period_us * 1000LL;

                if (ps->period < min_period) {
                        pr_info_ratelimited(
                            "kvm: requested %lld ns "
                            "i8254 timer period limited to %lld ns\n",
                            ps->period, min_period);
                        ps->period = min_period;
                }
        }

        hrtimer_start(&ps->timer, ktime_add_ns(ktime_get(), interval),
                      HRTIMER_MODE_ABS);
}
```

## kvm_timer_fn(): 中断流程

虚拟PIT注册了一个高精度定时器，1ms周期，注册的定时器处理函数为：



# 7. 参考

