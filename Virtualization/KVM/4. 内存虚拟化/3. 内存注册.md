
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [基本原理](#基本原理)
- [基本流程](#基本流程)
- [代码分析](#代码分析)
  - [](#)
  - [kvm_mem_slot 结构体: 一段空间虚拟机GPA到主机HVA的映射关系](#kvm_mem_slot-结构体-一段空间虚拟机gpa到主机hva的映射关系)
  - [kvm_vm_ioctl(): vm指令入口](#kvm_vm_ioctl-vm指令入口)
- [参考](#参考)

<!-- /code_chunk_output -->

# 基本原理

kvm虚拟机实际运行于`qemu-kvm`的**进程上下文**中，因此，需要建立**虚拟机的物理内存空间**(GPA)与`qemu-kvm`**进程的虚拟地址空间**(HVA)的映射关系。

**虚拟机的物理地址空间**实际也是**不连续**的，分成**不同的内存区域**(slot)，因为物理地址空间中通常还包括**BIOS**、**MMIO**、**显存**、**ISA保留**等部分。

qemu-kvm通过**ioctl vm**指令`KVM_SET_USER_MEMORY_REGION`来**为虚拟机设置内存**。主要建立**guest物理地址空间**中的内存区域与**qemu-kvm虚拟地址空间中的内存区域**的映射，从而建立其从**GVA到HVA的对应关系**，该**对应关系**主要通过`kvm_mem_slot`结构体保存，所以实质为设置kvm_mem_slot结构体。

本文简介ioctl vm指令KVM_SET_USER_MEMORY_REGION在内核中的执行流程，qemu-kvm用户态部分暂不包括。

本质是创建并填充了一个临时`kvm_memslots`结构，并把其赋值给`kvm->memslots`（全局的）。

# 基本流程

ioctl vm指令`KVM_SET_USER_MEMORY_REGION`在内核主要执行流程如下：

```cpp
kvm_vm_ioctl()
    kvm_vm_ioctl_set_memory_region()
        kvm_set_memory_region()
            __kvm_set_memory_region()
                kvm_iommu_unmap_pages() // 原来的slot需要删除，所以需要unmap掉相应的内存区域
                install_new_memslots() //将new分配的memslot写入kvm->memslots[]数组中
                kvm_free_physmem_slot() // 释放旧内存区域相应的物理内存(HPA)
```

# 代码分析

## 

```cpp
// include/linux/kvm_host.h
struct kvm {
        struct kvm_memslots __rcu *memslots[KVM_ADDRESS_SPACE_NUM];
```

一个`struct kvm`代表一个虚拟机, memslots是该虚拟机所有内存条, 注意最大`KVM_ADDRESS_SPACE_NUM`(这里是1), 用于将**GPA转换为HVA**. 

```cpp
/*
 * Note:
 * memslots are not sorted by id anymore, please use id_to_memslot()
 * to get the memslot by its id.
 */
struct kvm_memslots {
        u64 generation;
        /* The mapping table from slot id to the index in memslots[]. */
        short id_to_index[KVM_MEM_SLOTS_NUM];
        atomic_t lru_slot;
        int used_slots;
        struct kvm_memory_slot memslots[];
};
```

kvm_memslots

获取某一个`kvm_memory_slot`, 通过`id_to_memslot(struct kvm_memslots *slots, int id)`实现.

## kvm_mem_slot 结构体: 一段空间虚拟机GPA到主机HVA的映射关系

由于**GPA不能直接用于物理 MMU 进行寻址！！！**，所以需要**将GPA转换为HVA**，kvm中利用 `kvm_memory_slot` 数据结构来记录**每一个地址区间**(**Guest中的物理地址区间**)中**GPA与HVA**的**映射关系**.

```cpp
struct kvm_rmap_head {
        unsigned long val;
};

struct kvm_lpage_info {
        int disallow_lpage;
};

struct kvm_arch_memory_slot {
        struct kvm_rmap_head *rmap[KVM_NR_PAGE_SIZES];
        struct kvm_lpage_info *lpage_info[KVM_NR_PAGE_SIZES - 1];
        unsigned short *gfn_track[KVM_PAGE_TRACK_MAX];
};

struct kvm_memory_slot {
        // 虚拟机物理地址(即GPA)对应的页框号
        gfn_t base_gfn;
        // 当前slot中包含的page数目
        unsigned long npages;
        // 脏页位图
        unsigned long *dirty_bitmap;
        // 架构相关部分
        struct kvm_arch_memory_slot arch;
        /*
         * GPA对应的host虚拟地址(HVA), 由于虚拟机都运行在qemu的地址空间中
         * 而qemu是用户态程序, 所以通常使用root-module下的用户地址空间.
         */
        unsigned long userspace_addr;
        u32 flags;
        short id;
};
```

## kvm_vm_ioctl(): vm指令入口

**kvm ioctl vm指令的入口**，传入的fd为`KVM_CREATE_VM`中返回的fd。主要用于针对VM虚拟机进行控制，如：内存设置、创建VCPU等。

```cpp
static long kvm_vm_ioctl(struct file *filp,
             unsigned int ioctl, unsigned long arg)
{
    // 建立guest物理地址空间中的内存区域与qemu-kvm虚拟地址空间中的内存区域的映射
    case KVM_SET_USER_MEMORY_REGION: {
        // 存放内存区域信息的结构体，该内存区域从qemu-kvm进程的用户地址空间中分配
        struct kvm_userspace_memory_region kvm_userspace_mem;

        r = -EFAULT;
        // 从用户态拷贝相应数据到内核态，入参argp指向用户态地址
        if (copy_from_user(&kvm_userspace_mem, argp,
                        sizeof kvm_userspace_mem))
            goto out;
        // 进入实际处理流程
        r = kvm_vm_ioctl_set_memory_region(kvm, &kvm_userspace_mem);
        break;
    }
...
```
可以看到首要任务就是把参数复制到内核，然后调用了`kvm_vm_ioctl_set_memory_region()`函数。

```cpp
int kvm_vm_ioctl_set_memory_region(struct kvm *kvm,
                   struct kvm_userspace_memory_region *mem)
{
        // slot编号过大
    if (mem->slot >= KVM_USER_MEM_SLOTS)
        return -EINVAL;
    return kvm_set_memory_region(kvm, mem);
}
```

函数检查下slot编号如果超额，那没办法，无法添加，否则调用`kvm_set_memory_region()`函数。而该函数没做别的，最终调用 `__kvm_set_memory_region()`

```cpp
/*
 * Allocate some memory and give it an address in the guest physical address
 * space.
 *
 * Discontiguous memory is allowed, mostly for framebuffers.
 *
 * Must be called holding kvm->slots_lock for write.
 */
int __kvm_set_memory_region(struct kvm *kvm,
                            const struct kvm_userspace_memory_region *mem)
{
        struct kvm_memory_slot old, new;
        struct kvm_memory_slot *tmp;
        enum kvm_mr_change change;
        int as_id, id;
        int r;
        // 标记检查
        r = check_memory_region_flags(mem);
        if (r)
                return r;
        // address_space ID = slot编号右移4位
        as_id = mem->slot >> 16;
        // slot编号
        id = (u16)mem->slot;
        // 合规检查, 防止用户态恶意传参而导致安全漏洞
        /* 如果memory_size 不是页对齐, 直接失败 */
        if (mem->memory_size & (PAGE_SIZE - 1))
                return -EINVAL;
        // 如果客户机物理地址不是页对齐, 直接失败
        if (mem->guest_phys_addr & (PAGE_SIZE - 1))
                return -EINVAL;
        /* 如果slot的id在合法范围, 但是用户空间地址(host线性地址)不是页对齐/不在地址范围, 直接失败 */
        if ((id < KVM_USER_MEM_SLOTS) &&
            ((mem->userspace_addr & (PAGE_SIZE - 1)) ||
             !access_ok((void __user *)(unsigned long)mem->userspace_addr,
                        mem->memory_size)))
                return -EINVAL;
        // slot id太大, 失败
        if (as_id >= KVM_ADDRESS_SPACE_NUM || id >= KVM_MEM_SLOTS_NUM)
                return -EINVAL;
        if (mem->guest_phys_addr + mem->memory_size < mem->guest_phys_addr)
                return -EINVAL;

        /*
         * Make a full copy of the old memslot, the pointer will become stale
         * when the memslots are re-sorted by update_memslots(), and the old
         * memslot needs to be referenced after calling update_memslots(), e.g.
         * to free its resources and for arch specific behavior.
         */
        // 根据 kvm_userspace_memory_region->slot(qemu的内存槽号) 得到 kvm_mem_slot(kvm的内存槽号) 结构，该结构从 kvm->memslots 获取
        // 完全拷贝了一份到tmp
        tmp = id_to_memslot(__kvm_memslots(kvm, as_id), id);
        if (tmp) {
                old = *tmp;
                tmp = NULL;
        } else {
                memset(&old, 0, sizeof(old));
                old.id = id;
        }
        // 新设置区域大小为 0, 意味着删除原有区域, 然后直接返回
        if (!mem->memory_size)
                // 最终还是会调用 kvm_set_memslot
                return kvm_delete_memslot(kvm, mem, &old, as_id);
        
        // 新的 kvm_memory_slot
        new.id = id;
        // 内存区域起始位置在Guest物理地址空间中的页框号
        new.base_gfn = mem->guest_phys_addr >> PAGE_SHIFT;
        // 内存区域大小转换为page单位
        new.npages = mem->memory_size >> PAGE_SHIFT;
        new.flags = mem->flags;
        // HVA
        new.userspace_addr = mem->userspace_addr;

        if (new.npages > KVM_MEM_MAX_NR_PAGES)
                return -EINVAL;
        // 旧 pages 为0, 说明要创建新内存区域
        if (!old.npages) {
                /*
                 * 设置 KVM_MR_CREATE 标记
                 */
                change = KVM_MR_CREATE;
                new.dirty_bitmap = NULL;
                memset(&new.arch, 0, sizeof(new.arch));
        // 修改一个存在的slot
        } else { /* Modify an existing slot. */
                // 判断是否修改现有的内存区域
                // 旧 page 数不为 0
                // 修改的区域的HVA不同 或者 大小不同 或者 flag中的
                // KVM_MEM_READONLY 标记不同，直接退出。
                if ((new.userspace_addr != old.userspace_addr) ||
                    (new.npages != old.npages) ||
                    ((new.flags ^ old.flags) & KVM_MEM_READONLY))
                        return -EINVAL;
                /*
                 * 走到这，说明被修改的区域HVA和大小都是相同的
                 *
                 * 判断区域起始的 GFN 是否相同，如果不是，则说明需
                 * 要在Guest物理地址空间中move这段区域，设置KVM_MR_MOVE标记
                 * 也就是需要移动内存条
                 */
                if (new.base_gfn != old.base_gfn)
                        change = KVM_MR_MOVE;
                // 如果仅仅是flag不同，则仅修改标记，设置KVM_MR_FLAGS_ONLY标记
                else if (new.flags != old.flags)
                        change = KVM_MR_FLAGS_ONLY;
                // 否则, 啥也不干, 退出
                else /* Nothing to change. */
                        return 0;

                /* Copy dirty_bitmap and arch from the current memslot. */
                new.dirty_bitmap = old.dirty_bitmap;
                // 将原有slot的arch相关信息全部复制给新的slot
                memcpy(&new.arch, &old.arch, sizeof(new.arch));
        }
        // 对于创建或move, 检查重叠
        if ((change == KVM_MR_CREATE) || (change == KVM_MR_MOVE)) {
                /* Check for overlaps */
                // 检查已经存在的memslots中是否重叠, 有的话直接返回-EEXIST
                kvm_for_each_memslot(tmp, __kvm_memslots(kvm, as_id)) {
                        // 当前要加入的slot, 不管, 直接跳过
                        if (tmp->id == id)
                                continue;
                        // new_end > slot_base && new_base < slot_end，说明已经有覆盖该段内存了
                        if (!((new.base_gfn + new.npages <= tmp->base_gfn) ||
                              (new.base_gfn >= tmp->base_gfn + tmp->npages)))
                                return -EEXIST;
                }
        }

        /* Allocate/free page dirty bitmap as needed */
        if (!(new.flags & KVM_MEM_LOG_DIRTY_PAGES))
                new.dirty_bitmap = NULL;
        else if (!new.dirty_bitmap) {
                r = kvm_alloc_dirty_bitmap(&new);
                if (r)
                        return r;

                if (kvm_dirty_log_manual_protect_and_init_set(kvm))
                        bitmap_set(new.dirty_bitmap, 0, new.npages);
        }
        // 真正执行的代码
        r = kvm_set_memslot(kvm, mem, &old, &new, as_id, change);
        if (r)
                goto out_bitmap;

        if (old.dirty_bitmap && !new.dirty_bitmap)
                kvm_destroy_dirty_bitmap(&old);
        return 0;

out_bitmap:
        if (new.dirty_bitmap && !old.dirty_bitmap)
                kvm_destroy_dirty_bitmap(&new);
        return r;
}
EXPORT_SYMBOL_GPL(__kvm_set_memory_region);
```

该函数主要用来建立**guest物理地址空间**(虚拟机物理地址空间)中的**内存区域**与`qemu-kvm`**虚拟地址空间**(宿主机虚拟地址, HVA)中的**内存区域的映射**, 相应信息由`uerspace_memory_region` 参数传入，而其源头来自于**用户态qemu-kvm**。

check_memory_region_flags检查`mem->flags`是否合法，而当前flag也就使用了两位，`KVM_MEM_LOG_DIRTY_PAGES`和`KVM_MEM_READONLY`, 从qemu传过来的只能是`KVM_MEM_LOG_DIRTY_PAGES`

`id_to_memslot`则是根据**qemu的内存槽号i**得到**kvm结构下的内存槽号**，转换关系来自`id_to_index`数组，那映射关系怎么来的，映射关系是**一一对应**的，在kvm_create_vm虚拟机创建过程中，`kvm_init_memslots_id`初始化对应关系，即`slots->id_to_index[i] = slots->memslots[i].id = i`，当前映射是没有意义的，估计是为了后续扩展而存在的。

```cpp
static inline
struct kvm_memory_slot *id_to_memslot(struct kvm_memslots *slots, int id)
{
        int index = slots->id_to_index[id];
        struct kvm_memory_slot *slot;

        if (index < 0)
                return NULL;

        slot = &slots->memslots[index];

        WARN_ON(slot->id != id);
        return slot;
}
```

每次调用**设置一个内存区间**。内存区域可以**不连续**(实际的物理内存区域也经常不连续，因为有可能有保留内存)

另外看`kvm_mr_change`就知道memslot的变动值了：

```cpp
enum kvm_mr_change {
    KVM_MR_CREATE,
    KVM_MR_DELETE,
    KVM_MR_MOVE,
    KVM_MR_FLAGS_ONLY,
};
```

```cpp
static int kvm_delete_memslot(struct kvm *kvm,
                              const struct kvm_userspace_memory_region *mem,
                              struct kvm_memory_slot *old, int as_id)
{
        struct kvm_memory_slot new;
        int r;

        if (!old->npages)
                return -EINVAL;
        // 新的slot全部置为0
        memset(&new, 0, sizeof(new));
        new.id = old->id;
        // 也是调用kvm_set_memslot
        r = kvm_set_memslot(kvm, mem, old, &new, as_id, KVM_MR_DELETE);
        if (r)
                return r;
        // 释放掉旧slot的所有空间
        kvm_free_memslot(kvm, old);
        return 0;
}
```

最终调用`kvm_set_memslot()`

```cpp
static int kvm_set_memslot(struct kvm *kvm,
                           const struct kvm_userspace_memory_region *mem,
                           struct kvm_memory_slot *old,
                           struct kvm_memory_slot *new, int as_id,
                           enum kvm_mr_change change)
{
        struct kvm_memory_slot *slot;
        struct kvm_memslots *slots;
        int r;
        // 复制kvm->memslots的副本
        slots = kvm_dup_memslots(__kvm_memslots(kvm, as_id), change);
        if (!slots)
                return -ENOMEM;
        // 如果删除或move内存区域
        if (change == KVM_MR_DELETE || change == KVM_MR_MOVE) {
                /*
                 * Note, the INVALID flag needs to be in the appropriate entry
                 * in the freshly allocated memslots, not in @old or @new.
                 */
                // 获取旧的slot(内存条模型)
                slot = id_to_memslot(slots, old->id);
                // 在删除或move时, 旧slot应该不可用
                slot->flags |= KVM_MEMSLOT_INVALID;

                /*
                 * We can re-use the old memslots, the only difference from the
                 * newly installed memslots is the invalid flag, which will get
                 * dropped by update_memslots anyway.  We'll also revert to the
                 * old memslots if preparing the new memory region fails.
                 */
                // 安装新memslots，返回旧的memslots
                slots = install_new_memslots(kvm, as_id, slots);

                /* From this point no new shadow pages pointing to a deleted,
                 * or moved, memslot will be created.
                 *
                 * validation of sp->gfn happens in:
                 *      - gfn_to_hva (kvm_read_guest, gfn_to_pfn)
                 *      - kvm_is_visible_gfn (mmu_check_root)
                 */
                // flush影子页表中的条目
                kvm_arch_flush_shadow_memslot(kvm, slot);
        }
        // 
        r = kvm_arch_prepare_memory_region(kvm, new, mem, change);
        if (r)
                goto out_slots;
        // 更新
        update_memslots(slots, new, change);
        // 安装新memslots, 将其写入kvm->memslots[]数组, 返回旧的memslots
        slots = install_new_memslots(kvm, as_id, slots);

        kvm_arch_commit_memory_region(kvm, mem, old, new, change);
        // 释放旧内存区域相应的物理内存, HPA
        kvfree(slots);
        return 0;

out_slots:
        if (change == KVM_MR_DELETE || change == KVM_MR_MOVE)
                slots = install_new_memslots(kvm, as_id, slots);
        kvfree(slots);
        return r;
}
```

```cpp
int kvm_arch_prepare_memory_region(struct kvm *kvm,
                                struct kvm_memory_slot *memslot,
                                const struct kvm_userspace_memory_region *mem,
                                enum kvm_mr_change change)
{
        // 创建或move区域
        if (change == KVM_MR_CREATE || change == KVM_MR_MOVE)
                // 初始化memslot中arch相关内容
                return kvm_alloc_memslot_metadata(memslot,
                                                  mem->memory_size >> PAGE_SHIFT);
        return 0;
}
```

```cpp
static void update_memslots(struct kvm_memslots *slots,
                            struct kvm_memory_slot *memslot,
                            enum kvm_mr_change change)
{
        int i;
        // 删除
        if (change == KVM_MR_DELETE) {
                kvm_memslot_delete(slots, memslot);
        } else {
                if (change == KVM_MR_CREATE)
                        // 创建, 返回 slots->used_slots++
                        i = kvm_memslot_insert_back(slots);
                else    
                        // move
                        i = kvm_memslot_move_backward(slots, memslot);
                i = kvm_memslot_move_forward(slots, memslot, i);

                /*
                 * Copy the memslot to its new position in memslots and update
                 * its index accordingly.
                 */
                slots->memslots[i] = *memslot;
                slots->id_to_index[memslot->id] = i;
        }
}
```




```cpp
……
case KVM_SET_USER_MEMORY_REGION: {
        struct kvm_userspace_memory_region kvm_userspace_mem;
    
        r = -EFAULT;
        if (copy_from_user(&kvm_userspace_mem, argp,
                        sizeof (kvm_userspace_mem)))
            goto out;
        kvm_userspace_mem->flags |= 0x1;
        r = kvm_vm_ioctl_set_memory_region(kvm, &kvm_userspace_mem);
        break;
    }
……
```

可以看到首要任务就是把参数复制到内核，然后调用了kvm_vm_ioctl_set_memory_region()函数。

```cpp
int kvm_vm_ioctl_set_memory_region(struct kvm *kvm,
                   struct kvm_userspace_memory_region *mem)
{
    if (mem->slot >= KVM_USER_MEM_SLOTS)
        return -EINVAL;
    return kvm_set_memory_region(kvm, mem);
}
```

函数检查下slot编号如果超额，那没办法，无法添加，否则调用kvm_set_memory_region()函数。而该函数没做别的，直接调用了__kvm_set_memory_region。该函数比较长，咱们还是分段介绍。开始就是一些常规检查。

```cpp
if (mem->memory_size & (PAGE_SIZE - 1))
        goto out;
    if (mem->guest_phys_addr & (PAGE_SIZE - 1))
        goto out;
    /* We can read the guest memory with __xxx_user() later on. */
    if ((mem->slot < KVM_USER_MEM_SLOTS) &&
        ((mem->userspace_addr & (PAGE_SIZE - 1)) ||
         !access_ok(VERIFY_WRITE,
            (void   *)(unsigned long)mem->userspace_addr,
            mem->memory_size)))
        goto out;
    if (mem->slot >= KVM_MEM_SLOTS_NUM)
        goto out;
    if (mem->guest_phys_addr + mem->memory_size < mem->guest_phys_addr)
        goto out;
```

如果memory_size 不是页对齐的，则失败；如果mem的客户机物理地址不是页对齐的，也失败；如果slot的id在合法范围内但是用户空间地址不是页对齐的或者地址范围内的不能正常访问，则失败；如果slot id大于等于KVM_MEM_SLOTS_NUM，则失败；最后if我是没看明白啊，怎么可能越加越小呢，size也不可能是负值，该问题再议吧。

```cpp
    /*定位到指定slot*/
    slot = id_to_memslot(kvm->memslots, mem->slot);
    base_gfn = mem->guest_phys_addr >> PAGE_SHIFT;
    npages = mem->memory_size >> PAGE_SHIFT;

    r = -EINVAL;
    if (npages > KVM_MEM_MAX_NR_PAGES)
        goto out;
    /*如果npages为0，则设置*/
    if (!npages)
        mem->flags &= ~KVM_MEM_LOG_DIRTY_PAGES;
    /*new  为用户空间传递过来的mem,old为和用户空间mem id一致的mem*/
    new = old = *slot;

    new.id = mem->slot;
    new.base_gfn = base_gfn;
    new.npages = npages;
    new.flags = mem->flags;

    r = -EINVAL;
    /*如果new 的 npage不为0*/
    if (npages) {
        /*如果old 的npage为0，则创建新的mem*/
        if (!old.npages)
            change = KVM_MR_CREATE;
        /*否则修改已有的mem*/
        else { /* Modify an existing slot. */
            if ((mem->userspace_addr != old.userspace_addr) ||
                (npages != old.npages) ||
                ((new.flags ^ old.flags) & KVM_MEM_READONLY))
                goto out;
            /*如果两个mem映射的基址不同*/
            if (base_gfn != old.base_gfn)
                change = KVM_MR_MOVE;
            /*如果标志位不同则更新标志位*/
            else if (new.flags != old.flags)
                change = KVM_MR_FLAGS_ONLY;
            else { /* Nothing to change. */
                /*都一样的话就什么都不做*/
                r = 0;
                goto out;
            }
        }
    }
    /*如果new的npage为0而old的npage不为0，则需要delete已有的*/
    else if (old.npages) {
        change = KVM_MR_DELETE;
    } else /* Modify a non-existent slot: disallowed. */
        goto out;
```

这里如果检查都通过了，首先通过传递进来的slot的id在kvm维护的slot数组中找到对应的slot结构，此结构可能为空或者为旧的slot。然后获取物理页框号、页面数目。如果页面数目大于KVM_MEM_MAX_NR_PAGES，则失败；如果npages为0，则去除KVM_MEM_LOG_DIRTY_PAGES标志。使用旧的slot对新的slot内容做初始化，然后对new slot做设置，参数基本是从用户空间接收的kvm_userspace_memory_region的参数。然后进入下面的if判断

1、如果npages不为0，表明本次要添加slot此时如果old slot的npages为0，表明之前没有对应的slot，需要添加新的,设置change为KVM_MR_CREATE；如果不为0，则需要先修改已有的slot，注意这里如果old slot和new slot的page数目和用户空间地址必须相等，还有就是两个slot的readonly属性必须一致。如果满足上述条件，进入下面的流程。如果映射的物理页框号不同，则设置change KVM_MR_MOVE，如果flags不同，设置KVM_MR_FLAGS_ONLY，否则，什么都不做。

2、如果npages为0，而old.pages不为0，表明需要删除old slot,设置change为KVM_MR_DELETE。到这里基本是做一些准备工作，确定用户空间要进行的操作，接下来就执行具体的动作了


```cpp
if ((change == KVM_MR_CREATE) || (change == KVM_MR_MOVE)) {
        /* Check for overlaps */
        r = -EEXIST;
        kvm_for_each_memslot(slot, kvm->memslots) {
            if ((slot->id >= KVM_USER_MEM_SLOTS) ||
                (slot->id == mem->slot))
                continue;
            if (!((base_gfn + npages <= slot->base_gfn) ||
                  (base_gfn >= slot->base_gfn + slot->npages)))
                goto out;
        }
    }

    /* Free page dirty bitmap if unneeded */
    if (!(new.flags & KVM_MEM_LOG_DIRTY_PAGES))
        new.dirty_bitmap = NULL;

    r = -ENOMEM;
    if (change == KVM_MR_CREATE) {
        new.userspace_addr = mem->userspace_addr;

        if (kvm_arch_create_memslot(&new, npages))
            goto out_free;
    }

    /* Allocate page dirty bitmap if needed */
    if ((new.flags & KVM_MEM_LOG_DIRTY_PAGES) && !new.dirty_bitmap) {
        if (kvm_create_dirty_bitmap(&new) < 0)
            goto out_free;
    }
    /*如果用户层请求释放*/
    if ((change == KVM_MR_DELETE) || (change == KVM_MR_MOVE)) {
        r = -ENOMEM;
        slots = kmemdup(kvm->memslots, sizeof(struct kvm_memslots),
                GFP_KERNEL);
        if (!slots)
            goto out_free;
        /*先根据id定位具体的slot*/
        slot = id_to_memslot(slots, mem->slot);
        /*首先设置非法*/
        slot->flags |= KVM_MEMSLOT_INVALID;

        old_memslots = install_new_memslots(kvm, slots, NULL);

        /* slot was deleted or moved, clear iommu mapping */
        kvm_iommu_unmap_pages(kvm, &old);
        /* From this point no new shadow pages pointing to a deleted,
         * or moved, memslot will be created.
         *
         * validation of sp->gfn happens in:
         *     - gfn_to_hva (kvm_read_guest, gfn_to_pfn)
         *     - kvm_is_visible_gfn (mmu_check_roots)
         */
        kvm_arch_flush_shadow_memslot(kvm, slot);
        slots = old_memslots;
    }

    r = kvm_arch_prepare_memory_region(kvm, &new, mem, change);
    if (r)
        goto out_slots;

    r = -ENOMEM;
    /*
     * We can re-use the old_memslots from above, the only difference
     * from the currently installed memslots is the invalid flag.  This
     * will get overwritten by update_memslots anyway.
     */
    if (!slots) {
        slots = kmemdup(kvm->memslots, sizeof(struct kvm_memslots),
                GFP_KERNEL);
        if (!slots)
            goto out_free;
    }

    /*
     * IOMMU mapping:  New slots need to be mapped.  Old slots need to be
     * un-mapped and re-mapped if their base changes.  Since base change
     * unmapping is handled above with slot deletion, mapping alone is
     * needed here.  Anything else the iommu might care about for existing
     * slots (size changes, userspace addr changes and read-only flag
     * changes) is disallowed above, so any other attribute changes getting
     * here can be skipped.
     */
    if ((change == KVM_MR_CREATE) || (change == KVM_MR_MOVE)) {
        r = kvm_iommu_map_pages(kvm, &new);
        if (r)
            goto out_slots;
    }

    /* actual memory is freed via old in kvm_free_physmem_slot below */
    if (change == KVM_MR_DELETE) {
        new.dirty_bitmap = NULL;
        memset(&new.arch, 0, sizeof(new.arch));
    }
    old_memslots = install_new_memslots(kvm, slots, &new);
    kvm_arch_commit_memory_region(kvm, mem, &old, change);
    kvm_free_physmem_slot(&old, &new);
    kfree(old_memslots);
    return 0;
```

这里就根据change来做具体的设置了，如果 KVM_MR_CREATE，则设置new.用户空间地址为新的地址。如果new slot要求KVM_MEM_LOG_DIRTY_PAGES，但是new并没有分配dirty_bitmap，则为其分配。如果change为KVM_MR_DELETE或者KVM_MR_MOVE，这里主要由两个操作，一是设置对应slot标识为KVM_MEMSLOT_INVALID，更新页表。二是增加slots->generation，撤销iommu mapping。接下来对于私有映射的话(memslot->id >= KVM_USER_MEM_SLOTS)，如果是要创建，则需要手动建立映射。

接下来确保slots不为空，如果是KVM_MR_CREATE或者KVM_MR_MOVE，就需要重新建立映射，使用kvm_iommu_map_pages函数 ，而如果是KVM_MR_DELETE，就没必要为new设置dirty_bitmap，并对其arch字段的结构清零。最终都要执行操作install_new_memslots，不过当为delete操作时，new的memory size为0，那么看下该函数做了什么。

```cpp
static struct kvm_memslots *install_new_memslots(struct kvm *kvm,
        struct kvm_memslots *slots, struct kvm_memory_slot *new)
{
    struct kvm_memslots *old_memslots = kvm->memslots;

    update_memslots(slots, new, kvm->memslots->generation);
    rcu_assign_pointer(kvm->memslots, slots);
    kvm_synchronize_srcu_expedited(&kvm->srcu);
    kvm_arch_memslots_updated(kvm);
    return old_memslots;
}
```

这里核心操作在update_memslots里，如果是添加新的（create or move），那么new 的memory size肯定不为0，则根据new的id，在kvm维护的slot 数组中找到对应的slot，然后一次性吧new的内容赋值给old slot.如果页面数目不一样，则需要进行排序。如果是删除操作，new的memorysize 为0，这里就相当于把清空了一个slot。update之后就更改kvm->memslots，该指针是受RCU机制保护的，所以不能直接修改，需要先分配好，调用API修改。最后再刷新MMIO页表项。

```cpp
void update_memslots(struct kvm_memslots *slots, struct kvm_memory_slot *new,
             u64 last_generation)
{
    if (new) {
        int id = new->id;
        struct kvm_memory_slot *old = id_to_memslot(slots, id);
        unsigned long npages = old->npages;

        *old = *new;
            /*如果是删除操作，那么new.npages就是0*/
        if (new->npages != npages)
            sort_memslots(slots);
    }

    slots->generation = last_generation + 1;
}
```

# 参考

