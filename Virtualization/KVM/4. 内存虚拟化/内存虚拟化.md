
在虚拟机的创建与运行中`pc_init_pci`负责在**qemu中初始化虚拟机**，**内存初始化**也是在这里完成的，还是一步步从qemu说起，在vl.c的main函数中有`ram_size`参数，由qemu入参标识`QEMU_OPTION_m`设定，顾名思义就是**虚拟机内存的大小**，通过`machine->init`一步步传递给`pc_init1`函数。在这里分出了`above_4g_mem_size`和`below_4g_mem_size`，即**高低端内存**（也**不一定是32bit机器**..），然后开始初始化内存，即`pc_memory_init`，内存通过`memory_region_init_ram`下面的`qemu_ram_alloc`分配，使用`qemu_ram_alloc_from_ptr`。

插播qemu对内存条的模拟管理，是通过`RAMBlock`和`ram_list`管理的，**RAMBlock**就是**每次申请的内存池**，`ram_list`则是RAMBlock的**链表**，他们结构如下：

```cpp
typedef struct RAMBlock {
//对应宿主的内存地址
    uint8_t *host;
//block在ramlist中的偏移
    ram_addr_t offset;
//block长度
    ram_addr_t length;
    uint32_t flags;
//block名字
    char idstr[256];
    QLIST_ENTRY(RAMBlock) next;
#if defined(__linux__) && !defined(TARGET_S390X)
    int fd;
#endif
} RAMBlock;
 
typedef struct RAMList {
//看代码理解就是list的head，但是不知道为啥叫dirty...
    uint8_t *phys_dirty;
    QLIST_HEAD(ram, RAMBlock) blocks;
} RAMList;
```

下面再回到`qemu_ram_alloc_from_ptr`函数，使用`find_ram_offset`赋值给new block的offset，`find_ram_offset`具体工作模型已经在`KVM源代码分析2:虚拟机的创建与运行`中提到了，不赘述。然后是一串判断，在kvm_enabled的情况下使用`new_block->host = kvm_vmalloc(size)`，最终内存是`qemu_vmalloc`分配的，使用`qemu_memalign`干活。

