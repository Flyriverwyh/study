
在虚拟机的创建与运行中`pc_init_pci`负责在**qemu中初始化虚拟机**，**内存初始化**也是在这里完成的，还是一步步从qemu说起，在vl.c的main函数中有`ram_size`参数，由qemu入参标识`QEMU_OPTION_m`设定，顾名思义就是**虚拟机内存的大小**，通过`machine->init`一步步传递给`pc_init1`函数。在这里分出了`above_4g_mem_size`和`below_4g_mem_size`，即**高低端内存**（也**不一定是32bit机器**..），然后开始**初始化内存**，即`pc_memory_init`，内存通过`memory_region_init_ram`下面的`qemu_ram_alloc`分配，使用`qemu_ram_alloc_from_ptr`。

插播qemu对内存条的模拟管理，是通过`RAMBlock`和`ram_list`管理的，**RAMBlock**就是**每次申请的内存池**，`ram_list`则是RAMBlock的**链表**，他们结构如下：

```cpp
typedef struct RAMBlock {
//对应宿主的内存地址
    uint8_t *host;
//block在ramlist中的偏移
    ram_addr_t offset;
//block长度
    ram_addr_t length;
    uint32_t flags;
//block名字
    char idstr[256];
    QLIST_ENTRY(RAMBlock) next;
#if defined(__linux__) && !defined(TARGET_S390X)
    int fd;
#endif
} RAMBlock;
 
typedef struct RAMList {
//看代码理解就是list的head，但是不知道为啥叫dirty...
    uint8_t *phys_dirty;
    QLIST_HEAD(ram, RAMBlock) blocks;
} RAMList;
```

下面再回到`qemu_ram_alloc_from_ptr`函数，使用`find_ram_offset`赋值给new block的offset，`find_ram_offset`具体工作模型已经在`KVM源代码分析2:虚拟机的创建与运行`中提到了，不赘述。然后是一串判断，在kvm_enabled的情况下使用`new_block->host = kvm_vmalloc(size)`，最终内存是`qemu_vmalloc`分配的，使用`qemu_memalign`干活。

```cpp
void *qemu_memalign(size_t alignment, size_t size)
{
    void *ptr;
//使用posix进行内存针对页大小对齐
#if defined(_POSIX_C_SOURCE) && !defined(__sun__)
    int ret;
    ret = posix_memalign(&ptr, alignment, size);
    if (ret != 0) {
        fprintf(stderr, "Failed to allocate %zu B: %sn",
                size, strerror(ret));
        abort();
    }
#elif defined(CONFIG_BSD)
    ptr = qemu_oom_check(valloc(size));
#else
//所谓检查oom就是看memalign对应malloc申请内存是否成功
    ptr = qemu_oom_check(memalign(alignment, size));
#endif
    trace_qemu_memalign(alignment, size, ptr);
    return ptr;
}
```

以上`qemu_vmalloc`进行内存申请就结束了。在`qemu_ram_alloc_from_ptr`函数末尾则是将**block添加到链表**，realloc整个ramlist，用memset初始化整个ramblock，madvise对内存使用限定。

然后一层层的退回到`pc_memory_init`函数。

此时`pc.ram`已经分配完成，`ram_addr`已经拿到了分配的内存地址，MemoryRegion ram初始化完成。下面则是对已有的ram进行分段，即`ram-below-4g`和`ram-above-4g`，也就是高端内存和低端内存。用memory_region_init_alias初始化子MemoryRegion，然后将memory_region_add_subregion添加关联起来，memory_region_add_subregion具体细节“KVM源码分析2”中已经说了，参考对照着看吧，中间很多映射代码过程也只是qemu遗留的软件实现，没看到具体存在的意义，直接看到kvm_set_user_memory_region函数，内核真正需要kvm_vm_ioctl传递过去的参数是什么， struct kvm_userspace_memory_region mem而已，也就是