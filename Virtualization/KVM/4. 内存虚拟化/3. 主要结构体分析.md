

# 1. kvm_memslots: 虚拟机所有slot信息

```cpp
// include/linux/kvm_host.h
struct kvm {
        struct kvm_memslots __rcu *memslots[KVM_ADDRESS_SPACE_NUM];
```

一个`struct kvm`代表一个虚拟机, memslots是该虚拟机所有内存条, 注意最大`KVM_ADDRESS_SPACE_NUM`(这里是1), 用于将**GPA转换为HVA**. 

```cpp
/*
 * Note:
 * memslots are not sorted by id anymore, please use id_to_memslot()
 * to get the memslot by its id.
 */
struct kvm_memslots {
        u64 generation;
        /* The mapping table from slot id to the index in memslots[]. */
        short id_to_index[KVM_MEM_SLOTS_NUM];
        atomic_t lru_slot;
        int used_slots;
        struct kvm_memory_slot memslots[];
};
```

kvm_memslots结构体是`kvm_mem_slot`的封装，其中包含一个`kvm_mem_slot`的数组，对应于**该虚拟机**使用的**所有内存区域(slot**)。以**数组形式**存储这些**slot的地址信息**。

`kvm_mem_slot`是kvm内存管理相关主要数据结构，用来表示**虚拟机GPA**和**主机HVA**之间的**映射关系**，一个`kvm_mem_slot`表示一段**内存区域(slot)的映射关系**.

获取某一个`kvm_memory_slot`, 通过`id_to_memslot(struct kvm_memslots *slots, int id)`实现, 下面有具体代码.

# 2. kvm_mem_slot 结构体: 一个代表一段空间虚拟机GPA到主机HVA的映射关系

由于**GPA不能直接用于物理 MMU 进行寻址！！！**，所以需要**将GPA转换为HVA**，kvm中利用 `kvm_memory_slot` 数据结构来记录**每一个地址区间**(**Guest中的物理地址区间**)中**GPA与HVA**的**映射关系**.

```cpp
struct kvm_rmap_head {
        unsigned long val;
};

struct kvm_lpage_info {
        int disallow_lpage;
};

struct kvm_arch_memory_slot {
        struct kvm_rmap_head *rmap[KVM_NR_PAGE_SIZES];
        struct kvm_lpage_info *lpage_info[KVM_NR_PAGE_SIZES - 1];
        unsigned short *gfn_track[KVM_PAGE_TRACK_MAX];
};

struct kvm_memory_slot {
        // 虚拟机物理地址(即GPA)对应的页框号
        gfn_t base_gfn;
        // 当前slot中包含的page数目
        unsigned long npages;
        // 一个slot由许多客户机虚拟页面构成, 通过这个标识每个页是否可用
        unsigned long *dirty_bitmap;
        // 架构相关部分
        struct kvm_arch_memory_slot arch;
        /*
         * GPA对应的host虚拟地址(HVA), 由于虚拟机都运行在qemu的地址空间中
         * 而qemu是用户态程序, 所以通常使用root-module下的用户地址空间.
         */
        unsigned long userspace_addr;
        u32 flags;
        short id;
};
```

至于`kvm_userspace_memory_region`可以看qemu部分
