
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 32 位字段值](#1-32-位字段值)
- [2. primary processor-based VM-execution control](#2-primary-processor-based-vm-execution-control)
  - [2.1. vmcs_config 全局变量的构建](#21-vmcs_config-全局变量的构建)
  - [2.2. 模块初始化阶段](#22-模块初始化阶段)
  - [2.3. vcpu创建阶段](#23-vcpu创建阶段)
  - [2.5. interrupt-window exiting: bit 2](#25-interrupt-window-exiting-bit-2)
  - [2.6. Use TSC offsetting: bit 3](#26-use-tsc-offsetting-bit-3)
  - [2.7. HLT exiting: bit 7](#27-hlt-exiting-bit-7)
  - [2.8. INVLPG exiting: bit 9](#28-invlpg-exiting-bit-9)
  - [2.9. MWAIT exiting: bit 10](#29-mwait-exiting-bit-10)
  - [2.10. RDPMC exiting: bit 11](#210-rdpmc-exiting-bit-11)
  - [2.11. RDTSC exiting: bit 12](#211-rdtsc-exiting-bit-12)
  - [2.12. CR3-load exiting: bit 15](#212-cr3-load-exiting-bit-15)
  - [2.13. CR3-store exiting: bit 16](#213-cr3-store-exiting-bit-16)
  - [2.14. CR8-load exiting: bit 19](#214-cr8-load-exiting-bit-19)
  - [2.15. CR8-store exiting: bit 20](#215-cr8-store-exiting-bit-20)
  - [2.16. Use TPR shadow: bit 21](#216-use-tpr-shadow-bit-21)
  - [2.17. NMI-window exiting: bit 22](#217-nmi-window-exiting-bit-22)
  - [2.18. MOV-DR exiting: bit 23](#218-mov-dr-exiting-bit-23)
  - [2.19. Unconditional I/O exiting: bit 24](#219-unconditional-io-exiting-bit-24)
  - [2.20. Use I/O bitmap: bit 25](#220-use-io-bitmap-bit-25)
  - [2.21. Monitor trap flag: bit 27](#221-monitor-trap-flag-bit-27)
  - [2.22. Use MSR bitmap: bit 28](#222-use-msr-bitmap-bit-28)
  - [2.23. MONITOR exiting: bit 29](#223-monitor-exiting-bit-29)
  - [2.24. PAUSE exiting: bit 30](#224-pause-exiting-bit-30)
  - [2.25. Activate secondary controls: bit 31](#225-activate-secondary-controls-bit-31)
- [3. secondary processor-based VM-execution control](#3-secondary-processor-based-vm-execution-control)
  - [3.1. 模块初始化阶段](#31-模块初始化阶段)
  - [3.2. vcpu创建阶段](#32-vcpu创建阶段)
  - [3.3. 更新apicv时候](#33-更新apicv时候)

<!-- /code_chunk_output -->

# 1. 32 位字段值

```cpp
enum vmcs_field {
    CPU_BASED_VM_EXEC_CONTROL       = 0x00004002,
    SECONDARY_VM_EXEC_CONTROL       = 0x0000401e,
}
```

32 位字段值, 所以都使用 `vmcs_write32/read32()`, 见`3.3.2`

# 2. primary processor-based VM-execution control

## 2.1. vmcs_config 全局变量的构建

KVM使用了两个**全局变量** `vmcs_config` 和 `vmx_capability`, 用来配置和表示**VMX的能力**

```cpp
// arch/x86/kvm/vmx/capabilities.h
struct vmcs_config {
    ......
    u32 pin_based_exec_ctrl;
    u32 cpu_based_exec_ctrl;
    u32 cpu_based_2nd_exec_ctrl;
    ......
};

// arch/x86/kvm/vmx/vmx.c
struct vmcs_config vmcs_config;
```

## 2.2. 模块初始化阶段

在模块初始化时候

```cpp
vmx_init()                               // 模块初始化入口
 ├─ kvm_init(KVM_GET_API_VERSION)        // 初始化KVM框架

 |   ├─ kvm_arch_hardware_setup()         // 
 |   |   ├─ kvm_x86_ops->hardware_setup() // 硬件相关的构建
 |   |   |  ├─ setup_vmcs_config(&vmcs_config, &vmx_capability) // 设置了全局变量 vmcs_config 和 vmx_capability
 |   ├─ smp_call_function_single()       // 对每个online cpu进行兼容性检查, 调用 check_processor_compat()
```

```cpp
// arch/x86/include/asm/msr-index.h
#define MSR_IA32_VMX_PROCBASED_CTLS     0x00000482

// arch/x86/kvm/vmx/vmx.c
static __init int setup_vmcs_config(struct vmcs_config *vmcs_conf,
                                    struct vmx_capability *vmx_cap)
{
        u32 min, opt, min2, opt2;
        u32 _cpu_based_exec_control = 0;

        // 初始化全局变量 vmcs_conf 全部为 0
        memset(vmcs_conf, 0, sizeof(*vmcs_conf));
        // 下面的 MSR_IA32_VMX_PROCBASED_CTLS 必须支持的能力
        min = CPU_BASED_HLT_EXITING |
#ifdef CONFIG_X86_64
              CPU_BASED_CR8_LOAD_EXITING |
              CPU_BASED_CR8_STORE_EXITING |
#endif
              CPU_BASED_CR3_LOAD_EXITING |
              CPU_BASED_CR3_STORE_EXITING |
              CPU_BASED_UNCOND_IO_EXITING |
              CPU_BASED_MOV_DR_EXITING |
              CPU_BASED_USE_TSC_OFFSETTING |
              CPU_BASED_MWAIT_EXITING |
              CPU_BASED_MONITOR_EXITING |
              CPU_BASED_INVLPG_EXITING |
              CPU_BASED_RDPMC_EXITING;
        // 可选的能力
        opt = CPU_BASED_TPR_SHADOW |
              CPU_BASED_USE_MSR_BITMAPS |
              CPU_BASED_ACTIVATE_SECONDARY_CONTROLS;
        // 根据 IA32_VMX_PROCBASED_CTLS msr 寄存器的值来决定 primary 的值
        // 调整结果存放到 _cpu_based_exec_control 中
        // min 是 CTLS 必须支持的最小合集; opt 是可选功能
        if (adjust_vmx_controls(min, opt, MSR_IA32_VMX_PROCBASED_CTLS,
                                &_cpu_based_exec_control) < 0)
                return -EIO;
#ifdef CONFIG_X86_64
        // 如果开启了 TPR shadow, CR8 这两个应该清位, 避免 CR8 相关的 VM-exit
        if ((_cpu_based_exec_control & CPU_BASED_TPR_SHADOW))
                _cpu_based_exec_control &= ~CPU_BASED_CR8_LOAD_EXITING &
                                           ~CPU_BASED_CR8_STORE_EXITING;
#endif
        ......
#ifndef CONFIG_X86_64
        // 如果virtualize APIC accesses 没有启用, 那就清理 TPR shadow
        if (!(_cpu_based_2nd_exec_control &
                                SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES))
                _cpu_based_exec_control &= ~CPU_BASED_TPR_SHADOW;
#endif
        .....
        // 如果 EPT 启用, 清理掉 CR3 相关位和 INVLPG 指令的位
        if (_cpu_based_2nd_exec_control & SECONDARY_EXEC_ENABLE_EPT) {
                /* CR3 accesses and invlpg don't need to cause VM Exits when EPT
                   enabled */
                _cpu_based_exec_control &= ~(CPU_BASED_CR3_LOAD_EXITING |
                                             CPU_BASED_CR3_STORE_EXITING |
                                             CPU_BASED_INVLPG_EXITING);
        }
        ......
        vmcs_conf->cpu_based_exec_ctrl = _cpu_based_exec_control;
        .....
        return 0;
}
```

先将所有支持的功能设置为初始值, 然后根据条件支持与否再清理.

## 2.3. vcpu创建阶段

```cpp
kvm_vm_ioctl() // kvm ioctl vm指令入口
 ├─ kvm_vm_ioctl_create_vcpu() // 为虚拟机创建VCPU的ioctl调用的入口函数
 |   ├─ kvm_arch_vcpu_create() // 初始化kvm_vcpu_arch结构体, 架构相关 
 |   |   ├─ static_call(kvm_x86_vcpu_create)(vcpu); //对于intel x86来说, 最终调用 vmx_create_vcpu
 |   |   |   ├─ init_vmcs(vmx); // 初始化vmcs, 而guest-state在vmx_vcpu_reset()
 |   |   |   |   ├─ exec_controls_set(vmx, vmx_exec_control(vmx)); // 设置 pin-based VM-execution control 字段
 |   ├─ km_arch_vcpu_postcreate() // 架构相关的善后工作, 比如再次调用vcpu_load, 以及tsc相关处理
 |   |   ├─vcpu_load(); // 加载vcpu信息<参数为kvm_vcpu>, struct vmx_vcpu(vcpu的一个运行环境)加载
 |   |   |   ├─ kvm_arch_vcpu_load(vcpu, cpu)
 |   |   |   |   ├─ static_call(kvm_x86_vcpu_load)(vcpu, cpu); // 实际调用vmx.c的 vmx_vcpu_load()
```

在加载 `current-VMCS` 之前, 会对 VMCS 相应字段进行设置

```cpp
static void init_vmcs(struct vcpu_vmx *vmx)
{
        // 写入 vmcs
        exec_controls_set(vmx, vmx_exec_control(vmx));
}
```

这里先通过 `vmx_exec_control()` 对 `primary processor-based VM-execution control` 字段进行自定义设置

```cpp
static bool __read_mostly enable_vnmi = 1;
module_param_named(vnmi, enable_vnmi, bool, S_IRUGO);

static bool __read_mostly enable_preemption_timer = 1;
#ifdef CONFIG_X86_64
module_param_named(preemption_timer, enable_preemption_timer, bool, S_IRUGO);
#endif

u32 vmx_exec_control(struct vcpu_vmx *vmx)
{
        // 全局变量
        u32 exec_control = vmcs_config.cpu_based_exec_ctrl;
        // 
        if (vmx->vcpu.arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)
                exec_control &= ~CPU_BASED_MOV_DR_EXITING;

        if (!cpu_need_tpr_shadow(&vmx->vcpu)) {
                exec_control &= ~CPU_BASED_TPR_SHADOW;
#ifdef CONFIG_X86_64
                exec_control |= CPU_BASED_CR8_STORE_EXITING |
                                CPU_BASED_CR8_LOAD_EXITING;
#endif
        }
        if (!enable_ept)
                exec_control |= CPU_BASED_CR3_STORE_EXITING |
                                CPU_BASED_CR3_LOAD_EXITING  |
                                CPU_BASED_INVLPG_EXITING;
        if (kvm_mwait_in_guest(vmx->vcpu.kvm))
                exec_control &= ~(CPU_BASED_MWAIT_EXITING |
                                CPU_BASED_MONITOR_EXITING);
        // hlt 指令透传给虚拟机
        if (kvm_hlt_in_guest(vmx->vcpu.kvm))
                exec_control &= ~CPU_BASED_HLT_EXITING;
        return exec_control;
}
u32 vmx_pin_based_exec_ctrl(struct vcpu_vmx *vmx)
{
        u32 pin_based_exec_ctrl = vmcs_config.pin_based_exec_ctrl;
        // apicv 没有开启, 清掉 posted-interrupt
        if (!kvm_vcpu_apicv_active(&vmx->vcpu))
                pin_based_exec_ctrl &= ~PIN_BASED_POSTED_INTR;
        
        // 使用virtual NMIs模块参数关闭的话, 清掉这个feature
        if (!enable_vnmi)
                pin_based_exec_ctrl &= ~PIN_BASED_VIRTUAL_NMIS;

        // 使用模块参数关闭的话, 清掉这个feature
        if (!enable_preemption_timer)
                pin_based_exec_ctrl &= ~PIN_BASED_VMX_PREEMPTION_TIMER;

        return pin_based_exec_ctrl;
}
```

```cpp
static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)
{
    return vcpu->arch.apic && vcpu->arch.apicv_active;
}
```

`kvm_vcpu_apicv_active` 没有开启, 清掉 `posted-interrupt`

最后, 会通过 `pin_controls_set()` 将 构建的`pin-based VM-execution control` 字段写入 VMCS. 定义如下:

```cpp
// arch/x86/kvm/vmx/vmx.h
#define BUILD_CONTROLS_SHADOW(lname, uname)                 \
static inline void lname##_controls_set(struct vcpu_vmx *vmx, u32 val)      \
{                                       \
    if (vmx->loaded_vmcs->controls_shadow.lname != val) {           \
        vmcs_write32(uname, val);                   \
        vmx->loaded_vmcs->controls_shadow.lname = val;          \
    }                                   \
}                                       \
static inline u32 lname##_controls_get(struct vcpu_vmx *vmx)            \
{                                       \
    return vmx->loaded_vmcs->controls_shadow.lname;             \
}                                       \
static inline void lname##_controls_setbit(struct vcpu_vmx *vmx, u32 val)   \
{                                       \
    lname##_controls_set(vmx, lname##_controls_get(vmx) | val);     \
}                                       \
static inline void lname##_controls_clearbit(struct vcpu_vmx *vmx, u32 val) \
{                                       \
    lname##_controls_set(vmx, lname##_controls_get(vmx) & ~val);        \
}
BUILD_CONTROLS_SHADOW(vm_entry, VM_ENTRY_CONTROLS)
BUILD_CONTROLS_SHADOW(vm_exit, VM_EXIT_CONTROLS)
BUILD_CONTROLS_SHADOW(pin, PIN_BASED_VM_EXEC_CONTROL)
BUILD_CONTROLS_SHADOW(exec, CPU_BASED_VM_EXEC_CONTROL)
BUILD_CONTROLS_SHADOW(secondary_exec, SECONDARY_VM_EXEC_CONTROL)
```

## 2.5. interrupt-window exiting: bit 2

初始没有开启这个功能

## 2.6. Use TSC offsetting: bit 3

在**系统初始化**阶段, **通过 min 确保**这个功能在CPU层面**一定要支持**(但是**不意味着肯定会使用**), 同时会**默认设置开启**; 结果保存在全局变量 `vmcs_config`.

后续也没有清理这个 bit

最后在**创建vcpu**阶段, **初始化vmcs**时会通过 `vmcs_config` 读取并将其写入 VMCS 相应字段.

所以该功能是**肯定打开**了

## 2.7. HLT exiting: bit 7

在**系统初始化**阶段, **通过 min 确保**这个功能在CPU层面**一定要支持**(但是**不意味着肯定会使用**), 同时会**默认设置开启**; 结果保存在全局变量 `vmcs_config`.

最后在**创建vcpu**阶段, **初始化vmcs**时会通过读取全局变量 `vmcs_config`, 然后会判断**hlt指令是否透传给虚拟机**, 如果透传则清除这个字段, 最后写入 VMCS 相应字段.

## 2.8. INVLPG exiting: bit 9

在**系统初始化**阶段, **通过 min 确保**这个功能在CPU层面**一定要支持**(但是**不意味着肯定会使用**), 同时会**默认设置开启**; 

如果 `secondary processor-based VM-execution` 字段的“`ENABLE EPT`”位开启了, invlpg 指令便**不**需要 VM-exit, 所以清除这个位.

结果保存在全局变量 `vmcs_config`.

最后在**创建vcpu**阶段, **初始化vmcs**时会读取全局变量 `vmcs_config`; 而用户通过内核参数打开了 ept 则清除这个字段, 最后写入 VMCS 相应字段.

## 2.9. MWAIT exiting: bit 10

在**系统初始化**阶段, **通过 min 确保**这个功能在CPU层面**一定要支持**(但是**不意味着肯定会使用**), 同时会**默认设置开启**; 

如果 `secondary processor-based VM-execution` 字段的“`ENABLE EPT`”位开启了, invlpg 指令便**不**需要 VM-exit, 所以清除这个位.

最后在**创建vcpu**阶段, **初始化vmcs**时会通过读取全局变量 `vmcs_config`, 然后判断**mwait指令是否透传给虚拟机**, 如果透传则清除这个字段, 最后写入 VMCS 相应字段.

## 2.10. RDPMC exiting: bit 11

在**系统初始化**阶段, **通过 min 确保**这个功能在CPU层面**一定要支持**(但是**不意味着肯定会使用**), 同时会**默认设置开启**; 结果保存在全局变量 `vmcs_config`.

后续也没有清理这个 bit

最后在**创建vcpu**阶段, **初始化vmcs**时会通过 `vmcs_config` 读取并将其写入 VMCS 相应字段.

而后续**更新apicv时**候对 VMCS 的重新写入也**不会有任何更改**.

所以该功能是**肯定打开**了

## 2.11. RDTSC exiting: bit 12

该功能没有开启, 所以虚拟机调用 rdtsc 不会 VM-exit(相当于透传了这个指令) 

## 2.12. CR3-load exiting: bit 15

在**系统初始化**阶段, **通过 min 确保**这个功能在CPU层面**一定要支持**(但是**不意味着肯定会使用**), 同时会**默认设置开启**; 结果保存在全局变量 `vmcs_config`.

如果 `secondary processor-based VM-execution` 字段的“`ENABLE EPT`”位开启了, 虚拟机对于 CR3 的**读写**便**不**需要 VM-exit, 所以清除这个位.

最后在**创建vcpu**阶段, **初始化vmcs**时会读取全局变量 `vmcs_config`; 而用户通过内核参数打开了 ept 则清除这个字段, 最后写入 VMCS 相应字段.

而后续在处理 写CR0 的 VM-exit 时, 可能也会清理/设置这个位.

## 2.13. CR3-store exiting: bit 16

同上

## 2.14. CR8-load exiting: bit 19

只有 64 位模式可用.

在**系统初始化**阶段, **通过 min 确保**这个功能在CPU层面**一定要支持**(但是**不意味着肯定会使用**), 同时会**默认设置开启**; 

CR8寄存器作为TPR（Task Priority Register）的编程接口, 所以如果 TRP shadow 打开的时候, 这个就不可用, 所以便会清除这个位.

结果保存在全局变量 `vmcs_config`.

最后在**创建vcpu**阶段, **初始化vmcs**时会读取全局变量 `vmcs_config`; 而如果cpu不需要 TPR shadow 的话, 那就会清除 `TPR shadow` 位, 同时启用 `CR8 load/store` 位

## 2.15. CR8-store exiting: bit 20

同上面

## 2.16. Use TPR shadow: bit 21

在**系统初始化**阶段, 作为**可选功能**, 如果CPU支持那就**默认开启**; 结果保存在全局变量 `vmcs_config`.




## 2.17. NMI-window exiting: bit 22

## 2.18. MOV-DR exiting: bit 23

## 2.19. Unconditional I/O exiting: bit 24

在**系统初始化**阶段, **通过 min 确保**这个功能在CPU层面**一定要支持**(但是**不意味着肯定会使用**), 同时会**默认设置开启**; 结果保存在全局变量 `vmcs_config`.

后续也没有清理这个 bit

最后在**创建vcpu**阶段, **初始化vmcs**时会通过 `vmcs_config` 读取并将其写入 VMCS 相应字段.

所以该功能是**肯定打开**了

## 2.20. Use I/O bitmap: bit 25

该功能没有开启, 而`Unconditional I/O exiting`置位了, 所以 **IN/OUT**（包括 **INS/OUTS** 类）指令都将产生 `VM-exit`.

## 2.21. Monitor trap flag: bit 27

## 2.22. Use MSR bitmap: bit 28

在**系统初始化**阶段, 作为**可选功能**, 如果CPU支持那就**默认开启**; 结果保存在全局变量 `vmcs_config`.

后续也没有处理过这个 bit

最后在**创建vcpu**阶段, **初始化vmcs**时会通过 `vmcs_config` 读取并将其写入 VMCS 相应字段.

## 2.23. MONITOR exiting: bit 29

## 2.24. PAUSE exiting: bit 30

## 2.25. Activate secondary controls: bit 31

在**系统初始化**阶段, 作为**可选功能**, 如果CPU支持那就**默认开启**; 结果保存在全局变量 `vmcs_config`.

后续也没有处理过这个 bit

最后在**创建vcpu**阶段, **初始化vmcs**时会通过 `vmcs_config` 读取并将其写入 VMCS 相应字段.

# 3. secondary processor-based VM-execution control



## 3.1. 模块初始化阶段

在模块初始化时候

```cpp
// arch/x86/kvm/vmx/vmx.c
// 全局变量
struct vmcs_config vmcs_config;
struct vmx_capability vmx_capability;

hardware_setup();
 ├─setup_vmcs_config(&vmcs_config, &vmx_capability);
```

```cpp
// arch/x86/include/asm/msr-index.h
#define MSR_IA32_VMX_PROCBASED_CTLS     0x00000482

// arch/x86/kvm/vmx/vmx.c
static __init int setup_vmcs_config(struct vmcs_config *vmcs_conf,
                                    struct vmx_capability *vmx_cap)
{
        u32 vmx_msr_low, vmx_msr_high;
        u32 min, opt, min2, opt2;
        u32 _pin_based_exec_control = 0;
        u32 _cpu_based_exec_control = 0;
        u32 _cpu_based_2nd_exec_control = 0;
        u32 _vmexit_control = 0;
        u32 _vmentry_control = 0;
        // 初始化全局变量 vmcs_conf 全部为 0
        memset(vmcs_conf, 0, sizeof(*vmcs_conf));
        ......
        // 只有 primary 中 secondary 位可用时
        if (_cpu_based_exec_control & CPU_BASED_ACTIVATE_SECONDARY_CONTROLS) {
                // secondary control 没有必须支持的能力
                min2 = 0;
                // 可选功能, 如果cpu支持那就默认开启
                opt2 = SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |
                        SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |
                        SECONDARY_EXEC_WBINVD_EXITING |
                        SECONDARY_EXEC_ENABLE_VPID |
                        SECONDARY_EXEC_ENABLE_EPT |
                        SECONDARY_EXEC_UNRESTRICTED_GUEST |
                        SECONDARY_EXEC_PAUSE_LOOP_EXITING |
                        SECONDARY_EXEC_DESC |
                        SECONDARY_EXEC_ENABLE_RDTSCP |
                        SECONDARY_EXEC_ENABLE_INVPCID |
                        SECONDARY_EXEC_APIC_REGISTER_VIRT |
                        SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |
                        SECONDARY_EXEC_SHADOW_VMCS |
                        SECONDARY_EXEC_XSAVES |
                        SECONDARY_EXEC_RDSEED_EXITING |
                        SECONDARY_EXEC_RDRAND_EXITING |
                        SECONDARY_EXEC_ENABLE_PML |
                        SECONDARY_EXEC_TSC_SCALING |
                        SECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE |
                        SECONDARY_EXEC_PT_USE_GPA |
                        SECONDARY_EXEC_PT_CONCEAL_VMX |
                        SECONDARY_EXEC_ENABLE_VMFUNC |
                        SECONDARY_EXEC_BUS_LOCK_DETECTION;
                if (cpu_has_sgx())
                        opt2 |= SECONDARY_EXEC_ENCLS_EXITING;
                if (adjust_vmx_controls(min2, opt2,
                                        MSR_IA32_VMX_PROCBASED_CTLS2,
                                        &_cpu_based_2nd_exec_control) < 0)
                        return -EIO;
        }
        ......
        if (!(_cpu_based_exec_control & CPU_BASED_TPR_SHADOW))
                _cpu_based_2nd_exec_control &= ~(
                                SECONDARY_EXEC_APIC_REGISTER_VIRT |
                                SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |
                                SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);
        ......
        vmcs_conf->cpu_based_2nd_exec_ctrl = _cpu_based_2nd_exec_control;
        .....
        return 0;
}
```

先将所有支持的功能设置为初始值, 然后根据条件支持与否再清理.

## 3.2. vcpu创建阶段

```cpp
kvm_vm_ioctl() // kvm ioctl vm指令入口
 ├─ kvm_vm_ioctl_create_vcpu() // 为虚拟机创建VCPU的ioctl调用的入口函数
 |   ├─ kvm_arch_vcpu_create() // 初始化kvm_vcpu_arch结构体, 架构相关 
 |   |   ├─ static_call(kvm_x86_vcpu_create)(vcpu); //对于intel x86来说, 最终调用 vmx_create_vcpu
 |   |   |   ├─ init_vmcs(vmx); // 初始化vmcs, 而guest-state在vmx_vcpu_reset()
 |   |   |   |   ├─ exec_controls_set(vmx, vmx_exec_control(vmx)); // 设置 pin-based VM-execution control 字段
 |   ├─ km_arch_vcpu_postcreate() // 架构相关的善后工作, 比如再次调用vcpu_load, 以及tsc相关处理
 |   |   ├─vcpu_load(); // 加载vcpu信息<参数为kvm_vcpu>, struct vmx_vcpu(vcpu的一个运行环境)加载
 |   |   |   ├─ kvm_arch_vcpu_load(vcpu, cpu)
 |   |   |   |   ├─ static_call(kvm_x86_vcpu_load)(vcpu, cpu); // 实际调用vmx.c的 vmx_vcpu_load()
```

在加载 `current-VMCS` 之前, 会对 VMCS 相应字段进行设置

```cpp
static void init_vmcs(struct vcpu_vmx *vmx)
{
        // 写入 vmcs
        exec_controls_set(vmx, vmx_exec_control(vmx));
}
```

这里先通过 `vmx_exec_control()` 对 `primary processor-based VM-execution control` 字段进行自定义设置

```cpp
static bool __read_mostly enable_vnmi = 1;
module_param_named(vnmi, enable_vnmi, bool, S_IRUGO);

static bool __read_mostly enable_preemption_timer = 1;
#ifdef CONFIG_X86_64
module_param_named(preemption_timer, enable_preemption_timer, bool, S_IRUGO);
#endif

u32 vmx_exec_control(struct vcpu_vmx *vmx)
{
        // 全局变量
        u32 exec_control = vmcs_config.cpu_based_exec_ctrl;
        // 
        if (vmx->vcpu.arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)
                exec_control &= ~CPU_BASED_MOV_DR_EXITING;

        if (!cpu_need_tpr_shadow(&vmx->vcpu)) {
                exec_control &= ~CPU_BASED_TPR_SHADOW;
#ifdef CONFIG_X86_64
                exec_control |= CPU_BASED_CR8_STORE_EXITING |
                                CPU_BASED_CR8_LOAD_EXITING;
#endif
        }
        if (!enable_ept)
                exec_control |= CPU_BASED_CR3_STORE_EXITING |
                                CPU_BASED_CR3_LOAD_EXITING  |
                                CPU_BASED_INVLPG_EXITING;
        if (kvm_mwait_in_guest(vmx->vcpu.kvm))
                exec_control &= ~(CPU_BASED_MWAIT_EXITING |
                                CPU_BASED_MONITOR_EXITING);
        if (kvm_hlt_in_guest(vmx->vcpu.kvm))
                exec_control &= ~CPU_BASED_HLT_EXITING;
        return exec_control;
}
u32 vmx_pin_based_exec_ctrl(struct vcpu_vmx *vmx)
{
        u32 pin_based_exec_ctrl = vmcs_config.pin_based_exec_ctrl;
        // apicv 没有开启, 清掉 posted-interrupt
        if (!kvm_vcpu_apicv_active(&vmx->vcpu))
                pin_based_exec_ctrl &= ~PIN_BASED_POSTED_INTR;
        
        // 使用virtual NMIs模块参数关闭的话, 清掉这个feature
        if (!enable_vnmi)
                pin_based_exec_ctrl &= ~PIN_BASED_VIRTUAL_NMIS;

        // 使用模块参数关闭的话, 清掉这个feature
        if (!enable_preemption_timer)
                pin_based_exec_ctrl &= ~PIN_BASED_VMX_PREEMPTION_TIMER;

        return pin_based_exec_ctrl;
}
```

```cpp
static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)
{
    return vcpu->arch.apic && vcpu->arch.apicv_active;
}
```

`kvm_vcpu_apicv_active` 没有开启, 清掉 `posted-interrupt`

最后, 会通过 `pin_controls_set()` 将 构建的`pin-based VM-execution control` 字段写入 VMCS. 定义如下:

```cpp
// arch/x86/kvm/vmx/vmx.h
#define BUILD_CONTROLS_SHADOW(lname, uname)                 \
static inline void lname##_controls_set(struct vcpu_vmx *vmx, u32 val)      \
{                                       \
    if (vmx->loaded_vmcs->controls_shadow.lname != val) {           \
        vmcs_write32(uname, val);                   \
        vmx->loaded_vmcs->controls_shadow.lname = val;          \
    }                                   \
}                                       \
static inline u32 lname##_controls_get(struct vcpu_vmx *vmx)            \
{                                       \
    return vmx->loaded_vmcs->controls_shadow.lname;             \
}                                       \
static inline void lname##_controls_setbit(struct vcpu_vmx *vmx, u32 val)   \
{                                       \
    lname##_controls_set(vmx, lname##_controls_get(vmx) | val);     \
}                                       \
static inline void lname##_controls_clearbit(struct vcpu_vmx *vmx, u32 val) \
{                                       \
    lname##_controls_set(vmx, lname##_controls_get(vmx) & ~val);        \
}
BUILD_CONTROLS_SHADOW(vm_entry, VM_ENTRY_CONTROLS)
BUILD_CONTROLS_SHADOW(vm_exit, VM_EXIT_CONTROLS)
BUILD_CONTROLS_SHADOW(pin, PIN_BASED_VM_EXEC_CONTROL)
BUILD_CONTROLS_SHADOW(exec, CPU_BASED_VM_EXEC_CONTROL)
BUILD_CONTROLS_SHADOW(secondary_exec, SECONDARY_VM_EXEC_CONTROL)
```

## 3.3. 更新apicv时候

* `svm_vcpu_unblocking()`
* `kvm_request_apicv_update`
* `vcpu_enter_guest`

会更新下

```cpp
static void vmx_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu)
{
        struct vcpu_vmx *vmx = to_vmx(vcpu);

        pin_controls_set(vmx, vmx_pin_based_exec_ctrl(vmx));
        if (cpu_has_secondary_exec_ctrls()) {
                if (kvm_vcpu_apicv_active(vcpu))
                        secondary_exec_controls_setbit(vmx,
                                      SECONDARY_EXEC_APIC_REGISTER_VIRT |
                                      SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);
                else
                        secondary_exec_controls_clearbit(vmx,
                                        SECONDARY_EXEC_APIC_REGISTER_VIRT |
                                        SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);
        }

        if (cpu_has_vmx_msr_bitmap())
                vmx_update_msr_bitmap(vcpu);
}
```



```cpp
// arch/x86/include/asm/msr-index.h
#define MSR_IA32_VMX_PROCBASED_CTLS2    0x0000048b

// arch/x86/kvm/vmx/vmx.c
static __init int setup_vmcs_config(struct vmcs_config *vmcs_conf,
                                    struct vmx_capability *vmx_cap)
{
        u32 vmx_msr_low, vmx_msr_high;
        u32 min, opt, min2, opt2;
        u32 _pin_based_exec_control = 0;
        u32 _cpu_based_exec_control = 0;
        u32 _cpu_based_2nd_exec_control = 0;
        u32 _vmexit_control = 0;
        u32 _vmentry_control = 0;
        // 初始化全局变量 vmcs_conf 全部为 0
        memset(vmcs_conf, 0, sizeof(*vmcs_conf));
        // 下面的 MSR_IA32_VMX_PROCBASED_CTLS 必须支持的能力
        min = CPU_BASED_HLT_EXITING |
#ifdef CONFIG_X86_64
              CPU_BASED_CR8_LOAD_EXITING |
              CPU_BASED_CR8_STORE_EXITING |
#endif
              CPU_BASED_CR3_LOAD_EXITING |
              CPU_BASED_CR3_STORE_EXITING |
              CPU_BASED_UNCOND_IO_EXITING |
              CPU_BASED_MOV_DR_EXITING |
              CPU_BASED_USE_TSC_OFFSETTING |
              CPU_BASED_MWAIT_EXITING |
              CPU_BASED_MONITOR_EXITING |
              CPU_BASED_INVLPG_EXITING |
              CPU_BASED_RDPMC_EXITING;
        // 可选的能力, secondary
        opt = CPU_BASED_TPR_SHADOW |
              CPU_BASED_USE_MSR_BITMAPS |
              CPU_BASED_ACTIVATE_SECONDARY_CONTROLS;
        // 根据 IA32_VMX_PROCBASED_CTLS msr 寄存器的值来决定 primary 的值
        // 调整结果存放到 _cpu_based_exec_control 中
        // min 是 CTLS 必须支持的最小合集; opt 是可选功能
        if (adjust_vmx_controls(min, opt, MSR_IA32_VMX_PROCBASED_CTLS,
                                &_cpu_based_exec_control) < 0)
                return -EIO;
        if (_cpu_based_exec_control & CPU_BASED_ACTIVATE_SECONDARY_CONTROLS) {
                min2 = 0;
                opt2 = SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |
                        SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |
                        SECONDARY_EXEC_WBINVD_EXITING |
                        SECONDARY_EXEC_ENABLE_VPID |
                        SECONDARY_EXEC_ENABLE_EPT |
                        SECONDARY_EXEC_UNRESTRICTED_GUEST |
                        SECONDARY_EXEC_PAUSE_LOOP_EXITING |
                        SECONDARY_EXEC_DESC |
                        SECONDARY_EXEC_ENABLE_RDTSCP |
                        SECONDARY_EXEC_ENABLE_INVPCID |
                        SECONDARY_EXEC_APIC_REGISTER_VIRT |
                        SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |
                        SECONDARY_EXEC_SHADOW_VMCS |
                        SECONDARY_EXEC_XSAVES |
                        SECONDARY_EXEC_RDSEED_EXITING |
                        SECONDARY_EXEC_RDRAND_EXITING |
                        SECONDARY_EXEC_ENABLE_PML |
                        SECONDARY_EXEC_TSC_SCALING |
                        SECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE |
                        SECONDARY_EXEC_PT_USE_GPA |
                        SECONDARY_EXEC_PT_CONCEAL_VMX |
                        SECONDARY_EXEC_ENABLE_VMFUNC |
                        SECONDARY_EXEC_BUS_LOCK_DETECTION;
                if (cpu_has_sgx())
                        opt2 |= SECONDARY_EXEC_ENCLS_EXITING;
                if (adjust_vmx_controls(min2, opt2,
                                        MSR_IA32_VMX_PROCBASED_CTLS2,
                                        &_cpu_based_2nd_exec_control) < 0)
                        return -EIO;
        }
#ifndef CONFIG_X86_64
        if (!(_cpu_based_2nd_exec_control &
                                SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES))
                _cpu_based_exec_control &= ~CPU_BASED_TPR_SHADOW;
#endif

        if (!(_cpu_based_exec_control & CPU_BASED_TPR_SHADOW))
                _cpu_based_2nd_exec_control &= ~(
                                SECONDARY_EXEC_APIC_REGISTER_VIRT |
                                SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |
                                SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);

        rdmsr_safe(MSR_IA32_VMX_EPT_VPID_CAP,
                &vmx_cap->ept, &vmx_cap->vpid);

        if (_cpu_based_2nd_exec_control & SECONDARY_EXEC_ENABLE_EPT) {
                /* CR3 accesses and invlpg don't need to cause VM Exits when EPT
                   enabled */
                _cpu_based_exec_control &= ~(CPU_BASED_CR3_LOAD_EXITING |
                                             CPU_BASED_CR3_STORE_EXITING |
                                             CPU_BASED_INVLPG_EXITING);
        } else if (vmx_cap->ept) {
                vmx_cap->ept = 0;
                pr_warn_once("EPT CAP should not exist if not support "
                                "1-setting enable EPT VM-execution control\n");
        }
        if (!(_cpu_based_2nd_exec_control & SECONDARY_EXEC_ENABLE_VPID) &&
                vmx_cap->vpid) {
                vmx_cap->vpid = 0;
                pr_warn_once("VPID CAP should not exist if not support "
                                "1-setting enable VPID VM-execution control\n");
        }

        min = VM_EXIT_SAVE_DEBUG_CONTROLS | VM_EXIT_ACK_INTR_ON_EXIT;
#ifdef CONFIG_X86_64
        min |= VM_EXIT_HOST_ADDR_SPACE_SIZE;
#endif
        opt = VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL |
              VM_EXIT_LOAD_IA32_PAT |
              VM_EXIT_LOAD_IA32_EFER |
              VM_EXIT_CLEAR_BNDCFGS |
              VM_EXIT_PT_CONCEAL_PIP |
              VM_EXIT_CLEAR_IA32_RTIT_CTL;
        if (adjust_vmx_controls(min, opt, MSR_IA32_VMX_EXIT_CTLS,
                                &_vmexit_control) < 0)
                return -EIO;

        min = PIN_BASED_EXT_INTR_MASK | PIN_BASED_NMI_EXITING;
        opt = PIN_BASED_VIRTUAL_NMIS | PIN_BASED_POSTED_INTR |
                 PIN_BASED_VMX_PREEMPTION_TIMER;
        if (adjust_vmx_controls(min, opt, MSR_IA32_VMX_PINBASED_CTLS,
                                &_pin_based_exec_control) < 0)
                return -EIO;

        if (cpu_has_broken_vmx_preemption_timer())
                _pin_based_exec_control &= ~PIN_BASED_VMX_PREEMPTION_TIMER;
        if (!(_cpu_based_2nd_exec_control &
                SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY))
                _pin_based_exec_control &= ~PIN_BASED_POSTED_INTR;

        min = VM_ENTRY_LOAD_DEBUG_CONTROLS;
        opt = VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL |
              VM_ENTRY_LOAD_IA32_PAT |
              VM_ENTRY_LOAD_IA32_EFER |
              VM_ENTRY_LOAD_BNDCFGS |
              VM_ENTRY_PT_CONCEAL_PIP |
              VM_ENTRY_LOAD_IA32_RTIT_CTL;
        if (adjust_vmx_controls(min, opt, MSR_IA32_VMX_ENTRY_CTLS,
                                &_vmentry_control) < 0)
                return -EIO;

        /*
         * Some cpus support VM_{ENTRY,EXIT}_IA32_PERF_GLOBAL_CTRL but they
         * can't be used due to an errata where VM Exit may incorrectly clear
         * IA32_PERF_GLOBAL_CTRL[34:32].  Workaround the errata by using the
         * MSR load mechanism to switch IA32_PERF_GLOBAL_CTRL.
         */
        if (boot_cpu_data.x86 == 0x6) {
                switch (boot_cpu_data.x86_model) {
                case 26: /* AAK155 */
                case 30: /* AAP115 */
                case 37: /* AAT100 */
                case 44: /* BC86,AAY89,BD102 */
                case 46: /* BA97 */
                        _vmentry_control &= ~VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL;
                        _vmexit_control &= ~VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL;
                        pr_warn_once("kvm: VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL "
                                        "does not work properly. Using workaround\n");
                        break;
                default:
                        break;
                }
        }

        rdmsr(MSR_IA32_VMX_BASIC, vmx_msr_low, vmx_msr_high);

        /* IA-32 SDM Vol 3B: VMCS size is never greater than 4kB. */
        if ((vmx_msr_high & 0x1fff) > PAGE_SIZE)
                return -EIO;

#ifdef CONFIG_X86_64
        /* IA-32 SDM Vol 3B: 64-bit CPUs always have VMX_BASIC_MSR[48]==0. */
        if (vmx_msr_high & (1u<<16))
                return -EIO;
#endif

        /* Require Write-Back (WB) memory type for VMCS accesses. */
        if (((vmx_msr_high >> 18) & 15) != 6)
                return -EIO;

        vmcs_conf->size = vmx_msr_high & 0x1fff;
        vmcs_conf->order = get_order(vmcs_conf->size);
        vmcs_conf->basic_cap = vmx_msr_high & ~0x1fff;

        vmcs_conf->revision_id = vmx_msr_low;

        vmcs_conf->pin_based_exec_ctrl = _pin_based_exec_control;
        vmcs_conf->cpu_based_exec_ctrl = _cpu_based_exec_control;
        vmcs_conf->cpu_based_2nd_exec_ctrl = _cpu_based_2nd_exec_control;
        vmcs_conf->vmexit_ctrl         = _vmexit_control;
        vmcs_conf->vmentry_ctrl        = _vmentry_control;

#if IS_ENABLED(CONFIG_HYPERV)
        if (enlightened_vmcs)
                evmcs_sanitize_exec_ctrls(vmcs_conf);
#endif

        return 0;
}
```

