
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 32 位字段值](#1-32-位字段值)
- [2. primary processor-based VM-execution control](#2-primary-processor-based-vm-execution-control)
  - [2.1. 模块初始化阶段](#21-模块初始化阶段)
  - [2.2. vcpu创建阶段](#22-vcpu创建阶段)
  - [2.3. interrupt-window exiting: bit 2](#23-interrupt-window-exiting-bit-2)
  - [2.4. Use TSC offsetting: bit 3](#24-use-tsc-offsetting-bit-3)
  - [2.5. HLT exiting: bit 7](#25-hlt-exiting-bit-7)
  - [2.6. INVLPG exiting: bit 9](#26-invlpg-exiting-bit-9)
  - [2.7. MWAIT exiting: bit 10](#27-mwait-exiting-bit-10)
  - [2.8. RDPMC exiting: bit 11](#28-rdpmc-exiting-bit-11)
  - [2.9. RDTSC exiting: bit 12](#29-rdtsc-exiting-bit-12)
  - [2.10. CR3-load exiting: bit 15](#210-cr3-load-exiting-bit-15)
  - [2.11. CR3-store exiting: bit 16](#211-cr3-store-exiting-bit-16)
  - [2.12. CR8-load exiting: bit 19](#212-cr8-load-exiting-bit-19)
  - [2.13. CR8-store exiting: bit 20](#213-cr8-store-exiting-bit-20)
  - [2.14. Use TPR shadow: bit 21](#214-use-tpr-shadow-bit-21)
  - [2.15. NMI-window exiting: bit 22](#215-nmi-window-exiting-bit-22)
  - [2.16. MOV-DR exiting: bit 23](#216-mov-dr-exiting-bit-23)
  - [2.17. Unconditional I/O exiting: bit 24](#217-unconditional-io-exiting-bit-24)
  - [2.18. Use I/O bitmap: bit 25](#218-use-io-bitmap-bit-25)
  - [2.19. Monitor trap flag: bit 27](#219-monitor-trap-flag-bit-27)
  - [2.20. Use MSR bitmap: bit 28](#220-use-msr-bitmap-bit-28)
  - [2.21. MONITOR exiting: bit 29](#221-monitor-exiting-bit-29)
  - [2.22. PAUSE exiting: bit 30](#222-pause-exiting-bit-30)
  - [2.23. Activate secondary controls: bit 31](#223-activate-secondary-controls-bit-31)
- [3. secondary processor-based VM-execution control](#3-secondary-processor-based-vm-execution-control)

<!-- /code_chunk_output -->


# 1. 32 位字段值

```cpp
enum vmcs_field {
    CPU_BASED_VM_EXEC_CONTROL       = 0x00004002,
    SECONDARY_VM_EXEC_CONTROL       = 0x0000401e,
}
```

32 位字段值, 所以都使用 `vmcs_write32/read32()`, 见`3.3.2`

# 2. primary processor-based VM-execution control

## 2.1. 模块初始化阶段

在模块初始化时候

```cpp
// arch/x86/kvm/vmx/vmx.c
// 全局变量
struct vmcs_config vmcs_config;
struct vmx_capability vmx_capability;

hardware_setup();
 ├─setup_vmcs_config(&vmcs_config, &vmx_capability);
```

```cpp
// arch/x86/include/asm/msr-index.h
#define MSR_IA32_VMX_PROCBASED_CTLS     0x00000482

// arch/x86/kvm/vmx/vmx.c
static __init int setup_vmcs_config(struct vmcs_config *vmcs_conf,
                                    struct vmx_capability *vmx_cap)
{
        u32 vmx_msr_low, vmx_msr_high;
        u32 min, opt, min2, opt2;
        u32 _pin_based_exec_control = 0;
        u32 _cpu_based_exec_control = 0;
        u32 _cpu_based_2nd_exec_control = 0;
        u32 _vmexit_control = 0;
        u32 _vmentry_control = 0;
        // 初始化全局变量 vmcs_conf 全部为 0
        memset(vmcs_conf, 0, sizeof(*vmcs_conf));
        // 下面的 MSR_IA32_VMX_PROCBASED_CTLS 必须支持的能力
        min = CPU_BASED_HLT_EXITING |
#ifdef CONFIG_X86_64
              CPU_BASED_CR8_LOAD_EXITING |
              CPU_BASED_CR8_STORE_EXITING |
#endif
              CPU_BASED_CR3_LOAD_EXITING |
              CPU_BASED_CR3_STORE_EXITING |
              CPU_BASED_UNCOND_IO_EXITING |
              CPU_BASED_MOV_DR_EXITING |
              CPU_BASED_USE_TSC_OFFSETTING |
              CPU_BASED_MWAIT_EXITING |
              CPU_BASED_MONITOR_EXITING |
              CPU_BASED_INVLPG_EXITING |
              CPU_BASED_RDPMC_EXITING;
        // 可选的能力
        opt = CPU_BASED_TPR_SHADOW |
              CPU_BASED_USE_MSR_BITMAPS |
              CPU_BASED_ACTIVATE_SECONDARY_CONTROLS;
        // 根据 IA32_VMX_PROCBASED_CTLS msr 寄存器的值来决定 primary 的值
        // 调整结果存放到 _cpu_based_exec_control 中
        // min 是 CTLS 必须支持的最小合集; opt 是可选功能
        if (adjust_vmx_controls(min, opt, MSR_IA32_VMX_PROCBASED_CTLS,
                                &_cpu_based_exec_control) < 0)
                return -EIO;
#ifdef CONFIG_X86_64
        // 如果开启了 TPR shadow, CR8 这两个 会
        if ((_cpu_based_exec_control & CPU_BASED_TPR_SHADOW))
                _cpu_based_exec_control &= ~CPU_BASED_CR8_LOAD_EXITING &
                                           ~CPU_BASED_CR8_STORE_EXITING;
#endif
        ......
#ifndef CONFIG_X86_64
        if (!(_cpu_based_2nd_exec_control &
                                SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES))
                _cpu_based_exec_control &= ~CPU_BASED_TPR_SHADOW;
#endif
        .....
        if (_cpu_based_2nd_exec_control & SECONDARY_EXEC_ENABLE_EPT) {
                /* CR3 accesses and invlpg don't need to cause VM Exits when EPT
                   enabled */
                _cpu_based_exec_control &= ~(CPU_BASED_CR3_LOAD_EXITING |
                                             CPU_BASED_CR3_STORE_EXITING |
                                             CPU_BASED_INVLPG_EXITING);
        }
        ......
        vmcs_conf->cpu_based_exec_ctrl = _cpu_based_exec_control;
        .....
        return 0;
}
```

先将所有支持的功能设置为初始值, 然后根据条件支持与否再清理.

## 2.2. vcpu创建阶段

```cpp
kvm_vm_ioctl() // kvm ioctl vm指令入口
 ├─ kvm_vm_ioctl_create_vcpu() // 为虚拟机创建VCPU的ioctl调用的入口函数
 |   ├─ kvm_arch_vcpu_create() // 初始化kvm_vcpu_arch结构体, 架构相关 
 |   |   ├─ static_call(kvm_x86_vcpu_create)(vcpu); //对于intel x86来说, 最终调用 vmx_create_vcpu
 |   |   |   ├─ init_vmcs(vmx); // 初始化vmcs, 而guest-state在vmx_vcpu_reset()
 |   |   |   |   ├─ exec_controls_set(vmx, vmx_exec_control(vmx)); // 设置 pin-based VM-execution control 字段
 |   ├─ km_arch_vcpu_postcreate() // 架构相关的善后工作, 比如再次调用vcpu_load, 以及tsc相关处理
 |   |   ├─vcpu_load(); // 加载vcpu信息<参数为kvm_vcpu>, struct vmx_vcpu(vcpu的一个运行环境)加载
 |   |   |   ├─ kvm_arch_vcpu_load(vcpu, cpu)
 |   |   |   |   ├─ static_call(kvm_x86_vcpu_load)(vcpu, cpu); // 实际调用vmx.c的 vmx_vcpu_load()
```

在加载 `current-VMCS` 之前, 会对 VMCS 相应字段进行设置

```cpp
static void init_vmcs(struct vcpu_vmx *vmx)
{
        // 写入 vmcs
        exec_controls_set(vmx, vmx_exec_control(vmx));
}
```

这里先通过 `vmx_exec_control()` 对 `primary processor-based VM-execution control` 字段进行自定义设置

```cpp
static bool __read_mostly enable_vnmi = 1;
module_param_named(vnmi, enable_vnmi, bool, S_IRUGO);

static bool __read_mostly enable_preemption_timer = 1;
#ifdef CONFIG_X86_64
module_param_named(preemption_timer, enable_preemption_timer, bool, S_IRUGO);
#endif

u32 vmx_exec_control(struct vcpu_vmx *vmx)
{
        // 全局变量
        u32 exec_control = vmcs_config.cpu_based_exec_ctrl;
        // 
        if (vmx->vcpu.arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)
                exec_control &= ~CPU_BASED_MOV_DR_EXITING;

        if (!cpu_need_tpr_shadow(&vmx->vcpu)) {
                exec_control &= ~CPU_BASED_TPR_SHADOW;
#ifdef CONFIG_X86_64
                exec_control |= CPU_BASED_CR8_STORE_EXITING |
                                CPU_BASED_CR8_LOAD_EXITING;
#endif
        }
        if (!enable_ept)
                exec_control |= CPU_BASED_CR3_STORE_EXITING |
                                CPU_BASED_CR3_LOAD_EXITING  |
                                CPU_BASED_INVLPG_EXITING;
        if (kvm_mwait_in_guest(vmx->vcpu.kvm))
                exec_control &= ~(CPU_BASED_MWAIT_EXITING |
                                CPU_BASED_MONITOR_EXITING);
        if (kvm_hlt_in_guest(vmx->vcpu.kvm))
                exec_control &= ~CPU_BASED_HLT_EXITING;
        return exec_control;
}
u32 vmx_pin_based_exec_ctrl(struct vcpu_vmx *vmx)
{
        u32 pin_based_exec_ctrl = vmcs_config.pin_based_exec_ctrl;
        // apicv 没有开启, 清掉 posted-interrupt
        if (!kvm_vcpu_apicv_active(&vmx->vcpu))
                pin_based_exec_ctrl &= ~PIN_BASED_POSTED_INTR;
        
        // 使用virtual NMIs模块参数关闭的话, 清掉这个feature
        if (!enable_vnmi)
                pin_based_exec_ctrl &= ~PIN_BASED_VIRTUAL_NMIS;

        // 使用模块参数关闭的话, 清掉这个feature
        if (!enable_preemption_timer)
                pin_based_exec_ctrl &= ~PIN_BASED_VMX_PREEMPTION_TIMER;

        return pin_based_exec_ctrl;
}
```

```cpp
static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)
{
    return vcpu->arch.apic && vcpu->arch.apicv_active;
}
```

`kvm_vcpu_apicv_active` 没有开启, 清掉 `posted-interrupt`

最后, 会通过 `pin_controls_set()` 将 构建的`pin-based VM-execution control` 字段写入 VMCS. 定义如下:

```cpp
// arch/x86/kvm/vmx/vmx.h
#define BUILD_CONTROLS_SHADOW(lname, uname)                 \
static inline void lname##_controls_set(struct vcpu_vmx *vmx, u32 val)      \
{                                       \
    if (vmx->loaded_vmcs->controls_shadow.lname != val) {           \
        vmcs_write32(uname, val);                   \
        vmx->loaded_vmcs->controls_shadow.lname = val;          \
    }                                   \
}                                       \
static inline u32 lname##_controls_get(struct vcpu_vmx *vmx)            \
{                                       \
    return vmx->loaded_vmcs->controls_shadow.lname;             \
}                                       \
static inline void lname##_controls_setbit(struct vcpu_vmx *vmx, u32 val)   \
{                                       \
    lname##_controls_set(vmx, lname##_controls_get(vmx) | val);     \
}                                       \
static inline void lname##_controls_clearbit(struct vcpu_vmx *vmx, u32 val) \
{                                       \
    lname##_controls_set(vmx, lname##_controls_get(vmx) & ~val);        \
}
BUILD_CONTROLS_SHADOW(vm_entry, VM_ENTRY_CONTROLS)
BUILD_CONTROLS_SHADOW(vm_exit, VM_EXIT_CONTROLS)
BUILD_CONTROLS_SHADOW(pin, PIN_BASED_VM_EXEC_CONTROL)
BUILD_CONTROLS_SHADOW(exec, CPU_BASED_VM_EXEC_CONTROL)
BUILD_CONTROLS_SHADOW(secondary_exec, SECONDARY_VM_EXEC_CONTROL)
```


## 2.3. interrupt-window exiting: bit 2

只要相应的 CTL 寄存器相应的位功能可用, 读取 `MSR_IA32_VMX_PROCBASED_CTLS` 判断

## 2.4. Use TSC offsetting: bit 3

只要相应的 CTL 寄存器相应的位功能可用, **通过 min 确保**一定可用

## 2.5. HLT exiting: bit 7

只要相应的 CTL 寄存器相应的位功能可用, **通过 min 确保**一定可用

但是当 HLT 指令透传给虚拟机时候, 会清除相应位

```cpp
        if (kvm_hlt_in_guest(vmx->vcpu.kvm))
                exec_control &= ~CPU_BASED_HLT_EXITING;
```

## 2.6. INVLPG exiting: bit 9

在系统初始化阶段, **通过 min 确保**这个功能在处理器层面一定要支持(但是**不意味着肯定会使用**), 同时会**默认开启**

不过这里又提供了一个用户开关, 如果 EPT 打开, 便**不**需要 `VM-exit`

所以在创建vcpu阶段会判断并清除, 所以如果EPT关闭了, 又会开启

```cpp
        if (!enable_ept)
                exec_control |= CPU_BASED_CR3_STORE_EXITING |
                                CPU_BASED_CR3_LOAD_EXITING  |
                                CPU_BASED_INVLPG_EXITING;
```

## 2.7. MWAIT exiting: bit 10



## 2.8. RDPMC exiting: bit 11

## 2.9. RDTSC exiting: bit 12

## 2.10. CR3-load exiting: bit 15

## 2.11. CR3-store exiting: bit 16

## 2.12. CR8-load exiting: bit 19

CR8寄存器作为TPR（Task Priority Register）的编程接口, 所以如果 TRP shadow 打开的时候, 这个就不可用, 所以清除了

## 2.13. CR8-store exiting: bit 20

同上面

## 2.14. Use TPR shadow: bit 21



## 2.15. NMI-window exiting: bit 22

## 2.16. MOV-DR exiting: bit 23

## 2.17. Unconditional I/O exiting: bit 24

## 2.18. Use I/O bitmap: bit 25

## 2.19. Monitor trap flag: bit 27

## 2.20. Use MSR bitmap: bit 28

## 2.21. MONITOR exiting: bit 29

## 2.22. PAUSE exiting: bit 30

## 2.23. Activate secondary controls: bit 31

# 3. secondary processor-based VM-execution control

```cpp
// arch/x86/include/asm/msr-index.h
#define MSR_IA32_VMX_PROCBASED_CTLS2    0x0000048b

// arch/x86/kvm/vmx/vmx.c
static __init int setup_vmcs_config(struct vmcs_config *vmcs_conf,
                                    struct vmx_capability *vmx_cap)
{
        u32 vmx_msr_low, vmx_msr_high;
        u32 min, opt, min2, opt2;
        u32 _pin_based_exec_control = 0;
        u32 _cpu_based_exec_control = 0;
        u32 _cpu_based_2nd_exec_control = 0;
        u32 _vmexit_control = 0;
        u32 _vmentry_control = 0;
        // 初始化全局变量 vmcs_conf 全部为 0
        memset(vmcs_conf, 0, sizeof(*vmcs_conf));
        // 下面的 MSR_IA32_VMX_PROCBASED_CTLS 必须支持的能力
        min = CPU_BASED_HLT_EXITING |
#ifdef CONFIG_X86_64
              CPU_BASED_CR8_LOAD_EXITING |
              CPU_BASED_CR8_STORE_EXITING |
#endif
              CPU_BASED_CR3_LOAD_EXITING |
              CPU_BASED_CR3_STORE_EXITING |
              CPU_BASED_UNCOND_IO_EXITING |
              CPU_BASED_MOV_DR_EXITING |
              CPU_BASED_USE_TSC_OFFSETTING |
              CPU_BASED_MWAIT_EXITING |
              CPU_BASED_MONITOR_EXITING |
              CPU_BASED_INVLPG_EXITING |
              CPU_BASED_RDPMC_EXITING;
        // 可选的能力, secondary
        opt = CPU_BASED_TPR_SHADOW |
              CPU_BASED_USE_MSR_BITMAPS |
              CPU_BASED_ACTIVATE_SECONDARY_CONTROLS;
        // 根据 IA32_VMX_PROCBASED_CTLS msr 寄存器的值来决定 primary 的值
        // 调整结果存放到 _cpu_based_exec_control 中
        // min 是 CTLS 必须支持的最小合集; opt 是可选功能
        if (adjust_vmx_controls(min, opt, MSR_IA32_VMX_PROCBASED_CTLS,
                                &_cpu_based_exec_control) < 0)
                return -EIO;
        if (_cpu_based_exec_control & CPU_BASED_ACTIVATE_SECONDARY_CONTROLS) {
                min2 = 0;
                opt2 = SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |
                        SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |
                        SECONDARY_EXEC_WBINVD_EXITING |
                        SECONDARY_EXEC_ENABLE_VPID |
                        SECONDARY_EXEC_ENABLE_EPT |
                        SECONDARY_EXEC_UNRESTRICTED_GUEST |
                        SECONDARY_EXEC_PAUSE_LOOP_EXITING |
                        SECONDARY_EXEC_DESC |
                        SECONDARY_EXEC_ENABLE_RDTSCP |
                        SECONDARY_EXEC_ENABLE_INVPCID |
                        SECONDARY_EXEC_APIC_REGISTER_VIRT |
                        SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |
                        SECONDARY_EXEC_SHADOW_VMCS |
                        SECONDARY_EXEC_XSAVES |
                        SECONDARY_EXEC_RDSEED_EXITING |
                        SECONDARY_EXEC_RDRAND_EXITING |
                        SECONDARY_EXEC_ENABLE_PML |
                        SECONDARY_EXEC_TSC_SCALING |
                        SECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE |
                        SECONDARY_EXEC_PT_USE_GPA |
                        SECONDARY_EXEC_PT_CONCEAL_VMX |
                        SECONDARY_EXEC_ENABLE_VMFUNC |
                        SECONDARY_EXEC_BUS_LOCK_DETECTION;
                if (cpu_has_sgx())
                        opt2 |= SECONDARY_EXEC_ENCLS_EXITING;
                if (adjust_vmx_controls(min2, opt2,
                                        MSR_IA32_VMX_PROCBASED_CTLS2,
                                        &_cpu_based_2nd_exec_control) < 0)
                        return -EIO;
        }
#ifndef CONFIG_X86_64
        if (!(_cpu_based_2nd_exec_control &
                                SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES))
                _cpu_based_exec_control &= ~CPU_BASED_TPR_SHADOW;
#endif

        if (!(_cpu_based_exec_control & CPU_BASED_TPR_SHADOW))
                _cpu_based_2nd_exec_control &= ~(
                                SECONDARY_EXEC_APIC_REGISTER_VIRT |
                                SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |
                                SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);

        rdmsr_safe(MSR_IA32_VMX_EPT_VPID_CAP,
                &vmx_cap->ept, &vmx_cap->vpid);

        if (_cpu_based_2nd_exec_control & SECONDARY_EXEC_ENABLE_EPT) {
                /* CR3 accesses and invlpg don't need to cause VM Exits when EPT
                   enabled */
                _cpu_based_exec_control &= ~(CPU_BASED_CR3_LOAD_EXITING |
                                             CPU_BASED_CR3_STORE_EXITING |
                                             CPU_BASED_INVLPG_EXITING);
        } else if (vmx_cap->ept) {
                vmx_cap->ept = 0;
                pr_warn_once("EPT CAP should not exist if not support "
                                "1-setting enable EPT VM-execution control\n");
        }
        if (!(_cpu_based_2nd_exec_control & SECONDARY_EXEC_ENABLE_VPID) &&
                vmx_cap->vpid) {
                vmx_cap->vpid = 0;
                pr_warn_once("VPID CAP should not exist if not support "
                                "1-setting enable VPID VM-execution control\n");
        }

        min = VM_EXIT_SAVE_DEBUG_CONTROLS | VM_EXIT_ACK_INTR_ON_EXIT;
#ifdef CONFIG_X86_64
        min |= VM_EXIT_HOST_ADDR_SPACE_SIZE;
#endif
        opt = VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL |
              VM_EXIT_LOAD_IA32_PAT |
              VM_EXIT_LOAD_IA32_EFER |
              VM_EXIT_CLEAR_BNDCFGS |
              VM_EXIT_PT_CONCEAL_PIP |
              VM_EXIT_CLEAR_IA32_RTIT_CTL;
        if (adjust_vmx_controls(min, opt, MSR_IA32_VMX_EXIT_CTLS,
                                &_vmexit_control) < 0)
                return -EIO;

        min = PIN_BASED_EXT_INTR_MASK | PIN_BASED_NMI_EXITING;
        opt = PIN_BASED_VIRTUAL_NMIS | PIN_BASED_POSTED_INTR |
                 PIN_BASED_VMX_PREEMPTION_TIMER;
        if (adjust_vmx_controls(min, opt, MSR_IA32_VMX_PINBASED_CTLS,
                                &_pin_based_exec_control) < 0)
                return -EIO;

        if (cpu_has_broken_vmx_preemption_timer())
                _pin_based_exec_control &= ~PIN_BASED_VMX_PREEMPTION_TIMER;
        if (!(_cpu_based_2nd_exec_control &
                SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY))
                _pin_based_exec_control &= ~PIN_BASED_POSTED_INTR;

        min = VM_ENTRY_LOAD_DEBUG_CONTROLS;
        opt = VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL |
              VM_ENTRY_LOAD_IA32_PAT |
              VM_ENTRY_LOAD_IA32_EFER |
              VM_ENTRY_LOAD_BNDCFGS |
              VM_ENTRY_PT_CONCEAL_PIP |
              VM_ENTRY_LOAD_IA32_RTIT_CTL;
        if (adjust_vmx_controls(min, opt, MSR_IA32_VMX_ENTRY_CTLS,
                                &_vmentry_control) < 0)
                return -EIO;

        /*
         * Some cpus support VM_{ENTRY,EXIT}_IA32_PERF_GLOBAL_CTRL but they
         * can't be used due to an errata where VM Exit may incorrectly clear
         * IA32_PERF_GLOBAL_CTRL[34:32].  Workaround the errata by using the
         * MSR load mechanism to switch IA32_PERF_GLOBAL_CTRL.
         */
        if (boot_cpu_data.x86 == 0x6) {
                switch (boot_cpu_data.x86_model) {
                case 26: /* AAK155 */
                case 30: /* AAP115 */
                case 37: /* AAT100 */
                case 44: /* BC86,AAY89,BD102 */
                case 46: /* BA97 */
                        _vmentry_control &= ~VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL;
                        _vmexit_control &= ~VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL;
                        pr_warn_once("kvm: VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL "
                                        "does not work properly. Using workaround\n");
                        break;
                default:
                        break;
                }
        }

        rdmsr(MSR_IA32_VMX_BASIC, vmx_msr_low, vmx_msr_high);

        /* IA-32 SDM Vol 3B: VMCS size is never greater than 4kB. */
        if ((vmx_msr_high & 0x1fff) > PAGE_SIZE)
                return -EIO;

#ifdef CONFIG_X86_64
        /* IA-32 SDM Vol 3B: 64-bit CPUs always have VMX_BASIC_MSR[48]==0. */
        if (vmx_msr_high & (1u<<16))
                return -EIO;
#endif

        /* Require Write-Back (WB) memory type for VMCS accesses. */
        if (((vmx_msr_high >> 18) & 15) != 6)
                return -EIO;

        vmcs_conf->size = vmx_msr_high & 0x1fff;
        vmcs_conf->order = get_order(vmcs_conf->size);
        vmcs_conf->basic_cap = vmx_msr_high & ~0x1fff;

        vmcs_conf->revision_id = vmx_msr_low;

        vmcs_conf->pin_based_exec_ctrl = _pin_based_exec_control;
        vmcs_conf->cpu_based_exec_ctrl = _cpu_based_exec_control;
        vmcs_conf->cpu_based_2nd_exec_ctrl = _cpu_based_2nd_exec_control;
        vmcs_conf->vmexit_ctrl         = _vmexit_control;
        vmcs_conf->vmentry_ctrl        = _vmentry_control;

#if IS_ENABLED(CONFIG_HYPERV)
        if (enlightened_vmcs)
                evmcs_sanitize_exec_ctrls(vmcs_conf);
#endif

        return 0;
}
```

