
```cpp
kvm_vm_ioctl() // kvm ioctl vm指令入口
 ├─ kvm_vm_ioctl_create_vcpu() // 为虚拟机创建VCPU的ioctl调用的入口函数
 |   ├─ kvm_arch_vcpu_precreate() // stable tsc检查
 |   ├─ kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL); // 给kvm_vcpu分配内存, 该cache是kvm模块初始化时创建的
 |   ├─ page = alloc_page(); // 分配一页内存给vcpu->run(struct kvm_run)
 |   ├─ kvm_vcpu_init(vcpu, kvm, id); // vcpu结构体一些变量初始化
 |   ├─ kvm_arch_vcpu_create() // 初始化kvm_vcpu_arch结构体, 架构相关 
 |   |   ├─ kvm_vcpu_reset(vcpu, false); // 对vcpu结构进行初始化
 |   |   |   └─ static_call(kvm_x86_vcpu_reset)(vcpu, init_event); // 调用相应架构的 vcpu_reset 函数
```

```cpp
// arch/x86/include/asm/vmx.h
/* VMCS Encodings */
enum vmcs_field {
    ......
    EXCEPTION_BITMAP                = 0x00004004,
    ......
}

// arch/x86/kvm/vmx/vmx.c
void vmx_update_exception_bitmap(struct kvm_vcpu *vcpu)
{
        u32 eb;
        // PF, UD, MC, DB, AC 异常
        eb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |
             (1u << DB_VECTOR) | (1u << AC_VECTOR);
        /*
         * Guest access to VMware backdoor ports could legitimately
         * trigger #GP because of TSS I/O permission bitmap.
         * We intercept those #GP and allow access to them anyway
         * as VMware does.
         */
        if (enable_vmware_backdoor)
                eb |= (1u << GP_VECTOR);
        if ((vcpu->guest_debug &
             (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==
            (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))
                eb |= 1u << BP_VECTOR;
        // 实模式??
        if (to_vmx(vcpu)->rmode.vm86_active)
                eb = ~0;
        // 不需要拦截 pf 异常
        if (!vmx_need_pf_intercept(vcpu))
                eb &= ~(1u << PF_VECTOR);

        /* When we are running a nested L2 guest and L1 specified for it a
         * certain exception bitmap, we must trap the same exceptions and pass
         * them to L1. When running L2, we will only handle the exceptions
         * specified above if L1 did not want them.
         */
        // 嵌套
        if (is_guest_mode(vcpu))
                eb |= get_vmcs12(vcpu)->exception_bitmap;
        else {
                /*
                 * If EPT is enabled, #PF is only trapped if MAXPHYADDR is misma2       tched
                 * between guest and host.  In that case we only care about pres2       ent
                 * faults.  For vmcs02, however, PFEC_MASK and PFEC_MATCH are se2       t in
                 * prepare_vmcs02_rare.
                 */
                bool selective_pf_trap = enable_ept && (eb & (1u << PF_VECTOR));
                int mask = selective_pf_trap ? PFERR_PRESENT_MASK : 0;
                vmcs_write32(PAGE_FAULT_ERROR_CODE_MASK, mask);
                vmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH, mask);
        }
        // 写 vmcs 的 VM-execution 控制字段
        vmcs_write32(EXCEPTION_BITMAP, eb);
}
```