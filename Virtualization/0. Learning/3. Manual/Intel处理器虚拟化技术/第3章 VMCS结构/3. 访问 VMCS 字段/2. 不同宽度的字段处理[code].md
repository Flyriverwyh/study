
* 0x6000: `bit 14:13` = 11b
* 0x6001: `bit 14:13` = 11b, `bit 0` = 1
* 0x2000: `bit 14:13` = 01b
* 0x2001: `bit 14:13` = 01b, `bit 0` = 1
* 0x4000: `bit 14:13` = 10b

# 16位字段检查

```cpp
// arch/x86/kvm/vmx/vmx_ops.h
static __always_inline void vmcs_check16(unsigned long field)
{
    BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2000,
             "16-bit accessor invalid for 64-bit field");
    BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,
             "16-bit accessor invalid for 64-bit high field");
    BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,
             "16-bit accessor invalid for 32-bit high field");
    BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,
             "16-bit accessor invalid for natural width field");
}
```

16位字段要求: `bit 0`必须为0, `bit 14:13 = 00b`

1. `((field) & 0x6001) == 0x2000`

* `bit 0` 符合
* `bit 14:13` 是01b, 即64位, 不符合

2. `((field) & 0x6001) == 0x2001`

* `bit 1` 是1, 即high类型, 不符合
* `bit 14:13` 是01b, 即64位, 不符合

3. `((field) & 0x6000) == 0x4000`

* `bit 0` 符合
* `bit 14:13` 是10b, 即32位, 不符合 

4. `((field) & 0x6000) == 0x6000`

* `bit 0` 符合
* `bit 14:13` 是11b, 即`natural-width`, 不符合

注: 32/natural-width 不判断 bit 0, 因为只有64位有对 bit 0 进行限制

# 32位字段检查

```cpp
static __always_inline void vmcs_check32(unsigned long field)
{
    BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,
             "32-bit accessor invalid for 16-bit field");
    BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,
             "32-bit accessor invalid for natural width field");
}
```

32位字段要求: `bit 0`必须为0, `bit 14:13 = 10b`

1. `((field) & 0x6000) == 0`

* `bit 0` 符合
* `bit 14:13` 是0, 即16位, 不符合

2. `((field) & 0x6000) == 0x6000`

* `bit 0` 符合
* `bit 14:13` 是11b, 即`natural-width`, 不符合

注: 缺少对64位和64位high的判断; 

16/natural-width 不判断 bit 0, 因为只有64位有对 bit 0 进行限制

# 64位字段检查

```cpp
static __always_inline void vmcs_check64(unsigned long field)
{
    BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,
             "64-bit accessor invalid for 16-bit field");
    BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,
             "64-bit accessor invalid for 64-bit high field");
    BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,
             "64-bit accessor invalid for 32-bit field");
    BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,
             "64-bit accessor invalid for natural width field");
}
```

64位字段要求: 仅仅要求`bit 14:13 = 10b`

1. `((field) & 0x6000) == 0`

* `bit 14:13` 是0, 即16位, 不符合

2. `((field) & 0x6001) == 0x2001`

* `bit 1` 是1, 即high类型, 访问 64 位字段的高 32 位
* `bit 14:13` 是01b, 即64位

3. `((field) & 0x6000) == 0x4000`

* `bit 0` 符合
* `bit 14:13` 是10b, 即32位, 不符合 

4. `((field) & 0x6000) == 0x6000`

* `bit 14:13` 是11b, 即`natural-width`, 不符合

注: 缺少对64位和64位high的判断; 

16/natural-width 不判断 bit 0, 因为只有64位有对 bit 0 进行限制

# natural-width字段检查

```cpp
static __always_inline void vmcs_checkl(unsigned long field)
{
    BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,
             "Natural width accessor invalid for 16-bit field");
    BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2000,
             "Natural width accessor invalid for 64-bit field");
    BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,
             "Natural width accessor invalid for 64-bit high field");
    BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,
             "Natural width accessor invalid for 32-bit field");
}
```




```cpp
// arch/x86/kvm/vmx/vmx_ops.h
static __always_inline u16 vmcs_read16(unsigned long field)
{
    vmcs_check16(field);
    if (static_branch_unlikely(&enable_evmcs))
        return evmcs_read16(field);
    return __vmcs_readl(field);
}

static __always_inline u32 vmcs_read32(unsigned long field)
{
    vmcs_check32(field);
    if (static_branch_unlikely(&enable_evmcs))
        return evmcs_read32(field);
    return __vmcs_readl(field);
}

static __always_inline u64 vmcs_read64(unsigned long field)
{
    vmcs_check64(field);
    if (static_branch_unlikely(&enable_evmcs))
        return evmcs_read64(field);
#ifdef CONFIG_X86_64
    return __vmcs_readl(field);
#else
    return __vmcs_readl(field) | ((u64)__vmcs_readl(field+1) << 32);
#endif
}
static __always_inline unsigned long vmcs_readl(unsigned long field)
{
    vmcs_checkl(field);
    if (static_branch_unlikely(&enable_evmcs))
        return evmcs_read64(field);
    return __vmcs_readl(field);
}
```

```cpp
// arch/x86/kvm/vmx/vmx_ops.h
static __always_inline void vmcs_write16(unsigned long field, u16 value)
{
    vmcs_check16(field);
    if (static_branch_unlikely(&enable_evmcs))
        return evmcs_write16(field, value);

    __vmcs_writel(field, value);
}

static __always_inline void vmcs_write32(unsigned long field, u32 value)
{
    vmcs_check32(field);
    if (static_branch_unlikely(&enable_evmcs))
        return evmcs_write32(field, value);

    __vmcs_writel(field, value);
}

static __always_inline void vmcs_write64(unsigned long field, u64 value)
{
    vmcs_check64(field);
    if (static_branch_unlikely(&enable_evmcs))
        return evmcs_write64(field, value);

    __vmcs_writel(field, value);
#ifndef CONFIG_X86_64
    __vmcs_writel(field+1, value >> 32);
#endif
}

static __always_inline void vmcs_writel(unsigned long field, unsigned long value)
{
    vmcs_checkl(field);
    if (static_branch_unlikely(&enable_evmcs))
        return evmcs_write64(field, value);

    __vmcs_writel(field, value);
}
```