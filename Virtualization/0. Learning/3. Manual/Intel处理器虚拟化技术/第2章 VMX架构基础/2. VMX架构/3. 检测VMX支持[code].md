

在 kvm_intel 模块初始化阶段, 就判断是否支持vmx架构

```cpp
// arch/x86/kvm/vmx/vmx.c, 模块文件
static int __init vmx_init(void)
{
        ......
        r = kvm_init(&vmx_init_ops, sizeof(struct vcpu_vmx),
                     __alignof__(struct vcpu_vmx), THIS_MODULE);
        if (r)
                return r;
        ......
}

// virt/kvm/kvm_main.c
int kvm_init(void *opaque, unsigned vcpu_size, unsigned vcpu_align,
                  struct module *module)
{
        ......
        r = kvm_arch_init(opaque);
        if (r)
                goto out_fail;
        ......
}

// arch/x86/kvm/x86.c
int kvm_arch_init(void *opaque)
{
        ......
        if (!ops->cpu_has_kvm_support()) {
                pr_err_ratelimited("kvm: no hardware support\n");
                r = -EOPNOTSUPP;
                goto out;
        }
        ......
}
```

```cpp
// arch/x86/kvm/vmx/vmx.c
static struct kvm_x86_init_ops vmx_init_ops __initdata = {
        .cpu_has_kvm_support = cpu_has_kvm_support,
        .disabled_by_bios = vmx_disabled_by_bios,
        .check_processor_compatibility = vmx_check_processor_compat,
        .hardware_setup = hardware_setup,

        .runtime_ops = &vmx_x86_ops,
};

static __init int cpu_has_kvm_support(void)
{
        return cpu_has_vmx();
}
```

```cpp
// arch/x86/include/asm/virtext.h
static inline int cpu_has_vmx(void)
{
        unsigned long ecx = cpuid_ecx(1);
        // 返回bit[5]的当前值
        // 支持返回1, 不支持返回0
        return test_bit(5, &ecx); /* CPUID.1:ECX.VMX[bit 5] -> VT */
}
```