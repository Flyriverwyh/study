


```cpp
// arch/x86/include/uapi/asm/processor-flags.h
#define X86_CR4_VMXE_BIT    13 /* enable VMX virtualization */
#define X86_CR4_VMXE        _BITUL(X86_CR4_VMXE_BIT)

// arch/x86/kvm/vmx/vmx.c

static int kvm_cpu_vmxon(u64 vmxon_pointer)
{
        u64 msr;
        // 设置开启cr4的 vmxe 位
        cr4_set_bits(X86_CR4_VMXE);

        asm_volatile_goto("1: vmxon %[vmxon_pointer]\n\t"
                          _ASM_EXTABLE(1b, %l[fault])
                          : : [vmxon_pointer] "m"(vmxon_pointer)
                          : : fault);
        return 0;

fault:
        WARN_ONCE(1, "VMXON faulted, MSR_IA32_FEAT_CTL (0x3a) = 0x%llx\n",
                  rdmsrl_safe(MSR_IA32_FEAT_CTL, &msr) ? 0xdeadbeef : msr);
        cr4_clear_bits(X86_CR4_VMXE);

        return -EFAULT;
}

// arch/x86/include/asm/virtext.h

static inline int cpu_vmx_enabled(void)
{
        // 判断 cr4 的vmxe是否置位, 置位返回1, 否则返回0
        return __read_cr4() & X86_CR4_VMXE;
}
```

