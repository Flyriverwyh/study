

开启`CR4.VMXE`控制位, 从而可以使用 VMXON 指令

在创建虚拟机过程中, 

```cpp
用户态ioctl(fd,KVM_CREATE_VM,..)
kvm_dev_ioctl() // kvm ioctl 指令入口
 ├─ kvm_dev_ioctl_create_vm() // 创建虚拟机
 |   ├─ kvm_create_vm() // 实现虚拟机创建的主要函数
 |   |   ├─ hardware_enable_all() // 使能硬件，架构相关操作
 |   |   |   └─ on_each_cpu(hardware_enable_nolock, NULL, 1); // 
 |   |   |       └─ kvm_arch_hardware_enable() // 
 |   |   |           ├─ kvm_x86_ops->hardware_enable()  // 打开硬件功能, 会调用 vmxon 指令
 |   |   |           |   ├─ cr4_read_shadow() & X86_CR4_VMXE;  // 
 |   |   |           |   ├─ kvm_cpu_vmxon()  // vmxon打开VMX模式
```


```cpp
// arch/x86/include/uapi/asm/processor-flags.h
#define X86_CR4_VMXE_BIT    13 /* enable VMX virtualization */
#define X86_CR4_VMXE        _BITUL(X86_CR4_VMXE_BIT)

// arch/x86/kvm/vmx/vmx.c
static int kvm_cpu_vmxon(u64 vmxon_pointer)
{
        u64 msr;
        // 设置开启cr4的 vmxe 位
        cr4_set_bits(X86_CR4_VMXE);

        asm_volatile_goto("1: vmxon %[vmxon_pointer]\n\t"
                          _ASM_EXTABLE(1b, %l[fault])
                          : : [vmxon_pointer] "m"(vmxon_pointer)
                          : : fault);
        return 0;

fault:
        WARN_ONCE(1, "VMXON faulted, MSR_IA32_FEAT_CTL (0x3a) = 0x%llx\n",
                  rdmsrl_safe(MSR_IA32_FEAT_CTL, &msr) ? 0xdeadbeef : msr);
        cr4_clear_bits(X86_CR4_VMXE);

        return -EFAULT;
}

// arch/x86/include/asm/virtext.h

static inline int cpu_vmx_enabled(void)
{
        // 判断 cr4 的vmxe是否置位, 置位返回1, 否则返回0
        return __read_cr4() & X86_CR4_VMXE;
}
```

