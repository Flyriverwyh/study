
```cpp
// arch/x86/kvm/vmx/vmcs.h
// 每个物理逻辑cpu一个current vmcs指针
DECLARE_PER_CPU(struct vmcs *, current_vmcs);

//arch/x86/kvm/vmx/vmx.c
// 每个物理逻辑cpu一个链表, 表示加载当相应cpu上的vmcs
// 从而在cpu下线时, 我们需要VMCLEAR所有加载在CPU上的VMCS
static DEFINE_PER_CPU(struct list_head, loaded_vmcss_on_cpu);
```

# VMPTRLD 指令

加载 `current-VMCS`(`VMPTRLD`) 的地方很多, 这里以创建vcpu为例讲解.

在创建vcpu的过程中

```cpp
kvm_vm_ioctl() // kvm ioctl vm指令入口
 ├─ kvm_vm_ioctl_create_vcpu() // 虚拟机创建VCPU的ioctl调用的入口函数
 |   ├─ kvm_arch_vcpu_create() // 初始化kvm_vcpu_arch结构体, 架构相关
 |   |   ├─ static_call(kvm_x86_vcpu_create)(vcpu); //对于intel x86来说, 最终调用 vmx_create_vcpu
 |   |   |   ├─ alloc_laded_vmcs(&vmx->vmc01); // loaded_vmcs的分配以及初始化
 |   |   |   |   ├─ loaded_vmcs->vmcs = alloc_vmcs(); // 分配一个页面
 |   |   |   |   ├─ vmcs_clear(loaded_vmcs->vmcs); // 调用vmclear 
 |   |   |   |   ├─ loaded_vmcs->shadow_vmcs = NULL;
 |   |   |   |   ├─ loaded_vmcs->hv_timer_soft_disabled = false;
 |   |   |   |   ├─ loaded_vmcs->cpu = -1;
 |   |   |   |   ├─ loaded_vmcs->launched = 0; // 
 |   |   |   |   ├─ loaded_vmcs->msr_bitmap = (unsigned long *)__get_free_page(GFP_KERNEL_ACCOUNT); // msr_bitmap 分配页面
 |   |   |   |   ├─ memset(&loaded_vmcs->host_state, 0, sizeof(struct vmcs_host_state)); // host_state
 |   |   |   |   └─ memset(&loaded_vmcs->controls_shadow, 0, sizeof(struct vmcs_controls_shadow)); // controls_shadow
 |   |   |   ├─ vmx->loaded_vmcs = &vmx->vmcs01;
 |   |   |   ├─ vmx_vcpu_load(); // 加载vcpu信息
 |   |   |   |   ├─ vmx_vcpu_load_vmcs(); // 加载vmcs
 |   |   |   |   |   ├─ already_loaded = vmx->loaded_vmcs->cpu == cpu; // 是否已经加载的判断
 |   |   |   |   |   |   ├─ loaded_vmcs_clear(vmx->loaded_vmcs); // 没有加载时, 会调用vmclear命令(操作数为struct vmcs地址), 用于对该VMCS区域初始化, 包括将数据填充到VMCS区域和将VMCS状态(不可见字段)置为clear
 |   |   |   |   |   |   └─ list_add(&vmx->loaded_vmcs->loaded_vmcss_on_cpu_link, &per_cpu(loaded_vmcss_on_cpu, cpu)); // 没有加载时, 相应cpu上的loaded_vmcs链表
 |   |   |   |   |   ├─ per_cpu(current_vmcs, cpu) = vmx->loaded_vmcs->vmcs; // 赋值cpu的current_vmcs
 |   |   |   |   |   ├─ vmcs_load(vmx->loaded_vmcs->vmcs); // vmptrld指令, 加载这个vmcs为current-VMCS
 |   |   |   |   |   |   ├─ kvm_make_request(KVM_REQ_TLB_FLUSH, vcpu); // 
 |   |   |   |   |   |   ├─ vmcs_writel(HOST_TR_BASE, (unsigned long)&get_cpu_entry_area(cpu)->tss.x86_tss); // 没加载时, 写VMCS的TSS
 |   |   |   |   |   |   ├─ vmcs_writel(HOST_GDTR_BASE, (unsigned long)gdt);   // 没加载时, 写GDT
 |   |   |   |   |   |   └─  vmx->loaded_vmcs->cpu = cpu; // 没加载时, 关联CPU
 |   |   ├─ vcpu_load(vcpu);  // 加载vcpu信息<参数为kvm_vcpu>, struct vmx_vcpu(vcpu的一个运行环境)加载
 |   |   |   ├─ kvm_arch_vcpu_load(vcpu, cpu)
 |   |   |   |   ├─ static_call(kvm_x86_vcpu_load)(vcpu, cpu); // 实际调用vmx.c的 vmx_vcpu_load(), 见上面 
```

调用了两处

```cpp
int kvm_arch_vcpu_create(struct kvm_vcpu *vcpu)
{
        ......
        // 创建vcpu, 架构相关
        r = static_call(kvm_x86_vcpu_create)(vcpu);
        ......
        // 加载vcpu
        vcpu_load(vcpu);
}
```

1. 架构相关的创建vcpu

```cpp
static int vmx_create_vcpu(struct kvm_vcpu *vcpu)
{
        struct vcpu_vmx *vmx;
        int cpu;

        vmx = to_vmx(vcpu);
        ......
        // 分配并初始化了这个vcpu对应的vmcs01
        err = alloc_loaded_vmcs(&vmx->vmcs01);
        ......
        // 非嵌套下, 当前vcpu使用的vmcs等于vmcs01
        vmx->loaded_vmcs = &vmx->vmcs01;
        // 获取当前物理cpu编号
        cpu = get_cpu();
        vmx_vcpu_load(vcpu, cpu);
        // 表示运行当前VCPU的物理CPU编号
        vcpu->cpu = cpu;
}
```

`vcpu_vmx`其实是VCPU的一个运行环境，理解为environment, 和vcpu是一对一的。通过`loaded_vmcs`和**cpu**成员将**vmcs**和**物理CPU**关联起来。而`loaded_vmcs`指向**当前vcpu使用的vmcs**. 对于非嵌套(即L1)虚拟机, `loaded_vmcs`一直指向`vmcs01`, 对于嵌套(L2), 指向另外的vmcs.

**一个VCPU**当然可以运行在**不同的物理CPU**之上，只要更换`loaded_vmcs`中**cpu编号**即可

2. 加载vcpu

```cpp
void vcpu_load(struct kvm_vcpu *vcpu)
{
        // 获取当前物理cpu编号
        int cpu = get_cpu();
        kvm_arch_vcpu_load(vcpu, cpu);
}

void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
{
        ......
        static_call(kvm_x86_vcpu_load)(vcpu, cpu);
        ......
}
```

两个最终都会调用 `vmx_vcpu_load()`

```cpp
static void vmx_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
{
        // 当前vcpu对应的vcpu_vmx
        struct vcpu_vmx *vmx = to_vmx(vcpu);
        vmx_vcpu_load_vmcs(vcpu, cpu, NULL);
}
```

```cpp
// arch/x86/kvm/vmx/vmx.c
void vmx_vcpu_load_vmcs(struct kvm_vcpu *vcpu, int cpu,
                        struct loaded_vmcs *buddy)
{
        // vcpu_vmx是vcpu的一个运行环境, 这个和vcpu是一对一的
        struct vcpu_vmx *vmx = to_vmx(vcpu);
        // loaded_vmcs指向当前vcpu使用的vmcs
        // cpu属性表示上一次运行的CPU编号
        bool already_loaded = vmx->loaded_vmcs->cpu == cpu;
        struct vmcs *prev;
        // 这个vcpu使用的vmcs上一次运行的物理cpu不等于指定的cpu
        // 说明在新的cpu上执行, 既要清理旧的, 也要处理新的
        if (!already_loaded) {
                // 清理下当前vcpu使用的vmcs
                // 包括设置launched为0, 从上次运行的物理cpu的loaded_vmcs链表删除
                loaded_vmcs_clear(vmx->loaded_vmcs);
                local_irq_disable();

                smp_rmb();
                // 添加到新的cpu的loaded_vmcs链表
                list_add(&vmx->loaded_vmcs->loaded_vmcss_on_cpu_link,
                         &per_cpu(loaded_vmcss_on_cpu, cpu));
                local_irq_enable();
        }
        // 获取 per-cpu 的 current_vmcs
        prev = per_cpu(current_vmcs, cpu);
        // 当这个VCPU正在使用VMCS和指定物理cpu的current_vmcs不相等时
        // 自然而然需要加载
        if (prev != vmx->loaded_vmcs->vmcs) {
                // 将这个VCPU正在使用VMCS赋值给指定物理CPU的current_vmcs变量
                per_cpu(current_vmcs, cpu) = vmx->loaded_vmcs->vmcs;
                // 调用 vmptrld
                vmcs_load(vmx->loaded_vmcs->vmcs);
                ......
        }
        if (!already_loaded) {
                ......
                // 设置cpu
                vmx->loaded_vmcs->cpu = cpu;
        }
}
```cpp
// arch/x86/kvm/vmx/vmx_ops.h
static inline void vmcs_load(struct vmcs *vmcs)
{
    u64 phys_addr = __pa(vmcs);

    vmx_asm1(vmptrld, "m"(phys_addr), vmcs, phys_addr);
}
```