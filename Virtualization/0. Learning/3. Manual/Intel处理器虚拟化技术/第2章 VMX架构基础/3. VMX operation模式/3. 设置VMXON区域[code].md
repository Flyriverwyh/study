
# 定义per-cpu变量

首先定义了一个 per-cpu 变量, 即每个物理CPU都会用来记录自己的信息.

```cpp
// arch/x86/kvm/vmx/vmcs.h
// 使用位域, 一共是32位, 4字节
// bits[30:0]是id, 
// bits[31]是shadow
struct vmcs_hdr {
    u32 revision_id:31;
    u32 shadow_vmcs:1;
};

struct vmcs {
    // 32位, 4字节
    struct vmcs_hdr hdr;
    // 32位, 4字节
    u32 abort;
    // 不算大小
    char data[];
};

#define DEFINE_PER_CPU(type, name)                  \
    DEFINE_PER_CPU_SECTION(type, name, "")

// arch/x86/kvm/vmx/vmx.c
// 定义了 per-cpu 变量
static DEFINE_PER_CPU(struct vmcs *, vmxarea);
```

VMXON 区域的**首8个字节**与**VMCS区域**一样. 所以这里使用了 vmcs 结构体, 也是因为这两者的共通处.

# 模块初始化时分配并初始化

在 `kvm_intel` 模块初始化时, 分配了 VMXON 域并初始化

```cpp
vmx_init()                               // 模块初始化入口
 ├─ kvm_init(KVM_GET_API_VERSION)        // 初始化KVM框架
 |   ├─ kvm_arch_init()                  // 架构相关初始化
 |   ├─ kvm_arch_hardware_setup()         // 
 |   |   ├─ kvm_x86_ops->hardware_setup() // 硬件相关的构建
 |   |   |  ├─ setup_vmcs_config(&vmcs_config, &vmx_capability) // 设置了全局变量 vmcs_config 和 vmx_capability
 |   |   |  └─ alloc_kvm_area()           // 给每个物理cpu分配一个struct vmcs
```

## vmcs_config 的构建

`setup_vmcs_config` 就先设置了**全局变量** `vmcs_config` 和 `vmx_capability`, 这里面就包含了对 `IA32_VMX_BASIC MSR` 的读取判断, 后面会利用这个信息**初始化 VMXON 域**.

这里只简单看下, 具体的到 `2.5.4` 时候解释

```cpp
// arch/x86/kvm/vmx/vmx.c
static __init int setup_vmcs_config(struct vmcs_config *vmcs_conf,
                                    struct vmx_capability *vmx_cap)
{
        memset(vmcs_conf, 0, sizeof(*vmcs_conf));
        ......
        // 读取 MSR_IA32_VMX_BASIC MSR
        rdmsr(MSR_IA32_VMX_BASIC, vmx_msr_low, vmx_msr_high);

        /* IA-32 SDM Vol 3B: VMCS size is never greater than 4kB. */
        // VMCS 的大小不会大于 4KB
        if ((vmx_msr_high & 0x1fff) > PAGE_SIZE)
                return -EIO;

#ifdef CONFIG_X86_64
        /* IA-32 SDM Vol 3B: 64-bit CPUs always have VMX_BASIC_MSR[48]==0. */
        // 64位CPU的 VMX_BASIC_MSR[48] 必须为 0
        if (vmx_msr_high & (1u<<16))
                return -EIO;
#endif

        /* Require Write-Back (WB) memory type for VMCS accesses. */
        // 内存类型必须是 WB
        if (((vmx_msr_high >> 18) & 15) != 6)
                return -EIO;
        // 根据 MSR_IA32_VMX_BASIC MSR 
        // 检查设置 size 、 页大小order 和 revision id
        vmcs_conf->size = vmx_msr_high & 0x1fff;
        // 
        vmcs_conf->order = get_order(vmcs_conf->size);
        vmcs_conf->revision_id = vmx_msr_low;
        ......
}
```

从 `MSR_IA32_VMX_BASIC MSR` 获取`VMCS ID`值和 区域大小

## 分配 VMXON 区域并初始化

然后为**每个物理 CPU** 分配一个 VMXON 区域空间并初始化

```cpp
// arch/x86/kvm/vmx/vmx.c
// 两个全局变量
struct vmcs_config vmcs_config;
struct vmx_capability vmx_capability;

static __init int alloc_kvm_area(void)
{
        int cpu;
        // 对于每个物理CPU
        for_each_possible_cpu(cpu) {
                struct vmcs *vmcs;
                // 分配vmcs结构体, 实际上就是vmxon域
                vmcs = alloc_vmcs_cpu(false, cpu, GFP_KERNEL);
                if (!vmcs) {
                        free_kvm_area();
                        return -ENOMEM;
                }

                /*
                 * When eVMCS is enabled, alloc_vmcs_cpu() sets
                 * vmcs->revision_id to KVM_EVMCS_VERSION instead of
                 * revision_id reported by MSR_IA32_VMX_BASIC.
                 *
                 * However, even though not explicitly documented by
                 * TLFS, VMXArea passed as VMXON argument should
                 * still be marked with revision_id reported by
                 * physical CPU.
                 */
                if (static_branch_unlikely(&enable_evmcs))
                        vmcs->hdr.revision_id = vmcs_config.revision_id;

                per_cpu(vmxarea, cpu) = vmcs;
        }
        return 0;
}

struct vmcs *alloc_vmcs_cpu(bool shadow, int cpu, gfp_t flags)
{
        int node = cpu_to_node(cpu);
        struct page *pages;
        struct vmcs *vmcs;
        // per-cpu的, 常用, 所以从CPU所在的node分配
        // 分配页面, vmcs_config.order 就是
        pages = __alloc_pages_node(node, flags, vmcs_config.order);
        if (!pages)
                return NULL;
        // 返回虚拟地址
        vmcs = page_address(pages);
        // 全部置为 0
        memset(vmcs, 0, vmcs_config.size);

        /* KVM supports Enlightened VMCS v1 only */
        if (static_branch_unlikely(&enable_evmcs))
                vmcs->hdr.revision_id = KVM_EVMCS_VERSION;
        else
                // revision id 等于 IA32_VMX_BASIC[31:0]
                vmcs->hdr.revision_id = vmcs_config.revision_id;

        if (shadow)
                vmcs->hdr.shadow_vmcs = 1;
        return vmcs;
}
```

直接分配了页面, 所以肯定是 4KB 边界对齐的; 



### 1.1.2. 创建虚拟机阶段

> 如果能走到创建虚拟机, 说明模块初始化成功, 也就是上面的判断通过了

在**创建虚拟机过程**中, 会对所有物理CPU都会开启虚拟化功能

```cpp
用户态ioctl(fd,KVM_CREATE_VM,..)
kvm_dev_ioctl() // kvm ioctl 指令入口
 ├─ kvm_dev_ioctl_create_vm() // 创建虚拟机
 |   ├─ kvm_create_vm() // 实现虚拟机创建的主要函数
 |   |   ├─ hardware_enable_all() // 使能硬件，架构相关操作
 |   |   |   └─ on_each_cpu(hardware_enable_nolock, NULL, 1); // 对所有cpu调用hardware_enable_nolock方法, 从 hardware_enable_all 调用过来的话只会执行一次
 |   |   |       └─ kvm_arch_hardware_enable() //  
 |   |   |           ├─ static_call(kvm_x86_hardware_enable)() // 打开硬件功能, 会调用 vmxon 指令
 |   |   |           |   ├─ kvm_cpu_vmxon()  // vmxon打开VMX模式
```

注: 这里的 `static_call(kvm_x86_hardware_enable)()` 是通过 `arch/x86/include/asm/kvm-x86-ops.h` 中的 `KVM_X86_OP()` 或 `KVM_X86_OP_NULL()`实现的, 所以 `kvm_x86_hardware_enable` 对应的就是不同架构的 `hardware_enable` 函数.

```cpp
// arch/x86/kvm/vmx/vmx.c
static int hardware_enable(void)
{
        // 当前cpu
        int cpu = raw_smp_processor_id();
        // per_cpu变量
        // 将其转为物理地址
        u64 phys_addr = __pa(per_cpu(vmxarea, cpu));
        ......
        r = kvm_cpu_vmxon(phys_addr);
        if (r) {
                intel_pt_handle_vmx(0);
                return r;
        }
        ......
        return 0;
}

static int kvm_cpu_vmxon(u64 vmxon_pointer)
{
        u64 msr;

        cr4_set_bits(X86_CR4_VMXE);

        asm_volatile_goto("1: vmxon %[vmxon_pointer]\n\t"
                          _ASM_EXTABLE(1b, %l[fault])
                          : : [vmxon_pointer] "m"(vmxon_pointer)
                          : : fault);
        return 0;

fault:
        WARN_ONCE(1, "VMXON faulted, MSR_IA32_FEAT_CTL (0x3a) = 0x%llx\n",
                  rdmsrl_safe(MSR_IA32_FEAT_CTL, &msr) ? 0xdeadbeef : msr);
        cr4_clear_bits(X86_CR4_VMXE);

        return -EFAULT;
}
```