
在虚拟化平台上, 可能**只有一份VMM**存在, 但可以有**多个VM实例**存在. **每个VM**需要有**对应的VMCS**(虚拟机控制结构)区域来控制, 而**VMM本身**也需要**一个VMXON区域**来进行一些记录或维护工作.

```x86asm
vmxon [ebp + PCB.VmxonPhysicalPointer]
```

如上面, 执行VMXON指令, 需要提供一个VMXON指针作为操作数, 这个指针是物理地址, 指向VMXON区域.

# 分配VMXON区域

执行VMXON指令进入VMX operation模式前, 需要分配一块物理内存区域作为VMXON区域. 这块物理内存区域需要对齐在4K字节边界上. VMXON区域的大小和内存cache类型可以通过检查IA32\_VMX\_BASIC寄存器来获得.

```x86asm
        ;;
        ;; 分配 VMXON region
        ;;
        call get_vmcs_access_pointer                    ; edx:eax = pa:va
        REX.Wrxb
        mov [ebp + PCB.VmxonPointer], eax
        REX.Wrxb
        mov [ebp + PCB.VmxonPhysicalPointer], edx
```

如上代码所示, 在初始化 VMXON 区域阶段 `initialize_vmxon_region` 函数里调用 `get_vmcs_access_pointer` 来分配 VMXON 区域, 返回的物理地址保存在 `PCB.VmxonPhysicalPointer` 值里, 虚拟地址保存在 `PCB.VmxonPointer` 值里.

# VMXON区域初始设置

VMXON 区域的首 8 个字节结构与 VMCS 区域是一样的, 首4个字节为 `VMCS ID` 值, 下一个 DWORD 位置是 `VMX-abort indicator` 字段, 存放 `VMX-abort` 发生后的ID值, 如图.

![config](./images/3.png)

这个 `VMCS ID` 值可以从 `IA32_VMX_BASICI[31:0]` 来获得，执行 VMXON 指令前必须将这个 `VMCS ID` 值写入 VMXON 区域首 DWORD 位置。如果 `VMCS ID` 值与处理器当前 VMX 版本下的 VMCS ID 值不符，则产生 `VmfailInvalid` 失败（参见第 2.6.2 节），此时 `CF=1`, 指示 VMCS 指针无效。



