

按时间顺序:

* 32ad73db7fc5fe7eebafdab3b528f99ab8498e3f: x86/msr-index: Clean up bit defines for IA32_FEATURE_CONTROL MSR
* 21bd3467a58ea51ccc0b1d9bcb86dadf1640a002: KVM: VMX: Drop initialization of IA32_FEAT_CTL MSR
* a4d0b2fdbcf75ef6654713c83c316ea3a661ddc3: KVM: VMX: Use VMX feature flag to query BIOS enabling


```cpp
// arch/x86/include/asm/msr-index.h
#define MSR_IA32_FEAT_CTL       0x0000003a
#define FEAT_CTL_LOCKED             BIT(0)
#define FEAT_CTL_VMX_ENABLED_INSIDE_SMX     BIT(1)
#define FEAT_CTL_VMX_ENABLED_OUTSIDE_SMX    BIT(2)
```

在第二个patch之前(即21bd3467a58ea51ccc0b1d9bcb86dadf1640a002之前), 实现是这样的

```cpp
vmx_init()                               // 初始化入口
 ├─ kvm_init(KVM_GET_API_VERSION)        // 初始化KVM框架
 |   ├─ kvm_arch_init()                  // 架构相关初始化
 |   |   ├─ vmx_disabled_by_bios()        // bios是否禁用vt, vmx.c
 |   ├─ kvm_arch_hardware_setup()        // 
 |   |   ├─ kvm_x86_ops->hardware_setup() // CPU是否支持kvm 
 |   |   |  ├─ rdmsrl_safe()              // 读msr
 |   |   |  ├─ store_idt()                // 保存idt
 |   |   |  ├─ setup_vmcs_config()        // 建立vmcs_config和vmx_capability
 |   |   |  ├─ boot_cpu_has()             // CPU特性支持
 |   |   |  ├─ cpu_has_vmx_vpid()         // cpu是否支持vpid
 |   |   |  ├─ cpu_has_vmx_invvpid()      // cpu是否支持invvpid
 |   |   |  ├─ cpu_has_vmx_ept()          // cpu是否支持ept
 |   |   |  ├─ kvm_configure_mmu()       // mmu相关硬件判断和全局变量
 |   |   |  ├─ cpu_has_vmx_XXX()          // cpu是否有XXX
 |   |   |  ├─ vmx_enable_tdp()           // ept支持时开启tdp
 |   |   |  ├─ kvm_disable_tdp()          // 关闭tdp
 |   |   |  ├─ kvm_set_posted_intr_wakeup_handler()     // posted intr wakeup handler
 |   |   |  └─ alloc_kvm_area()           // 给每个cpu分配一个struct vmcs

// arch/x86/kvm/vmx/vmx.c
static __init int vmx_disabled_by_bios(void)
{
        u64 msr;

        rdmsrl(MSR_IA32_FEAT_CTL, msr);
        if (msr & FEAT_CTL_LOCKED) {
                /* launched w/ TXT and VMX disabled */
                if (!(msr & FEAT_CTL_VMX_ENABLED_INSIDE_SMX)
                        && tboot_enabled())
                        return 1;
                /* launched w/o TXT and VMX only enabled w/ TXT */
                if (!(msr & FEAT_CTL_VMX_ENABLED_OUTSIDE_SMX)
                        && (msr & FEAT_CTL_VMX_ENABLED_INSIDE_SMX)
                        && !tboot_enabled()) {
                        printk(KERN_WARNING "kvm: disable TXT in the BIOS or "
                                "activate TXT before enabling KVM\n");
                        return 1;
                }
                /* launched w/o TXT and VMX disabled */
                if (!(msr & FEAT_CTL_VMX_ENABLED_OUTSIDE_SMX)
                        && !tboot_enabled())
                        return 1;
        }

        return 0;
}

static int hardware_enable(void)
{
        ......
        rdmsrl(MSR_IA32_FEAT_CTL, old);
 
        test_bits = FEAT_CTL_LOCKED;
        test_bits |= FEAT_CTL_VMX_ENABLED_OUTSIDE_SMX;
        if (tboot_enabled())
                test_bits |= FEAT_CTL_VMX_ENABLED_INSIDE_SMX;
 
        if ((old & test_bits) != test_bits) {
                /* enable and lock */
                wrmsrl(MSR_IA32_FEAT_CTL, old | test_bits);
        }
        kvm_cpu_vmxon(phys_addr);
        ......
}
```







目前, 在系统启动阶段, `IA32_FEATURE_CONTROL MSR`会在所有**支持VMX**的cpu启动时被初始化, 即在**所有可能加载kvm_intel的cpu上**. 所以就不需要在 `kvm_intel` 模块初始化时候对 `IA32_FEATURE_CONTROL` 寄存器不进行手动代码检查, 而是检查boot CPU的 `X86_FEATURE_MSR_IA32_FEAT_CTL` 和 `VMX` 这两个feature flag. 

`X86_FEATURE_MSR_IA32_FEAT_CTL` 表明 `IA32_FEATURE_CONTROL` 已经被配置好了, 并且它所依赖的特性也是正确的. 比如, 如果 VMX 没有通过 `IA32_FEATURE_CONTROL` 完全启用，那么VMX flag在boot期间会被清除，包括不支持 `IA32_FEATURE_CONTROL` 的情况。

```cpp
// arch/x86/kernel/cpu/feat_ctl.c
void init_ia32_feat_ctl(struct cpuinfo_x86 *c)
{
        bool tboot = tboot_enabled();
        bool enable_sgx;
        u64 msr;
        // 读取 IA32_FEATURE_CONTROL 寄存器值, 存到msr中
        if (rdmsrl_safe(MSR_IA32_FEAT_CTL, &msr)) {
                // 当不支持这个 MSR时, 清理 VMX flag 
                clear_cpu_cap(c, X86_FEATURE_VMX);
                return;
        }

        if (msr & FEAT_CTL_LOCKED)
                goto update_caps;

        /*
         * Ignore whatever value BIOS left in the MSR to avoid enabling random
         * features or faulting on the WRMSR.
         */
        msr = FEAT_CTL_LOCKED;

        /*
         * Enable VMX if and only if the kernel may do VMXON at some point,
         * i.e. KVM is enabled, to avoid unnecessarily adding an attack vector
         * for the kernel, e.g. using VMX to hide malicious code.
         */
        if (cpu_has(c, X86_FEATURE_VMX) && IS_ENABLED(CONFIG_KVM_INTEL)) {
                msr |= FEAT_CTL_VMX_ENABLED_OUTSIDE_SMX;

                if (tboot)
                        msr |= FEAT_CTL_VMX_ENABLED_INSIDE_SMX;
        }

        if (enable_sgx)
                msr |= FEAT_CTL_SGX_ENABLED | FEAT_CTL_SGX_LC_ENABLED;

        wrmsrl(MSR_IA32_FEAT_CTL, msr);

caps:
        set_cpu_cap(c, X86_FEATURE_MSR_IA32_FEAT_CTL);

        if (!cpu_has(c, X86_FEATURE_VMX))
                goto update_sgx;

        if ( (tboot && !(msr & FEAT_CTL_VMX_ENABLED_INSIDE_SMX)) ||
            (!tboot && !(msr & FEAT_CTL_VMX_ENABLED_OUTSIDE_SMX))) {
                if (IS_ENABLED(CONFIG_KVM_INTEL))
                        pr_err_once("VMX (%s TXT) disabled by BIOS\n",
                                    tboot ? "inside" : "outside");
                clear_cpu_cap(c, X86_FEATURE_VMX);
        } else {
#ifdef CONFIG_X86_VMX_FEATURE_NAMES
                init_vmx_capabilities(c);
#endif
        }
```


```cpp
// arch/x86/include/asm/cpufeature.h
#define X86_FEATURE_MSR_IA32_FEAT_CTL   ( 7*32+31) /* "" MSR IA32_FEAT_CTL configured */

#define boot_cpu_has(bit)   cpu_has(&boot_cpu_data, bit)

// arch/x86/kvm/vmx/vmx.c
static __init int vmx_disabled_by_bios(void)
{
        return !boot_cpu_has(X86_FEATURE_MSR_IA32_FEAT_CTL) ||
               !boot_cpu_has(X86_FEATURE_VMX);
}


```

