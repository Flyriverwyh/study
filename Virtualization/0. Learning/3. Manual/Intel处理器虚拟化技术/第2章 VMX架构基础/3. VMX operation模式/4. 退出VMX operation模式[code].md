
# 模块初始化

在模块初始化阶段, 定义了vCPU状态变化时候的回调函数以及系统发生suspend时候的回调函数

```cpp
vmx_init()/svm_init()/arm_init()         // 初始化入口
 ├─ kvm_init(KVM_GET_API_VERSION)        // 初始化KVM框架
 |   ├─ cpuhp_setup_state_nocalls(CPUHP_AP_KVM_STARTING, "kvm/cpu:starting",kvm_starting_cpu, kvm_dying_cpu);      // 注册cpu状态变化(包括热插拔)的回调函数
 |   ├─ register_reboot_notifier()       // 注册reboot时候的回调函数
 |   ├─ register_syscore_ops(&kvm_syscore_ops) // 注册系统核心函数, 这里是系统发生suspend和resume时候的回调
 ├─
```

对应的就是 `kvm_dying_cpu()` 和 `kvm_suspend()`:

* `kvm_dying_cpu()`: vCPU热拔时候的回调函数
* `kvm_suspend()`: 在host操作系统的 suspend 中被调用

# 退出 VMX operation 模式

```cpp
kvm_dying_cpu()/kvm_suspend()            // 入口
 ├─ hardware_disable_nolock()        // 禁掉硬件功能
 |   ├─ kvm_arch_hardware_disable()                  // 
 |   |   ├─ static_call(kvm_x86_hardware_disable)();  // 对于vmx来说就是 hardware_disable
 |   |   |   ├─ vmclear_local_loaded_vmcss();        // 
 |   |   |   ├─ vcpu_vmxoff()       // 
 |   |   |   └─ intel_pt_handle_vmx(0); // 
```

`kvm_x86_hardware_disable` 对应的就是不同架构的 `hardware_disable` 函数.

```cpp
// arch/x86/kvm/vmx/vmx.c
static void hardware_disable(void)
{
        vmclear_local_loaded_vmcss();

        if (cpu_vmxoff())
                kvm_spurious_fault();

        intel_pt_handle_vmx(0);
}

static void vmclear_local_loaded_vmcss(void)
{
        int cpu = raw_smp_processor_id();
        struct loaded_vmcs *v, *n;

        list_for_each_entry_safe(v, n, &per_cpu(loaded_vmcss_on_cpu, cpu),
                                 loaded_vmcss_on_cpu_link)
                __loaded_vmcs_clear(v);
}

// arch/x86/include/asm/virtext.h
static inline int cpu_vmxoff(void)
{
    asm_volatile_goto("1: vmxoff\n\t"
              _ASM_EXTABLE(1b, %l[fault])
              ::: "cc", "memory" : fault);
    // 清理掉 CR4.VMXE
    cr4_clear_bits(X86_CR4_VMXE);
    return 0;

fault:
    cr4_clear_bits(X86_CR4_VMXE);
    return -EIO;
}
```