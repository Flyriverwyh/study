

执行VMXON指令的基本要求是:

* 需要开启`CR4.VMXE`位, 不能在实模式, `virtual-8086`以及兼容模式下进行, 否则将产生`#UD`异常;

* 不能在非0级权限下执行, 否则将产生`#GP`异常.

# IA32_FEATURE_CONTROL 寄存器

`IA32_FEATURE_CONTROL` 寄存器也影响着 VMXON 指令的执行，这个寄存器的 `bit 0` 为 lock 位，bit 1 与 bit 2 分别是 **SMX** 模式的 **inside** 与 **outside** 位。inside 位指示允许在 SMX 内使用 VMX, outside 位指示允许在 SMX 外使用 VMX（这是开启 VMX 模式最基本的条件）。

(1) 当 lock 位为 0 时(`bit 0`)，**执行 VMXON 指令**将产生 `#GP` 异常。因此，**执行 VMXON 指令前**必须确保 lock 位为 **1** 值，也就是锁上 `IA32_FEATURE_CONTROL` 寄存器。上锁后如果对 `IA32_FEATURE_CONTROL` 寄存器进行写操作，将产生 `#GP` 异常。

(2) Enable VMX inside SMX 位（`bit 1`），指示当处理器处于 `SMX` (**Safer Mode Extensions**）模式**时**，允许开启 VMX operation 模式。当 `inside=0` 且**处于 SMX 模式时**，执行 VMXON 指令将引发 `#GP` 异常。

(3) Enable VMX outside SMX 位（bit 2），指示允许在 **SMX 模式之外**开启 VMX  operation 模式。当 **outside=0** 且**不在 SMX 模式**时，执行 VMXON 指令将引发 `#GP` 异常。

只有支持 VMX 与 SMX 模式时，允许对 bit 1 置位（即 `CPUID.01H:ECX[6:5]=11B`）。在支持 VMX 模式时，才允许对 bit 2 置位（即 `CPUID.01H:ECX[5]=1`).

注意：“`Enable VMX outside SMX`”位需要**置位**，这是运行 VMX 模式的**基本条件**。bit1 与 bit2 允许同时置位，此时表示无论是 SMX 模式内还是模式外都可以开启 VMX 模式.

下面的代码片段来自 `lib\system_data_manage.asm` 里的 `get_vmx_global_data` 函数，用来收集和分析 VMX 的数据：

```x86asm
        ;;
        ;; 关于 IA32_FEATURE_CONTROL.lock 位：
        ;; 1) 当 lock = 0 时，执行 VMXON 产生 #GP 异常
        ;; 2) 当 lock = 1 时，写 IA32_FEATURE_CONTROL 寄存器产生 #GP 异常
        ;;
        
        ;;
        ;; 下面将检查 IA32_FEATURE_CONTROL 寄存器
        ;; 1) 当 lock 位为 0 时，需要进行一些设置，然后锁上 IA32_FEATURE_CONTROL
        ;;        
        mov ecx, IA32_FEATURE_CONTROL
        rdmsr
        bts eax, 0                                                      ; 检查 lock 位，并上锁
        jc get_vmx_global_data.@7
        
        ;; lock 未上锁时：
        ;; 1) 对 lock 置位（锁上 IA32_FEATURE_CONTROL 寄存器）
        ;; 2) 对 bit 2 置位（启用 enable VMXON outside SMX）
        ;; 3) 如果支持 enable VMXON inside SMX 时，对 bit 1 置位!
        ;; 
        mov esi, 6                                                      ; enable VMX outside SMX = 1, enable VMX inside SMX = 1
        mov edi, 4                                                      ; enable VMX outside SMX = 1, enable VMX inside SMX = 0
        
        ;;
        ;; 检查是否支持 SMX 模式
        ;;
        test DWORD [gs: PCB.FeatureEcx], CPU_FLAGS_SMX
        cmovz esi, edi        
        or eax, esi
        wrmsr
        
                
get_vmx_global_data.@7:        

        ;;
        ;; 假如使用 enable VMX inside SMX 功能，则根据 IA32_FEATURE_CONTROL[1] 来决定是否必须开启 CR4.SMXE
        ;; 1) 本书例子中没有开启 CR4.SMXE
        ;;
%ifdef ENABLE_VMX_INSIDE_SMX
        ;;
        ;; ### step 7: 设置 Cr4FixedMask 的 CR4.SMXE 位 ###
        ;;
        ;; 再次读取 IA32_FEATURE_CONTROL 寄存器
        ;; 1) 检查 enable VMX inside SMX 位（bit1）
        ;;    1.1) 如果是 inside SMX（即 bit1 = 1），则设置 CR4FixedMask 位的相应位
        ;; 
        rdmsr
        and eax, 2                                                      ; 取 enable VMX inside SMX 位的值（bit1）
        shl eax, 13                                                     ; 对应在 CR4 寄存器的 bit 14 位（即 CR4.SMXE 位）
        or DWORD [ebp + PCB.Cr4FixedMask], eax                          ; 在 Cr4FixedMask 里设置 enable VMX inside SMX 位的值　        
        
%endif
```

这段代码检查 `IA32_FEATURE_CONTROL` 寄存器的 lock 位是否为 1。不为 1 时，需要上锁，并对“Enable VMX outside SMX”置位，同时根据 `CPUID.01H:EDX[6].SMX` 位来设置“Enable VMX inside SMX”位。

在定义了 `ENABLE_VMX_INSIDE_SMX` 符号时，接下来分析是否启用“Enable VMX inside SMX”，如果是，那么 `Cr4FixedMask` 的值需要添加 `CR4.SMXE` 位（需要为 1 值）, 也就是必须要开启 SMX模式。本书中没有开启 CR4.SMXE 位。


............


