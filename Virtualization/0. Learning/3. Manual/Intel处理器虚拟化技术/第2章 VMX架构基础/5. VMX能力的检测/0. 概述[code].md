

# 1. vmcs_config 变量的构建

`setup_vmcs_config` 就先设置了**全局变量** `vmcs_config` 和 `vmx_capability`, 这里面就包含了对 `IA32_VMX_BASIC MSR` 的读取判断

```cpp
// arch/x86/kvm/vmx/capabilities.h
struct vmcs_config {
    int size;
    int order;
    u32 basic_cap;
    u32 revision_id;
    u32 pin_based_exec_ctrl;
    u32 cpu_based_exec_ctrl;
    u32 cpu_based_2nd_exec_ctrl;
    u32 vmexit_ctrl;
    u32 vmentry_ctrl;
    struct nested_vmx_msrs nested;
};

struct vmx_capability {
    u32 ept;
    u32 vpid;
};

// arch/x86/kvm/vmx/vmx.c
// 两个全局变量
struct vmcs_config vmcs_config;
struct vmx_capability vmx_capability;
```

结构体基本上说明了这一章的内容

# 2. 模块初始化时初始化

因为是虚拟化能力的检测, 所以在 `kvm_intel` 模块初始化阶段进行

```cpp
vmx_init()                               // 模块初始化入口
 ├─ kvm_init(KVM_GET_API_VERSION)        // 初始化KVM框架
 |   ├─ kvm_arch_init()                  // 架构相关初始化
 |   |   ├─ cpu_has_kvm_support()         // CPU是否支持kvm, vmx.c
 |   |   |   ├─ cpu_has_vmx()         // CPU是否支持kvm
 |   ├─ kvm_arch_hardware_setup()         // 
 |   |   ├─ kvm_x86_ops->hardware_setup() // 硬件相关的构建
 |   |   |  ├─ setup_vmcs_config(&vmcs_config, &vmx_capability) // 设置了全局变量 vmcs_config 和 vmx_capability
```

## 检测是否支持VMX

`cpu_has_vmx()`中

## 基本信息检测

`setup_vmcs_config()`