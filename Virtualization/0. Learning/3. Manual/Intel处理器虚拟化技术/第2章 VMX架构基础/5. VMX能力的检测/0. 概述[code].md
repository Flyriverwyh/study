

# 1. 系统初始化

x86/cpu: Detect VMX features on Intel, Centaur and Zhaoxin CPUs, b47ce1fed42eeb9ac8c07fcda6c795884826723d

x86/cpu: Set synthetic VMX cpufeatures during init_ia32_feat_ctl(), 167a4894c113ebe6a1f8b24fa6f9fca849c77f8a

```cpp
// arch/x86/kernel/cpu/feat_ctl.c
void init_ia32_feat_ctl(struct cpuinfo_x86 *c)
{
        ......
#ifdef CONFIG_X86_VMX_FEATURE_NAMES
        // 一切顺利的话, 在这里会初始化 vmx 的能力
        init_vmx_capabilities(c);
#endif
}

#ifdef CONFIG_X86_VMX_FEATURE_NAMES
enum vmx_feature_leafs {
        MISC_FEATURES = 0,
        PRIMARY_CTLS,
        SECONDARY_CTLS,
        NR_VMX_FEATURE_WORDS,
};

#define VMX_F(x) BIT(VMX_FEATURE_##x & 0x1f)
static void init_vmx_capabilities(struct cpuinfo_x86 *c)
{
        u32 supported, funcs, ept, vpid, ign;

        BUILD_BUG_ON(NVMXINTS != NR_VMX_FEATURE_WORDS);

        // 低32位(ign), 直接忽略不用
        // 高32位中为1的表明对应的控制字段相应位允许为1, 即支持某个特性

        // 这里没有考虑 TRUE 寄存器, 即没考虑 IA32_VMX_BASIC[55] = 1 的情况
        // 服务primary processor-based VM-execution control 字段
        rdmsr(MSR_IA32_VMX_PROCBASED_CTLS, ign, supported);
        c->vmx_capability[PRIMARY_CTLS] = supported;

        // 同样没有考虑 TRUE 寄存器
        // 服务secondary processor-based VM-execution control 字段
        rdmsr_safe(MSR_IA32_VMX_PROCBASED_CTLS2, &ign, &supported);
        c->vmx_capability[SECONDARY_CTLS] = supported;

        // 同样没有考虑 TRUE 寄存器
        // 服务Pin-based VM-execution control 字段
        rdmsr(MSR_IA32_VMX_PINBASED_CTLS, ign, supported);

        // 服务VM-function control 字段, 没有allowed 0-setting位
        // 没有对应的 TRUE 寄存器
        rdmsr_safe(MSR_IA32_VMX_VMFUNC, &ign, &funcs);

        // 上面三个对应的是 VM-execution control 控制字段


        rdmsr_safe(MSR_IA32_VMX_EPT_VPID_CAP, &ept, &vpid);

        /* Pin, EPT, VPID and VM-Func are merged into a single word. */
        WARN_ON_ONCE(supported >> 16);
        WARN_ON_ONCE(funcs >> 4);
        c->vmx_capability[MISC_FEATURES] = (supported & 0xffff) |
                                           ((vpid & 0x1) << 16) |
                                           ((funcs & 0xf) << 28);

        /* EPT bits are full on scattered and must be manually handled. */
        if (ept & VMX_EPT_EXECUTE_ONLY_BIT)
                c->vmx_capability[MISC_FEATURES] |= VMX_F(EPT_EXECUTE_ONLY);
        if (ept & VMX_EPT_AD_BIT)
                c->vmx_capability[MISC_FEATURES] |= VMX_F(EPT_AD);
        if (ept & VMX_EPT_1GB_PAGE_BIT)
                c->vmx_capability[MISC_FEATURES] |= VMX_F(EPT_1GB);

        /* Synthetic APIC features that are aggregates of multiple features. */
        if ((c->vmx_capability[PRIMARY_CTLS] & VMX_F(VIRTUAL_TPR)) &&
            (c->vmx_capability[SECONDARY_CTLS] & VMX_F(VIRT_APIC_ACCESSES)))
                c->vmx_capability[MISC_FEATURES] |= VMX_F(FLEXPRIORITY);

        if ((c->vmx_capability[PRIMARY_CTLS] & VMX_F(VIRTUAL_TPR)) &&
            (c->vmx_capability[SECONDARY_CTLS] & VMX_F(APIC_REGISTER_VIRT)) &&
            (c->vmx_capability[SECONDARY_CTLS] & VMX_F(VIRT_INTR_DELIVERY)) &&
            (c->vmx_capability[MISC_FEATURES] & VMX_F(POSTED_INTR)))
                c->vmx_capability[MISC_FEATURES] |= VMX_F(APICV);

        /* Set the synthetic cpufeatures to preserve /proc/cpuinfo's ABI. */
        if (c->vmx_capability[PRIMARY_CTLS] & VMX_F(VIRTUAL_TPR))
                set_cpu_cap(c, X86_FEATURE_TPR_SHADOW);
        if (c->vmx_capability[MISC_FEATURES] & VMX_F(FLEXPRIORITY))
                set_cpu_cap(c, X86_FEATURE_FLEXPRIORITY);
        if (c->vmx_capability[MISC_FEATURES] & VMX_F(VIRTUAL_NMIS))
                set_cpu_cap(c, X86_FEATURE_VNMI);
        if (c->vmx_capability[SECONDARY_CTLS] & VMX_F(EPT))
                set_cpu_cap(c, X86_FEATURE_EPT);
        if (c->vmx_capability[MISC_FEATURES] & VMX_F(EPT_AD))
                set_cpu_cap(c, X86_FEATURE_EPT_AD);
        if (c->vmx_capability[MISC_FEATURES] & VMX_F(VPID))
                set_cpu_cap(c, X86_FEATURE_VPID);
}
```

# 2. 模块初始化时初始化

## 2.1. vmcs_config 变量的构建

KVM使用了两个**全局变量** `vmcs_config` 和 `vmx_capability`, 用来配置和表示VMX的能力

```cpp
// arch/x86/kvm/vmx/capabilities.h
struct vmcs_config {
    int size;
    int order;
    u32 basic_cap;
    u32 revision_id;
    u32 pin_based_exec_ctrl;
    u32 cpu_based_exec_ctrl;
    u32 cpu_based_2nd_exec_ctrl;
    u32 vmexit_ctrl;
    u32 vmentry_ctrl;
    struct nested_vmx_msrs nested;
};

struct vmx_capability {
    u32 ept;
    u32 vpid;
};

// arch/x86/kvm/vmx/vmx.c
// 两个全局变量
struct vmcs_config vmcs_config;
struct vmx_capability vmx_capability;
```

结构体基本上说明了这一章的内容

## 2.2. 整体流程
因为是虚拟化能力的检测, 所以在 `kvm_intel` 模块初始化阶段进行

```cpp
vmx_init()                               // 模块初始化入口
 ├─ kvm_init(KVM_GET_API_VERSION)        // 初始化KVM框架
 |   ├─ kvm_arch_init()                  // 架构相关初始化
 |   |   ├─ cpu_has_kvm_support()         // CPU是否支持kvm, vmx.c
 |   |   |   ├─ cpu_has_vmx()         // CPU是否支持kvm
 |   ├─ kvm_arch_hardware_setup()         // 
 |   |   ├─ kvm_x86_ops->hardware_setup() // 硬件相关的构建
 |   |   |  ├─ setup_vmcs_config(&vmcs_config, &vmx_capability) // 设置了全局变量 vmcs_config 和 vmx_capability
```

## 2.3. 检测是否支持VMX

`cpu_has_vmx()`中

## 2.4. 基本信息检测

`setup_vmcs_config()`







