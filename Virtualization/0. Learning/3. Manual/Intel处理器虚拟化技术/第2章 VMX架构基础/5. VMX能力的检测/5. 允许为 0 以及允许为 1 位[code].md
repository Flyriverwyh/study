
在表 2-2 里列举的**两组寄存器**（在 `IA32_VMX_BASIC[55] = 1` 时使用 **TRUE 寄存器**），共 **8 个寄存器**，它们的**结构**和**使用方法**是**一致**的，结构如图 2-7 所示。

![2021-03-22-22-06-29.png](./images/2021-03-22-22-06-29.png)

这些 64 位的寄存器**低 32 位**是 `allowed 0-setting`(**允许设置为 0**)位值，**高 32 位**是  `allowed 1-setting`（**允许设置为 1**) 位值。这**两组 32 位值**对应**一个 VMCS 区域**的 `control field`(**控制字段**)值，这些控制字段是 **32 位值**，用法如下所示。

* `bits 31:0` 的用法：当其中的位为 **0** 值时，**对应**的**控制字段相应的位**允许为 **0** 值。
* `bits 63:32` 的用法：当其中的位为 **1** 值时，对应的控制字段相应的位允许为 1 值。

> 最终形成的控制字段是 32 位.

举个例子说明，在图 2-5 的运行结果里显示，`IA32_VMX_TRUE_PINBASED_CTLS` 的低 32 位值为 `00000016h`, 高 32 位为 `0000003Fh`。它对应控制 `Pin-based control` 字段，那么表明：

(1) `00000016h`, `Pin-based control` 字段除了 `bit 1`、`bit 2` 以及 `bit 4`(值为 **16h**)不能为 0 值外，其他位都可以设置为 0 值。

(2) `0000003Fh`, `Pin-based control` 字段**只**允许 `bit 0` 到 `bit 5` 位可以设置 **1** 值，**其余位必须为 0 值**。

那么，形成 `Pin-based control` 字段的**设置要求**如图 2-8 所示

![2021-03-22-22-35-08.png](./images/2021-03-22-22-35-08.png)

从上面的 `allowed 0-setting` 与 `allowed 1-setting` 的设置来看，`bit 0` **既可以为 0 值**，**也可以为 1 值**。而 `bit 1` **只允许为 1 值**。那么代表着 Pin- based control 字段的合法设置如下。

(1) bit0、bit3 以及 bit5 可以设为 0 或 1 值。

(2) bit1、bit2 以及 bit4 只能设为 1 值。

(3) bits31:6 只能设为 0 值。

推广开来，表 2-2 中的 8 个寄存器，都使用相同的设置原理，不同的是设置的目标字段不一样。我们看到对于一个控制字段的设置：“某些位必须为 1, 某些位必须为 0

（它们属于保留位）。

注意：这些必须为 0 值的保留位被称为“default0”位，必须为 1 值的保留位被称为  defaulti”位。这与通常接触到的数据结构中的“保留位必须为 0 值”有些区别（例知 PTE 中的保留位）。

当控制字段的保留位不符合这些 default (0 和 default 值，在 VM entry 操作时，字段

的检查会失败，从而导致 VM entry 失败。