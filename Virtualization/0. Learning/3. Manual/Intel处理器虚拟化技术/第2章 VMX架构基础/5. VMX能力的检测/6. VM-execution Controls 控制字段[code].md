
先跳过


在操作系统初始化阶段

```cpp
// arch/x86/include/asm/processor.h
#define NVMXINTS                       3 /* N 32-bit words worth of info */

struct cpuinfo_x86 {
    __u32           vmx_capability[NVMXINTS];
}

// arch/x86/kernel/cpu/feat_ctl.c
void init_ia32_feat_ctl(struct cpuinfo_x86 *c)
{
        ......
#ifdef CONFIG_X86_VMX_FEATURE_NAMES
        // 一切顺利的话, 在这里会初始化 vmx 的能力
        init_vmx_capabilities(c);
#endif
}

#ifdef CONFIG_X86_VMX_FEATURE_NAMES
enum vmx_feature_leafs {
        MISC_FEATURES = 0,
        PRIMARY_CTLS,
        SECONDARY_CTLS,
        NR_VMX_FEATURE_WORDS,
};

#define VMX_F(x) BIT(VMX_FEATURE_##x & 0x1f)
static void init_vmx_capabilities(struct cpuinfo_x86 *c)
{
        u32 supported, funcs, ept, vpid, ign;

        BUILD_BUG_ON(NVMXINTS != NR_VMX_FEATURE_WORDS);

        // 低32位(ign), 直接忽略不用(allowed 0-setting)
        // 高32位(supported)中为1的表明对应的控制字段相应位允许为1, 即支持某个特性

        // 这里没有考虑 TRUE 寄存器, 即没考虑 IA32_VMX_BASIC[55] = 1 的情况
        // 服务primary processor-based VM-execution control 字段
        rdmsr(MSR_IA32_VMX_PROCBASED_CTLS, ign, supported);
        c->vmx_capability[PRIMARY_CTLS] = supported;

        // 同样没有考虑 TRUE 寄存器
        // 服务secondary processor-based VM-execution control 字段
        rdmsr_safe(MSR_IA32_VMX_PROCBASED_CTLS2, &ign, &supported);
        c->vmx_capability[SECONDARY_CTLS] = supported;

        // 同样没有考虑 TRUE 寄存器
        // 服务Pin-based VM-execution control 字段
        rdmsr(MSR_IA32_VMX_PINBASED_CTLS, ign, supported);

        // 上面三个对应的是 VM-execution control 控制字段
        // 低32位直接忽略, 高32位中为1的表明对应的位允许为1(即支持某个特性)
        ......
        /* Pin, EPT, VPID and VM-Func are merged into a single word. */
        // Pin, EPT, VPID 和 VM-Func相关信息会合并到一个单个word中
        // 这里的 supported(32位) 是 Pin-based VM-execution control的
        // 高16位应该全为 0 
        WARN_ON_ONCE(supported >> 16);
        // funcs 是 VM-Func control的
        // 
        WARN_ON_ONCE(funcs >> 4);
        // 
        c->vmx_capability[MISC_FEATURES] = (supported & 0xffff) |
                                           ((vpid & 0x1) << 16) |
                                           ((funcs & 0xf) << 28);

        ......
}
```






```cpp
// arch/x86/kvm/vmx/vmx.c
static __init int adjust_vmx_controls(u32 ctl_min, u32 ctl_opt,
                                      u32 msr, u32 *result)
{
        // 读取 msr 的值, 存放到 low 和 high 中
        rdmsr(msr, vmx_msr_low, vmx_msr_high);

```