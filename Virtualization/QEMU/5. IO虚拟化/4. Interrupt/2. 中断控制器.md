
中断虚拟化的关键在于对中断控制器的模拟，我们知道x86上中断控制器主要有旧的中断控制器PIC(intel 8259a)和适应于SMP框架的IOAPIC/LAPIC两种。

# 中断控制器的创建和初始化

考虑到中断实时性对性能的影响，**PIC和IOAPIC**的**设备模拟主要逻辑**都放到了**kvm模块**进行实现，**每个VCPU**的**LAPIC**则**完全放到kvm**中进行实现。 

**i8259控制器**和**IOAPIC**的创建和初始化由**qemu和kvm配合完成**，包括了2个方面：

- **kvm**中**设备相关数据结构初始化**
- **qemu中设备模拟的初始化**

## 中断控制器的创建

qemu代码中中断控制器的kvm内核初始化流程为：

```cpp
configure_accelerator
    |--> accel_init_machine
        |--> kvm_init
            |--> kvm_irqchip_create
                |--> kvm_vm_ioctl(s, KVM_CREATE_IRQCHIP)
                |--> kvm_init_irq_routing
```

qemu通过kvm的ioctl命令`KVM_CREATE_IRQCHIP`调用到kvm内核模块中，在内核模块中创建和初始化PIC/IOAPIC设备（创建设备对应的数据结构并将设备注册到总线上）。

```cpp
kvm_arch_vm_ioctl(s, KVM_CREATE_IRQCHIP)
    |--> kvm_pic_init                    /* i8259 初始化 */
    |--> kvm_ioapic_init                 /* ioapic 初始化 */
    |--> kvm_setup_default_irq_routing   /* 初始化缺省的IRE */
```

这一步详见KVM

qemu在kvm内核中创建完成PIC和IOAPIC后将全局变量`kvm_kernel_irqchip`置为**true**，kvm模块则将`kvm->arch.irqchip_mode` 赋值为 `KVM_IRQCHIP_KERNEL`，这样后面的`kvm_irqchip_in_kernel`返回true表示**pic芯片**放到**kvm内核模块**中实现, `kvm_ioapic_in_kernel`也返回true表示ioapic放到kvm中来模拟。

**中断处理的逻辑**放在**kvm内核模块**中进行实现，但**设备的模拟**呈现还是需要**qemu设备模拟器**来搞定，最后qemu和kvm一起配合完成快速中断处理的流程。

i8259的设备创建流程(pic还是传统的isa设备，中断是边沿触发的，master的i/o port为0x20,0x21 slave的i/o port为0xa0,0xa1)：