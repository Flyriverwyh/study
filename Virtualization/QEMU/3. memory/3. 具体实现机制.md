

# 整体概述

qemu部分的内存申请流程上可以分为三小部分，分成三小部分主要是我在看代码的时候觉得这三部分耦合性不是很大，相对而言比较独立。

众所周知，qemu起始于vl.c中的main函数，那么这三部分也按照在main函数中的调用顺序分别介绍。

# 回调函数的注册

涉及函数：`configure_accelerator() -->kvm_init()-->memory_listener_register ()`

这里所说的accelerator在这里就是kvm，初始化函数自然调用了`kvm_init`，该函数主要完成对**kvm的初始化**，包括一些常规检查如CPU个数、kvm版本等，还会通过ioctl和内核交互**创建kvm结构**，这些并非本文重点，不在赘述。在`kvm_init`函数的结尾调用了`memory_listener_register`

```cpp
memory_listener_register(&kvm_memory_listener, &address_space_memory);
memory_listener_register(&kvm_io_listener, &address_space_io);
```

通过`memory_listener_register`函数，针对**地址空间**注册了**lisenter**,lisenter本身是**一组函数表**，当**地址空间发生变化**的时候，会调用到listener中的相应函数，从而保持**内核**和**用户空间**的**内存信息的一致性**。

**虚拟机**包含有**两个地址空间**`address_space_memory`和`address_space_io`，很容易理解，正常系统也包含系统地址空间和IO地址空间。

`memory_listener_register`函数不复杂，咱们看下

```cpp
void memory_listener_register(MemoryListener *listener, AddressSpace *filter)
{
    MemoryListener *other = NULL;
    AddressSpace *as;

    listener->address_space_filter = filter;
    /*如果listener为空或者当前listener的优先级大于最后一个listener的优先级，则可以直接插入*/
    if (QTAILQ_EMPTY(&memory_listeners)
        || listener->priority >= QTAILQ_LAST(&memory_listeners,
                                             memory_listeners)->priority) {
        QTAILQ_INSERT_TAIL(&memory_listeners, listener, link);
    } else {
        /*listener按照优先级升序排列*/
        QTAILQ_FOREACH(other, &memory_listeners, link) {
            if (listener->priority < other->priority) {
                break;
            }
        }
        /*插入listener*/
        QTAILQ_INSERT_BEFORE(other, listener, link);
    }
    /*全局address_spaces-->as*/
    /*对于每个address_spaces，设置listener*/
    QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
        listener_add_address_space(listener, as);
    }
}
```

系统中可以存在**多个listener**，listener之间有着明确的**优先级关系**，通过**链表**进行组织，**链表头**是**全局**的`memory_listeners`。

```cpp
static QTAILQ_HEAD(, MemoryListener) memory_listeners
    = QTAILQ_HEAD_INITIALIZER(memory_listeners);
```

函数中，如果`memory_listeners`为空或者**当前listener**的**优先级**大于最后一个listener的优先级，即直接把当前listener插入。否则需要**挨个遍历链表**，找到**合适的位置**。具体按照优先级升序查找。

在函数最后还针对**每个address_space**，调用`listener_add_address_space`函数，该函数对其对应的`address_space`管理的**flatrange**向**KVM注册**。当然，实际上**此时address_space**尚未经过初始化，所以这里的循环其实是**空循环**。

# AddressSpace的初始化

涉及函数：`cpu_exec_init_all() memory_map_init()` 

在第一节中已经**注册了listener**，但是**addressspace尚未初始化**，本节就介绍下其初始化流程。

从上节的`configure_accelerator()`函数往下走，会执行`cpu_exec_init_all()`函数，该函数主要**初始化**了**IO地址空间**和**系统地址空间**。`memory_map_init()`函数初始化系统地址空间，有一个**全局**的**MemoryRegion**指针`system_memory`指向该区域的MemoryRegion结构。

```cpp
static void memory_map_init(void)
{
    /*为system_memory分配内存*/
    system_memory = g_malloc(sizeof(*system_memory));

    memory_region_init(system_memory, NULL, "system", UINT64_MAX);
    /*初始化全局的address_space_memory*/
    address_space_init(&address_space_memory, system_memory, "memory");

    system_io = g_malloc(sizeof(*system_io));
    memory_region_init_io(system_io, NULL, &unassigned_io_ops, NULL, "io",
                          65536);
    address_space_init(&address_space_io, system_io, "I/O");
}

memory_map_init()                    // 初始化 MemoryRegion 及其对应的 FlatView
 ├─ memory_region_init(system_memory, NULL, "system", UINT64_MAX);   // 初始化 system_memory 全局 MemoryRegion
 ├─ address_space_init(&address_space_memory, system_memory, "memory");;   // 初始化 address_space_memory 全局 AddressSpace, 将 system_memory 作为 root(根MR)
 |   ├─ QTAILQ_INIT(&as->listeners);      // 初始化该 AddressSpace 的 listeners 链表
 |   ├─ QTAILQ_INSERT_TAIL(&address_spaces, as, address_spaces_link);       // 初始化该 AddressSpace 为全局 as链表address_spaces的节点(通过as的 address_spaces_link 域)
 |   └─ address_space_update_topology(as)      // 为 AddressSpace 生成 FlatView
 |   |   ├─ MemoryRegion *physmr = memory_region_get_flatview_root(as->root);  // 获取as指向的mr 
 |   |   ├─ generate_memory_topology(physmr)   // 将 MemoryRegion 的拓扑结构渲染为 FlatRange 数组
 |   |   |   ├─ view = flatview_new(mr)     // 参数其实就是 physmr
 |   |   |   ├─ render_memory_region(&view, mr, ...) // 根据 mr 生成 view
 |   |   |   └─ flatview_simplify(&view) // 合并相邻的 FlatRange
 |   |   └─ address_space_set_flatview(as);
 |   |       ├─ address_space_update_topology_pass(AddressSpce, FlatView_old, FlatView_new) // 遍历FlatView的所有FlatRange, 也就是得到若干个 MemoryRegionSection, 将其注册到KVM
 |   |       |   └─ MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_add)        // 回调函数 region_add, 对应的是kvm_region_add()
 |   |       |   └─ kvm_region_add()        // region_add 对应的回调实现
 |   |       |       └─ kvm_set_phys_mem()  // 根据传入的 section 填充 KVMSlot
 |   |       |           └─ kvm_set_user_memory_region() // 将 QEMU 侧的内存布局注册到 KVM 中
 |   |       |               └─ kvm_ioctl(KVM_SET_USER_MEMORY_REGION)
 |   |       |
 |   └─ address_space_update_ioeventfds(as)   
 |
 ├─ memory_region_init_io(system_io, NULL, &unassigned_io_ops, NULL, "io", 65536);   // 初始化 system_io 全局 MemoryRegion
 └─ address_space_init(&address_space_io, system_io, "I/O");   // 初始化 address_space_io 全局 AddressSpace, 将 system_io 作为 root(根MR)
```

所以在函数起始，就对`system_memory`分配了内存，然后调用了`memory_region_init`函数对其进行初始化，其中**size**设置为**整个地址空间**：如果是**64位**就是`2^64`.

接着调用了`address_space_init`函数对`address_space_memory`进行了初始化。

```cpp
void address_space_init(AddressSpace *as, MemoryRegion *root, const char *name)
{
    memory_region_ref(root);
    /*指定address_space_memory的root为system_memory*/
    as->root = root;
    as->current_map = NULL;
    as->ioeventfd_nb = 0;
    as->ioeventfds = NULL;
    /* 初始化AddressSpace的listeners链表 */
    QTAILQ_INIT(&as->listeners);
    /*把address_space_memory插入全局链表*/
    QTAILQ_INSERT_TAIL(&address_spaces, as, address_spaces_link);
    /* AddressSpace的名称 */
    as->name = g_strdup(name ? name : "anonymous");
    address_space_update_topology(as);
    address_space_update_ioeventfds(as);
}


```

函数主要做了以下几个工作，设置**addressSpaceh和MR的关联**，并**初始化对应的FlatView**, 设置**其名称**。最后把address_space_memory加入到全局的address_spaces链表中，最后调用memory_region_transaction_commit()提交本次修改，关于memory_region_transaction_commit后imianzai做论述。回到memory_map_init()函数中，接下来按照同样的模式对IO区域system_io和IO地址空间address_space_io做了初始化。