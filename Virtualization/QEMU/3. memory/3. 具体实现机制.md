

# 整体概述

qemu部分的内存申请流程上可以分为三小部分，分成三小部分主要是我在看代码的时候觉得这三部分耦合性不是很大，相对而言比较独立。

众所周知，qemu起始于vl.c中的main函数，那么这三部分也按照在main函数中的调用顺序分别介绍。

# 回调函数的注册

涉及函数：`configure_accelerator() -->kvm_init()-->memory_listener_register ()`

这里所说的accelerator在这里就是kvm，初始化函数自然调用了`kvm_init`，该函数主要完成对**kvm的初始化**，包括一些常规检查如CPU个数、kvm版本等，还会通过ioctl和内核交互**创建kvm结构**，这些并非本文重点，不在赘述。在`kvm_init`函数的结尾调用了`memory_listener_register`

```cpp
memory_listener_register(&kvm_memory_listener, &address_space_memory);
memory_listener_register(&kvm_io_listener, &address_space_io);
```

通过`memory_listener_register`函数，针对**地址空间**注册了**lisenter**,lisenter本身是**一组函数表**，当**地址空间发生变化**的时候，会调用到listener中的相应函数，从而保持**内核**和**用户空间**的**内存信息的一致性**。

**虚拟机**包含有**两个地址空间**`address_space_memory`和`address_space_io`，很容易理解，正常系统也包含系统地址空间和IO地址空间。

`memory_listener_register`函数不复杂，咱们看下

```cpp
void memory_listener_register(MemoryListener *listener, AddressSpace *filter)
{
    MemoryListener *other = NULL;
    AddressSpace *as;

    listener->address_space_filter = filter;
    /*如果listener为空或者当前listener的优先级大于最后一个listener的优先级，则可以直接插入*/
    if (QTAILQ_EMPTY(&memory_listeners)
        || listener->priority >= QTAILQ_LAST(&memory_listeners,
                                             memory_listeners)->priority) {
        QTAILQ_INSERT_TAIL(&memory_listeners, listener, link);
    } else {
        /*listener按照优先级升序排列*/
        QTAILQ_FOREACH(other, &memory_listeners, link) {
            if (listener->priority < other->priority) {
                break;
            }
        }
        /*插入listener*/
        QTAILQ_INSERT_BEFORE(other, listener, link);
    }
    /*全局address_spaces-->as*/
    /*对于每个address_spaces，设置listener*/
    QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
        listener_add_address_space(listener, as);
    }
}
```

系统中可以存在**多个listener**，listener之间有着明确的**优先级关系**，通过**链表**进行组织，**链表头**是**全局**的`memory_listeners`。

```cpp
static QTAILQ_HEAD(, MemoryListener) memory_listeners
    = QTAILQ_HEAD_INITIALIZER(memory_listeners);
```

函数中，如果`memory_listeners`为空或者**当前listener**的**优先级**大于最后一个listener的优先级，即直接把当前listener插入。否则需要**挨个遍历链表**，找到**合适的位置**。具体按照优先级升序查找。

在函数最后还针对**每个address_space**，调用`listener_add_address_space`函数，该函数对其对应的`address_space`管理的**flatrange**向**KVM注册**。当然，实际上**此时address_space**尚未经过初始化，所以这里的循环其实是**空循环**。

# AddressSpace的初始化

涉及函数：`cpu_exec_init_all() memory_map_init()` 

在第一节中已经**注册了listener**，但是**addressspace尚未初始化**，本节就介绍下其初始化流程。从上节的configure_accelerator()函数往下走，会执行cpu_exec_init_all()函数，该函数主要初始化了IO地址空间和系统地址空间。memory_map_init()函数初始化系统地址空间，有一个全局的MemoryRegion指针system_memory指向该区域的MemoryRegion结构。