
详细的流程在经典的《Linkers and Loaders》和《深入理解计算机系统》中均有描述，也有国产的诸如《程序员的自我修养——链接、装载与库》等大牛著作。

我的环境：Fedora 16 i686 kernel-3.6.11-4 gcc 4.6.3

在正式开始我们的描述前，我们先来引出几个问题：

1. C语言代码为什么要编译后才能执行？整个过程中编译器都做了什么？
2. C代码中经常会包含头文件，那头文件是什么？C语言库又是什么？
3. 有人说main函数是C语言程序的入口，是这样吗？难道就不能把其它函数当入口？
4. 不同的操作系统上编译好的程序可以直接拷贝过去运行吗？

我们就以最经典的HelloWorld程序为例开始吧。

我们先使用vim等文本编辑器写好代码，接着在终端执行命令 `gcc HelloWorld.c -o HelloWorld` 输出了可执行文件HelloWorld，最后我们在终端执行 `./HelloWorld`，顺利地显示了输出结果。

```
[root@lihaiwei cpptest]# vim HelloWorld.c
#include <stdio.h>

int main(void)
{
	printf("Hello World\n");
}
[root@lihaiwei cpptest]# gcc HelloWorld.c -o HelloWorld
[root@lihaiwei cpptest]# ./HelloWorld
Hello World
```

可是，简单的命令背后经过了什么样的处理过程呢？gcc真的就“直接”生成了最后的可执行文件了吗？当然不是，我们在**gcc编译命令**行加上参数 `–verbose` 要求gcc输出完整的处理过程(命令行加上 `-v` 也行)，我们看到了一段较长的过程输出。

```
[root@lihaiwei cpptest]# gcc --verbose HelloWorld.c -o HelloWorld
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/lto-wrapper
Target: x86_64-redhat-linux
Configured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-linker-hash-style=gnu --enable-languages=c,c++,objc,obj-c++,java,fortran,ada,go,lto --enable-plugin --enable-initfini-array --disable-libgcj --with-isl=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/isl-install --with-cloog=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/cloog-install --enable-gnu-indirect-function --with-tune=generic --with-arch_32=x86-64 --build=x86_64-redhat-linux
Thread model: posix
gcc version 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC)
COLLECT_GCC_OPTIONS='-v' '-o' 'HelloWorld' '-mtune=generic' '-march=x86-64'
 /usr/libexec/gcc/x86_64-redhat-linux/4.8.5/cc1 -quiet -v HelloWorld.c -quiet -dumpbase HelloWorld.c -mtune=generic -march=x86-64 -auxbase HelloWorld -version -o /tmp/cc4vtoRP.s
GNU C (GCC) version 4.8.5 20150623 (Red Hat 4.8.5-39) (x86_64-redhat-linux)
	compiled by GNU C version 4.8.5 20150623 (Red Hat 4.8.5-39), GMP version 6.0.0, MPFR version 3.1.1, MPC version 1.0.1
GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
ignoring nonexistent directory "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include-fixed"
ignoring nonexistent directory "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../x86_64-redhat-linux/include"
#include "..." search starts here:
#include <...> search starts here:
 /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include
 /usr/local/include
 /usr/include
End of search list.
GNU C (GCC) version 4.8.5 20150623 (Red Hat 4.8.5-39) (x86_64-redhat-linux)
	compiled by GNU C version 4.8.5 20150623 (Red Hat 4.8.5-39), GMP version 6.0.0, MPFR version 3.1.1, MPC version 1.0.1
GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
Compiler executable checksum: edd9a53947039836c859e437e8c9af72
COLLECT_GCC_OPTIONS='-v' '-o' 'HelloWorld' '-mtune=generic' '-march=x86-64'
 as -v --64 -o /tmp/ccf99PWJ.o /tmp/cc4vtoRP.s
GNU assembler version 2.27 (x86_64-redhat-linux) using BFD version version 2.27-41.base.el7_7.1
COMPILER_PATH=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/:/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/:/usr/libexec/gcc/x86_64-redhat-linux/:/usr/lib/gcc/x86_64-redhat-linux/4.8.5/:/usr/lib/gcc/x86_64-redhat-linux/
LIBRARY_PATH=/usr/lib/gcc/x86_64-redhat-linux/4.8.5/:/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/:/lib/../lib64/:/usr/lib/../lib64/:/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../:/lib/:/usr/lib/
COLLECT_GCC_OPTIONS='-v' '-o' 'HelloWorld' '-mtune=generic' '-march=x86-64'
 /usr/libexec/gcc/x86_64-redhat-linux/4.8.5/collect2 --build-id --no-add-needed --eh-frame-hdr --hash-style=gnu -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o HelloWorld /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/crt1.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/crti.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtbegin.o -L/usr/lib/gcc/x86_64-redhat-linux/4.8.5 -L/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64 -L/lib/../lib64 -L/usr/lib/../lib64 -L/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../.. /tmp/ccf99PWJ.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtend.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/crtn.o
```

![2020-02-07-15-00-06.png](./images/2020-02-07-15-00-06.png)

可以自己试验然后试着分析整个流程。

一图胜千言，我们先上一张图吧。这是gcc编译过程的分解图.

![2020-02-07-14-56-31.png](./images/2020-02-07-14-56-31.png)

gcc处理HelloWorld.c的大致过程：

>预处理(Prepressing)—>编译(Compilation)—>汇编(Assembly)—>链接(Linking)

括号中我注明了各个过程中实际执行任务的程序名称：`预处理器cpp`、`编译器cc1`、`汇编器as`以及最后的`链接器ld`。

# 预处理

`gcc -E HelloWorld.c -o HelloWorld.i`

我们一步一步来看，首先是预处理，我们看看预处理阶段对代码进行了哪些处理。

我们在终端输入指令 `gcc -E HelloWorld.c -o HelloWorld.i`，然后我们打开输出文件。

![2020-02-07-15-19-27.png](./images/2020-02-07-15-19-27.png)

首先是大段大段的**变量和函数的声明**，汗..我们的代码哪里去了？我们在vim的普通模式中按下shift+g(大写G)来到最后，终于在几千行以后看到了我们可怜兮兮的几行代码。

![2020-02-07-15-22-04.png](./images/2020-02-07-15-22-04.png)

前面几千行是什么呢？其实它就是 `/usr/include/stdio.h` 文件的所有内容，预处理器把所有的`#include`**替换**为**实际文件的内容**了。这个过程是**递归进行**的，所以`stdio.h`里面的`#include`也**被实际内容所替换**了。

而且`HelloWorld.c`里面的**所有注释被预处理器全部删除**了。就连`printf语句`前的`Tab缩进`也被**替换为一个空格**了，显得代码都不美观了。

我直接给出预处理器处理的大致范围吧。

* 展开所有的宏定义并删除 `#define`
* 处理所有的条件编译指令，例如 `#if #else #endif #ifndef …`
* 把所有的 `#include` 替换为头文件实际内容，递归进行
* 把所有的注释 `//` 和 `/* */` 替换为空格
* 添加行号和文件名标识以供编译器使用
* 保留所有的 #pragma 指令，因为编译器要使用
* ……

基本上就是这些了。在这里我顺便插播一个小技巧，在代码中有时候**宏定义比较复杂的时候**我们很**难判断其处理后的结构是否正确**。这个时候我们呢就可以使用gcc的`-E参数`输出处理结果来判断了。

前文中我们提到了**头文件**中放置的是**变量定义**和**函数声明**等等内容。这些到底是什么东西呢？

其实在**比较早**的时候**调用函数并不需要声明**，后来因为“笔误”之类的错误实在太多，造成了链接期间的错误过多，**所有编译器**开始要求对**所有使用的变量或者函数**给出**声明**，以支持编译器进行**参数检查**和**类型匹配**。**头文件**包含的基本上就是**这些东西**和**一些预先的宏定义**来方便程序员编程。

其实对于我们的`HelloWorld.c`程序来说**不需要这个庞大的头文件**，只需要在**main函数前**声明printf函数，不需要`#include<stdio.h>`即可通过编译。

```cpp
int printf(const char *format, ...);
```

```
# cat HelloWorld.c
int printf(const char *format, ...);
int main(void)
{
	printf("Hello World\n");
}

# gcc -v HelloWorld.c -o HelloWorld
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/lto-wrapper
Target: x86_64-redhat-linux
Configured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-linker-hash-style=gnu --enable-languages=c,c++,objc,obj-c++,java,fortran,ada,go,lto --enable-plugin --enable-initfini-array --disable-libgcj --with-isl=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/isl-install --with-cloog=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/cloog-install --enable-gnu-indirect-function --with-tune=generic --with-arch_32=x86-64 --build=x86_64-redhat-linux
Thread model: posix
gcc version 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC)
COLLECT_GCC_OPTIONS='-v' '-o' 'HelloWorld' '-mtune=generic' '-march=x86-64'
 /usr/libexec/gcc/x86_64-redhat-linux/4.8.5/cc1 -quiet -v HelloWorld.c -quiet -dumpbase HelloWorld.c -mtune=generic -march=x86-64 -auxbase HelloWorld -version -o /tmp/ccACFg1Y.s
GNU C (GCC) version 4.8.5 20150623 (Red Hat 4.8.5-39) (x86_64-redhat-linux)
	compiled by GNU C version 4.8.5 20150623 (Red Hat 4.8.5-39), GMP version 6.0.0, MPFR version 3.1.1, MPC version 1.0.1
GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
ignoring nonexistent directory "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include-fixed"
ignoring nonexistent directory "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../x86_64-redhat-linux/include"
#include "..." search starts here:
#include <...> search starts here:
 /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include
 /usr/local/include
 /usr/include
End of search list.
GNU C (GCC) version 4.8.5 20150623 (Red Hat 4.8.5-39) (x86_64-redhat-linux)
	compiled by GNU C version 4.8.5 20150623 (Red Hat 4.8.5-39), GMP version 6.0.0, MPFR version 3.1.1, MPC version 1.0.1
GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
Compiler executable checksum: edd9a53947039836c859e437e8c9af72
COLLECT_GCC_OPTIONS='-v' '-o' 'HelloWorld' '-mtune=generic' '-march=x86-64'
 as -v --64 -o /tmp/ccKBm26a.o /tmp/ccACFg1Y.s
GNU assembler version 2.27 (x86_64-redhat-linux) using BFD version version 2.27-41.base.el7_7.1
COMPILER_PATH=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/:/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/:/usr/libexec/gcc/x86_64-redhat-linux/:/usr/lib/gcc/x86_64-redhat-linux/4.8.5/:/usr/lib/gcc/x86_64-redhat-linux/
LIBRARY_PATH=/usr/lib/gcc/x86_64-redhat-linux/4.8.5/:/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/:/lib/../lib64/:/usr/lib/../lib64/:/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../:/lib/:/usr/lib/
COLLECT_GCC_OPTIONS='-v' '-o' 'HelloWorld' '-mtune=generic' '-march=x86-64'
 /usr/libexec/gcc/x86_64-redhat-linux/4.8.5/collect2 --build-id --no-add-needed --eh-frame-hdr --hash-style=gnu -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o HelloWorld /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/crt1.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/crti.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtbegin.o -L/usr/lib/gcc/x86_64-redhat-linux/4.8.5 -L/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64 -L/lib/../lib64 -L/usr/lib/../lib64 -L/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../.. /tmp/ccKBm26a.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtend.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/crtn.o

# ./HelloWorld
Hello World
```

查看`gcc -E HelloWorld.c -o HelloWorld.i`

```
# cat HelloWorld.i
# 1 "HelloWorld.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "HelloWorld.c"
int printf(const char *format, ...);
int main(void)
{
 printf("Hello World\n");
}
```

另外再补充一点，gcc其实**并不要求**函数一定要在**被调用之前定义或者声明**（MSVC不允许），因为**gcc**在处理到**某个未知类型的函数**时，会为其**创建一个隐式声明**，并**假设**该**函数返回值类型为int**。但**gcc**此时**无法检查**传递给该函数的**实参类型**和**个数**是否正确，不利于编译器为我们排除错误（而且如果该**函数的返回值不是int**的话也会**出错！！！**）。所以还是建议大家在函数调用前，先对其定义或声明。

# 编译

`gcc -S HelloWorld.c -o HelloWorld.s`

`gcc -S HelloWorld.i -o HelloWorld.s`

接着看编译和汇编。

那么什么是编译？一句话描述：**编译**就是把**预处理之后的文件**进行一系列**词法分析**、**语法分析**、**语义分析**以及优化后生成的**相应汇编代码**文件。

这一部分我们不能展开说了，一来我没有系统学习过编译原理的内容不敢信口开河，二来这部分要是展开去说需要很厚很厚的一本书了，细节大家就自己学习《编译原理》吧，相关的资料自然就是经典的龙书、虎书和鲸书了。

`gcc`怎么**查看编译后的汇编代码**呢？命令是 `gcc -S HelloWorld.c -o HelloWorld.s`，这样输出了汇编代码文件HelloWorld.s，其实输出的文件名可以随意，我是习惯使然。

顺便说一句，这里生成的**汇编**是`AT&T`风格的汇编代码，如果大家更熟悉Intel风格，可以在命令行加上参数 `-masm=intel` ,这样gcc就会生成**Intel风格**的汇编代码了。不过**gcc的内联汇编**只支持`AT&T`风格，大家还是找找资料学学AT&T风格吧。

# 汇编

再下来是汇编步骤，我们继续用一句话来描述：**汇编**就是**将编译后的汇编代码**翻译为**机器码**，几乎**每一条汇编指令**对应**一句机器码**。

这里其实也没有什么好说的了，命令行 `gcc -c HelloWorld.c` 可以让**编译器**只进行到**生成目标文件**这一步，这样我们就能在目录下看到HelloWorld.o文件了。

Linux下的**可执行文件**以及**目标文件**的**格式**叫作**ELF**(Executable Linkable Format)。其实Windows下的PE(Portable Executable)也好，ELF也罢，都是`COFF(Common file format)`格式的**一种变种**，甚至Windows下的目标文件就是以COFF格式去存储的。不同的操作系统之间的可执行文件的格式通常是不一样的，所以造成了编译好的HelloWorld没有办法直接复制执行，而需要在相关平台上重新编译。当然了，不能运行的原因自然不是这一点点，不同的操作系统接口（windows API和Linux的System Call）以及相关的类库不同也是原因之一。

由于本文的读者定位，我们不能详细展开说了，有相关需求的同学可以去看《Windows PE权威指南》和《程序员的自我修养》去详细了解。

# 链接

我们接下来看最后的链接过程。

这一步是将**汇编**产生的**目标文件**和**所使用的库函数的目标文件**链接**生成一个可执行文件**的过程。

我想在这里稍微的扩展一下篇幅，稍微详细的说一说链接，一来这里造成的错误通常难以理解和处理，二来使用第三方库在开发中越来越常见了，想着大家可能更需要稍微了解一些细节了。

我们先介绍gnu binutils工具包，这是一整套的二进制分析处理工具包。详细介绍请大家参考喂鸡百科：http://zh.wikipedia.org/wiki/GNU_Binutils

我的fedora已经自带了这套工具包，如果你的发行版没有，请自行搜索安装方法。

这套工具包含了足够多的工具，我们甚至可以用来研究ELF文件的格式等内容。不过本文只是抛砖引玉，更多的使用方法和技巧还是需要大家自己去学习和研究。

由于时间关系，上篇到此就告一段落了，我们的问题2和3还没有给出完整的答案，而且链接还没有详细去解释和说明。这些内容我们将在下篇中解决，当然，大家也可以先行研究，到时候我们相互学习补充。

# 参考

http://www.0xffffff.org/2013/04/05/16-complier-and-linker-1/