# 整个过程示例

详细的流程在经典的《Linkers and Loaders》和《深入理解计算机系统》中均有描述，也有国产的诸如《程序员的自我修养——链接、装载与库》等大牛著作。

我的环境：Fedora 16 i686 kernel-3.6.11-4 gcc 4.6.3

在正式开始我们的描述前，我们先来引出几个问题：

1. C语言代码为什么要编译后才能执行？整个过程中编译器都做了什么？
2. C代码中经常会包含头文件，那头文件是什么？C语言库又是什么？
3. 有人说main函数是C语言程序的入口，是这样吗？难道就不能把其它函数当入口？
4. 不同的操作系统上编译好的程序可以直接拷贝过去运行吗？

我们就以最经典的HelloWorld程序为例开始吧。

我们先使用vim等文本编辑器写好代码，接着在终端执行命令 `gcc HelloWorld.c -o HelloWorld` 输出了可执行文件HelloWorld，最后我们在终端执行 `./HelloWorld`，顺利地显示了输出结果。

```
[root@lihaiwei cpptest]# vim HelloWorld.c
#include <stdio.h>

int main(void)
{
	printf("Hello World\n");
}
[root@lihaiwei cpptest]# gcc HelloWorld.c -o HelloWorld
[root@lihaiwei cpptest]# ./HelloWorld
Hello World
```

可是，简单的命令背后经过了什么样的处理过程呢？gcc真的就“直接”生成了最后的可执行文件了吗？

当然不是，我们在**gcc编译命令**行加上参数 `–verbose` 要求gcc输出完整的处理过程(命令行加上 `-v` 也行)，我们看到了一段较长的过程输出。

```
[root@lihaiwei cpptest]# gcc --verbose HelloWorld.c -o HelloWorld
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/lto-wrapper
Target: x86_64-redhat-linux
Configured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-linker-hash-style=gnu --enable-languages=c,c++,objc,obj-c++,java,fortran,ada,go,lto --enable-plugin --enable-initfini-array --disable-libgcj --with-isl=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/isl-install --with-cloog=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/cloog-install --enable-gnu-indirect-function --with-tune=generic --with-arch_32=x86-64 --build=x86_64-redhat-linux
Thread model: posix
gcc version 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC)
COLLECT_GCC_OPTIONS='-v' '-o' 'HelloWorld' '-mtune=generic' '-march=x86-64'
 /usr/libexec/gcc/x86_64-redhat-linux/4.8.5/cc1 -quiet -v HelloWorld.c -quiet -dumpbase HelloWorld.c -mtune=generic -march=x86-64 -auxbase HelloWorld -version -o /tmp/cc4vtoRP.s
GNU C (GCC) version 4.8.5 20150623 (Red Hat 4.8.5-39) (x86_64-redhat-linux)
	compiled by GNU C version 4.8.5 20150623 (Red Hat 4.8.5-39), GMP version 6.0.0, MPFR version 3.1.1, MPC version 1.0.1
GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
ignoring nonexistent directory "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include-fixed"
ignoring nonexistent directory "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../x86_64-redhat-linux/include"
#include "..." search starts here:
#include <...> search starts here:
 /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include
 /usr/local/include
 /usr/include
End of search list.
GNU C (GCC) version 4.8.5 20150623 (Red Hat 4.8.5-39) (x86_64-redhat-linux)
	compiled by GNU C version 4.8.5 20150623 (Red Hat 4.8.5-39), GMP version 6.0.0, MPFR version 3.1.1, MPC version 1.0.1
GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
Compiler executable checksum: edd9a53947039836c859e437e8c9af72
COLLECT_GCC_OPTIONS='-v' '-o' 'HelloWorld' '-mtune=generic' '-march=x86-64'
 as -v --64 -o /tmp/ccf99PWJ.o /tmp/cc4vtoRP.s
GNU assembler version 2.27 (x86_64-redhat-linux) using BFD version version 2.27-41.base.el7_7.1
COMPILER_PATH=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/:/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/:/usr/libexec/gcc/x86_64-redhat-linux/:/usr/lib/gcc/x86_64-redhat-linux/4.8.5/:/usr/lib/gcc/x86_64-redhat-linux/
LIBRARY_PATH=/usr/lib/gcc/x86_64-redhat-linux/4.8.5/:/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/:/lib/../lib64/:/usr/lib/../lib64/:/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../:/lib/:/usr/lib/
COLLECT_GCC_OPTIONS='-v' '-o' 'HelloWorld' '-mtune=generic' '-march=x86-64'
 /usr/libexec/gcc/x86_64-redhat-linux/4.8.5/collect2 --build-id --no-add-needed --eh-frame-hdr --hash-style=gnu -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o HelloWorld /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/crt1.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/crti.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtbegin.o -L/usr/lib/gcc/x86_64-redhat-linux/4.8.5 -L/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64 -L/lib/../lib64 -L/usr/lib/../lib64 -L/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../.. /tmp/ccf99PWJ.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtend.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/crtn.o
```

![2020-02-07-15-00-06.png](./images/2020-02-07-15-00-06.png)

可以自己试验然后试着分析整个流程。

一图胜千言，我们先上一张图吧。这是gcc编译过程的分解图.

![2020-02-07-14-56-31.png](./images/2020-02-07-14-56-31.png)

gcc处理HelloWorld.c的大致过程：

>预处理(Prepressing)—>编译(Compilation)—>汇编(Assembly)—>链接(Linking)

括号中我注明了各个过程中实际执行任务的程序名称：`预处理器cpp`、`编译器cc1`、`汇编器as`以及最后的`链接器ld`。

# 预处理: 转换成新C源码文件

`gcc -E HelloWorld.c -o HelloWorld.i`

`-E` 选项是"Preprocess only; do not compile, assemble or link", 即"**仅仅预处理**, **不编译、不汇编和不链接"**.

我们一步一步来看，首先是预处理，我们看看预处理阶段对代码进行了哪些处理。

我们在终端输入指令 `gcc -E HelloWorld.c -o HelloWorld.i`，然后我们打开输出文件。

![2020-02-07-15-19-27.png](./images/2020-02-07-15-19-27.png)

首先是大段大段的**变量和函数的声明**，汗..我们的代码哪里去了？我们在vim的普通模式中按下shift+g(大写G)来到最后，终于在几千行以后看到了我们可怜兮兮的几行代码。

![2020-02-07-15-22-04.png](./images/2020-02-07-15-22-04.png)

前面几千行是什么呢？其实它就是 `/usr/include/stdio.h` 文件的所有内容，预处理器把所有的`#include`**替换**为**实际文件的内容**了。这个过程是**递归进行**的，所以`stdio.h`里面的`#include`也**被实际内容所替换**了。

而且`HelloWorld.c`里面的**所有注释被预处理器全部删除**了。就连`printf语句`前的`Tab缩进`也被**替换为一个空格**了，显得代码都不美观了。

我直接给出预处理器处理的大致范围吧。

* 展开所有的**宏定义**并删除 `#define`
* 处理所有的**条件编译指令**，例如 `#if #else #endif #ifndef …`
* 把所有的 `#include` 替换为**头文件实际内容**，递归进行
* 把所有的**注释** `//` 和 `/* */` 替换为**空格**
* 添加行号和文件名标识以供编译器使用
* 保留所有的 `#pragma` 指令，因为编译器要使用
* ……

基本上就是这些了。在这里我顺便插播一个小技巧，在代码中有时候**宏定义比较复杂的时候**我们很**难判断其处理后的结构是否正确**。这个时候我们呢就可以使用gcc的`-E参数`输出处理结果来判断了。

## 头文件的作用

前文中我们提到了**头文件！！！** 中放置的是**变量定义！！！** 和**函数声明！！！** 等等内容。这些到底是什么东西呢？

其实在**比较早**的时候**调用函数并不需要声明**，后来因为“笔误”之类的错误实在太多，造成了链接期间的错误过多，**所有编译器**开始要求对**所有使用的变量或者函数**给出**声明**，以支持编译器进行**参数检查**和**类型匹配**。

**头文件**包含的基本上就是**这些东西**和**一些预先的宏定义**来方便程序员编程。

## 不要头文件但手动声明

其实对于我们的`HelloWorld.c`程序来说**不需要这个庞大的头文件**，只需要在**main函数前**声明printf函数，不需要`#include<stdio.h>`即可通过编译。

```cpp
int printf(const char *format, ...);
```

```
# cat HelloWorld.c
int printf(const char *format, ...);
int main(void)
{
	printf("Hello World\n");
}

# gcc -v HelloWorld.c -o HelloWorld
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/lto-wrapper
Target: x86_64-redhat-linux
Configured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-linker-hash-style=gnu --enable-languages=c,c++,objc,obj-c++,java,fortran,ada,go,lto --enable-plugin --enable-initfini-array --disable-libgcj --with-isl=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/isl-install --with-cloog=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/cloog-install --enable-gnu-indirect-function --with-tune=generic --with-arch_32=x86-64 --build=x86_64-redhat-linux
Thread model: posix
gcc version 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC)
COLLECT_GCC_OPTIONS='-v' '-o' 'HelloWorld' '-mtune=generic' '-march=x86-64'
 /usr/libexec/gcc/x86_64-redhat-linux/4.8.5/cc1 -quiet -v HelloWorld.c -quiet -dumpbase HelloWorld.c -mtune=generic -march=x86-64 -auxbase HelloWorld -version -o /tmp/ccACFg1Y.s
GNU C (GCC) version 4.8.5 20150623 (Red Hat 4.8.5-39) (x86_64-redhat-linux)
	compiled by GNU C version 4.8.5 20150623 (Red Hat 4.8.5-39), GMP version 6.0.0, MPFR version 3.1.1, MPC version 1.0.1
GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
ignoring nonexistent directory "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include-fixed"
ignoring nonexistent directory "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../x86_64-redhat-linux/include"
#include "..." search starts here:
#include <...> search starts here:
 /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include
 /usr/local/include
 /usr/include
End of search list.
GNU C (GCC) version 4.8.5 20150623 (Red Hat 4.8.5-39) (x86_64-redhat-linux)
	compiled by GNU C version 4.8.5 20150623 (Red Hat 4.8.5-39), GMP version 6.0.0, MPFR version 3.1.1, MPC version 1.0.1
GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
Compiler executable checksum: edd9a53947039836c859e437e8c9af72
COLLECT_GCC_OPTIONS='-v' '-o' 'HelloWorld' '-mtune=generic' '-march=x86-64'
 as -v --64 -o /tmp/ccKBm26a.o /tmp/ccACFg1Y.s
GNU assembler version 2.27 (x86_64-redhat-linux) using BFD version version 2.27-41.base.el7_7.1
COMPILER_PATH=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/:/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/:/usr/libexec/gcc/x86_64-redhat-linux/:/usr/lib/gcc/x86_64-redhat-linux/4.8.5/:/usr/lib/gcc/x86_64-redhat-linux/
LIBRARY_PATH=/usr/lib/gcc/x86_64-redhat-linux/4.8.5/:/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/:/lib/../lib64/:/usr/lib/../lib64/:/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../:/lib/:/usr/lib/
COLLECT_GCC_OPTIONS='-v' '-o' 'HelloWorld' '-mtune=generic' '-march=x86-64'
 /usr/libexec/gcc/x86_64-redhat-linux/4.8.5/collect2 --build-id --no-add-needed --eh-frame-hdr --hash-style=gnu -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o HelloWorld /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/crt1.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/crti.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtbegin.o -L/usr/lib/gcc/x86_64-redhat-linux/4.8.5 -L/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64 -L/lib/../lib64 -L/usr/lib/../lib64 -L/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../.. /tmp/ccKBm26a.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtend.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/crtn.o

# ./HelloWorld
Hello World
```

查看`gcc -E HelloWorld.c -o HelloWorld.i`

```
[root@lihaiwei cpptest]# cat HelloWorld.i
# 1 "HelloWorld.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "HelloWorld.c"
int printf(const char *format, ...);
int main(void)
{
 printf("Hello World\n");
}
```

另外再补充一点，gcc其实**并不要求**函数一定要在**被调用之前定义或者声明**（MSVC不允许），因为**gcc**在处理到**某个未知类型的函数**时，会为其**创建一个隐式声明**，并**假设**该**函数返回值类型为int**。

但**gcc**此时**无法检查**传递给该函数的**实参类型！！！** 和**个数！！！** 是否正确，**不利于编译器为我们排除错误**（而且如果该**函数的返回值不是int**的话也会**出错！！！**）。

所以还是建议大家在函数调用前，先对其定义或声明。

# 编译: 从预处理后的C源码生成汇编码

从 `.c` C源码生成:

`gcc -S HelloWorld.c -o HelloWorld.s`

从 `.i` 预处理后C源码生成:

`gcc -S HelloWorld.i -o HelloWorld.s`

`-S`选项是"Compile only; do not assemble or link", 即"**仅仅编译**, **不汇编和不链接"**. 

接着看编译和汇编。

那么什么是编译？一句话描述：**编译**就是把**预处理之后的文件**进行一系列**词法分析**、**语法分析**、**语义分析**以及优化后生成的**相应汇编代码**文件。

这一部分我们不能展开说了，一来我没有系统学习过编译原理的内容不敢信口开河，二来这部分要是展开去说需要很厚很厚的一本书了，细节大家就自己学习《编译原理》吧，相关的资料自然就是经典的龙书、虎书和鲸书了。

`gcc`怎么**查看编译后的汇编代码**呢？命令是 `gcc -S HelloWorld.c -o HelloWorld.s`，这样输出了汇编代码文件HelloWorld.s，其实输出的文件名可以随意，我是习惯使然。

顺便说一句，这里生成的**汇编**是`AT&T`风格的汇编代码，如果大家更熟悉Intel风格，可以在命令行加上参数 `-masm=intel` ,这样gcc就会生成**Intel风格**的汇编代码了。不过**gcc的内联汇编**只支持`AT&T`风格，大家还是找找资料学学AT&T风格吧。

# 汇编: 从汇编代码生成机器码(目标文件)

从 `.c` C源码生成:

`gcc -c HelloWorld.c -o HelloWorld.o`

从 `.s` 汇编代码生成:

`gcc -c HelloWorld.s -o HelloWorld.o`

`-c`选项是"Compile and assemble, but do not link", 即"**编译和汇编**, **不链接"**. 

再下来是汇编步骤，我们继续用一句话来描述：**汇编**就是**将编译后的汇编代码**翻译为**机器码**，几乎**每一条汇编指令**对应**一句机器码**。

这里其实也没有什么好说的了，命令行 `gcc -c HelloWorld.c -o HelloWorld.o` 可以让**编译器**只进行到**生成目标文件**这一步，这样我们就能在目录下看到HelloWorld.o文件了。

Linux下的**可执行文件**以及**目标文件**的**格式**叫作**ELF**(Executable Linkable Format)。其实Windows下的PE(Portable Executable)也好，ELF也罢，都是`COFF(Common file format)`格式的**一种变种**，甚至Windows下的目标文件就是以COFF格式去存储的。不同的操作系统之间的可执行文件的格式通常是不一样的，所以造成了编译好的HelloWorld没有办法直接复制执行，而需要在相关平台上重新编译。当然了，不能运行的原因自然不是这一点点，不同的操作系统接口（windows API和Linux的System Call）以及相关的类库不同也是原因之一。

由于本文的读者定位，我们不能详细展开说了，有相关需求的同学可以去看《Windows PE权威指南》和《程序员的自我修养》去详细了解。

# 链接: 从目标文件和其他库的目标文件生成一个可执行文件

我们接下来看最后的链接过程。

这一步是将**汇编**产生的**目标文件**和**所使用的库函数的目标文件**链接**生成一个可执行文件**的过程。

## GNU binutils工具包

我们先介绍`gnu binutils`工具包，这是一整套的**二进制分析处理工具包**。详细介绍请大家参考维基百科：http://zh.wikipedia.org/wiki/GNU_Binutils

我的fedora已经自带了这套工具包，如果你的发行版没有，请自行搜索安装方法。

```
yum install binutils
```

这套工具包含了足够多的工具，我们甚至可以用来**研究ELF文件的格式**等内容。不过本文只是抛砖引玉，更多的使用方法和技巧还是需要大家自己去学习和研究。

包含诸多工具, 比如 `ld`、`as`、`objdump`等. 官网: https://www.gnu.org/software/binutils/ .

## 链接相关知识

我想在这里稍微的扩展一下篇幅，稍微详细的说一说链接，一来这里造成的**错误通常难以理解和处理**，二来使用**第三方库**在开发中越来越常见了，想着大家可能更需要稍微了解一些细节了。

链接这个话题延伸之后完全可以跑到九霄云外去，为了避免本文牵扯到过多的话题导致言之泛泛，我们先设定本文涉及的范围。

我们今天**只讨论**链接进行的**大致步骤及其规则**、**静态链接库**与**动态链接库**的**创建**和**使用**这两大块的问题。至于**可执行文件的加载**、**可执行文件的运行时储存器映像**之类的内容我们**暂时不讨论**。

### 什么是链接

首先，什么是链接？我们引用CSAPP的定义：`链接（linking）`是将各种**代码**和**数据**部分收集起来并**组合成为一个单一文件**的过程，这个文件可被加载（或被拷贝）到存储器并执行。

需要强调的是，**链接**

- 可以执行于**编译时**（compile time），也就是在**源代码**被翻译成**机器代码**时；
- 也可以执行于**加载时**，也就是在程序被加载器（`loader`）加载到存储器并执行时；
- 甚至执行于**运行时**（run time），由应用程序来执行。

### 了解链接的用处

说了这么多，了解链接有什么用呢？生命这么短暂，我们干嘛要去学习一些根本用不到的东西。当然有用了，继续引用CSAPP的说法，如下：

1. 理解链接器将帮助你构造大型程序。
2. 理解链接器将帮助你避免一些危险的编程错误。
3. 理解链接将帮助你理解语言的作用域是如何实现的。
4. 理解链接将帮助你理解其他重要的系统概念。
5. 理解链接将使你能够利用共享库。
6. ……

### 运行时库CRT

为了避免我们的描述过于枯燥，我们还是以C语言为例吧。

想必大家通过我们在上篇中的描述，已经知道**C代码编译后的目标文件**了吧。

**目标文件！！！** 最终要和**标准库！！！** 进行**链接**生成**最后的可执行文件**。那么，标准库和我们生成的目标文件是什么关系呢？

其实，任何一个程序，它的背后都有**一套庞大的代码**在支撑着它，以使得该程序能够正常运行。**这套代码**至少包括**入口函数**、以及其**所依赖的函数**构成的**函数集合**。当然，它还包含了各种**标准库函数的实现**。

这个“支撑模块”就叫做**运行时库**（`Runtime Library`）。而C语言的运行库，即被称为`C运行时库（CRT`）。

`CRT`大致包括：**启动**与**退出**相关的**代码**（包括**入口函数**及入口函数所**依赖的其他函数**）、**标准库函数**（ANSI C标准规定的函数实现）、`I/O`相关、**堆的封装实现**、**语言特殊功能的实现**以及**调试相关**。

其中**标准库函数的实现**占据了主要地位。标准库函数大家想必很熟悉了，而我们平时常用的printf，scanf函数就是标准库函数的成员。**C语言标准库**在**不同的平台**上实现了**不同的版本**，我们**只要依赖其接口定义**，就能保证程序在不同平台上的一致行为。

**C语言标准库**有**24**个，囊括**标准输入输出**、**文件操作**、**字符串操作**、**数学函数**以及**日期**等等内容。大家有兴趣的可以自行搜索。

### 静态链接库: 标准库函数提供形式

既然C语言提供了**标准库函数**供我们使用，那么以**什么形式提供**呢？**源代码**吗？当然**不是**了。下面我们引入**静态链接库**的概念。

我们几乎**每一次写程序**都难免去**使用库函数**，那么**每一次去编译！！！** 岂不是**太麻烦**了。干嘛不把**标准库函数提前编译好！！！**，需要的时候**直接链接！！！** 呢？我很负责任的说，我们就是这么做的。

那么，**标准库**以**什么形式**存在呢？一个目标文件？我们知道，**链接的最小单位**就是**一个个目标文件**，如果我们**只用**到一个**printf函数**，就需要和**整个库链接**的话岂不是**太浪费资源**了么？但是，如果把**库函数**分别定义在彼此**独立的代码文件**里，这样编译出来的可是**一大堆目标文件**，有点混乱吧？

所以，**编辑器系统**提供了**一种机制**，将**所有！！！的编译出来的目标文件**打包成**一个单独的文件！！！**，叫做`静态库（static library）`。

当**链接器**和**静态库链接**的时候，**链接器**会从**这个打包的文件**中“**解压缩**”出**需要的！！！部分目标文件**进行**链接**。这样就解决了**资源浪费**的问题。

Linux/Unix系统下`ANSI C`的库名叫做`libc.a`，另外**数学函数**单独在`libm.a`库里。**静态库**采用一种称为`存档（archive）`的**特殊文件格式**来**保存**。其实就是**一个目标文件的集合**，**文件头**描述了**每个成员目标文件**的**位置**和**大小**。

## 静态库例子

光说不练是假把式，我们自己做个静态库试试。为了简单起见我们就做一个**只有两个函数**的私有库吧。

我们在`swap.c`里定义一个`swap函数`，在`add.c`里定义了一个`add函数`。最后还有含有它们声明的`calc.h`头文件。

```cpp
// swap.c
void swap(int *num1, int *num2)
{
    int tmp = *num1;
    *num1 = *num2;
    *num2 = tmp;
}
```

```cpp
// add.c
int add(int a, int b)
{
    return a + b;
}
```

```cpp
// calc.h
#ifndef CALC_H_
#define CALC_H_

#ifdef _cplusplus
extern "C"
{
#endif

void swap(int *, int *);
int add(int, int);

#ifdef _cplusplus
}
#endif

#endif // CALC_H_
```

我们分别编译它们得到了`swap.o`和`add.o`这两个目标文件，最后使用**ar命令**将其打包为一个静态库。

```
# gcc add.c -c -o add.o
# gcc swap.c -c -o swap.o
# ar rcs libcalc.a swap.o add.o
```

现在我们怎么使用这个静态库呢？我们写一个`test.c`使用这个库中的**swap函数**吧。

```

```

# 参考

http://www.0xffffff.org/2013/04/05/16-complier-and-linker-1/