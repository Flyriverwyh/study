基本原理里面提到kvm虚拟化由用户态程序Qemu和[内核态驱动](http://www.oenhan.com/size-512-slab-kmalloc)kvm配合完成，qemu负责HOST用户态层面进程管理，IO处理等，KVM负责把qemu的部分指令在硬件上直接实现，从[虚拟机](http://www.oenhan.com/sort-optimal-solution)的创建和运行上看，qemu的代码占了流程上的主要部分。下面的代码主要主要针对与qemu，KVM部分另外开篇再说。

代码：

QEMU：git://git.qemu.org/qemu.git v2.4.0

KVM：https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git v4.2

QEMU和KVM是通过IOCTL进行配合的，直接抓住这个线看有kvm\_ioctl、kvm\_vm\_ioctl、kvm\_vcpu\_ioctl、kvm\_device\_ioctl等，他们还都在一个C文件里面。

使用kvm\_ioctl很少了，直接看调用的代码，有KVM\_GET\_VCPU\_MMAP\_SIZE，KVM\_CHECK\_EXTENSION，KVM\_GET\_API\_VERSION，KVM\_CREATE\_VM，KVM\_GET\_SUPPORTED\_CPUID等等，需要记住只有KVM\_CREATE\_VM。

而调用kvm_vm_ioctl的函数真是海了去了，需要看的是KVM\_SET\_USER\_MEMORY\_REGION，KVM\_CREATE\_VCPU，KVM\_CREATE\_DEVICE。

所有寄存器的交换信息都是通过kvm_vcpu_ioctl，需要记住的操作只有，KVM_RUN。

所有看QEMU和KVM的配合流程如下：

