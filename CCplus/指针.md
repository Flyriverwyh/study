
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [前言: 复杂类型说明](#前言-复杂类型说明)
  - [int p](#int-p)
  - [int *p](#int-p-1)
  - [int p[3]](#int-p3)
  - [int *p[3]](#int-p3-1)
  - [int (*p)[3]](#int-p3-2)
  - [int **p](#int-p-2)
  - [int p(int)](#int-pint)
  - [int (*p)(int)](#int-pint-1)
  - [int *(*p(int))[3]](#int-pint3)
- [细说指针](#细说指针)
  - [指针的类型](#指针的类型)
  - [指针所指向的类型](#指针所指向的类型)
- [参考](#参考)

<!-- /code_chunk_output -->

# 前言: 复杂类型说明

要了解指针,多多少少会出现一些比较复杂的类型, 所以我先介绍一下如何完全理解一个复杂类型,要理解复杂类型其实很简单, **一个类型**里会出现**很多运算符**, 他们也像**普通的表达式**一样, 有**优先级**, 其优先级和**运算优先级**一样, 所以我总结了一下其原则: 

>从**变量名**处起,根据**运算符优先级结合**,一步一步分析

注: 指针是一个**带有大小范围的地址**

下面让我们先从简单的类型开始慢慢分析吧:

## int p

```c
int p;
```

这是一个普通的整型变量

## int *p

```c
int *p;
```

**首先从 P 处开始**, 先**与\*结合**, 所以说明 P 是**一个指针**, 然后再**与 int 结合**, 说明**指针所指向的内容**的**类型为 int 型**. 

所以 P 是**一个返回整型数据的指针**

## int p[3]

```c
int p[3];
```

首先从 P 处开始, **先与[]结合**,说明 **P 是一个数组**, 然后**与 int 结合**, 说明**数组里的元素是整型的**.

所以 P 是一个**由整型数据组成的数组**

## int *p[3]

```c
int *p[3];
```

首先从 P 处开始, **先与[]结合**, 因为其**优先级比\*高**, 所以 **P 是一个数组**, 然后**再与\*结合**, 说明**数组里的元素是指针类型**, 然后**再与 int 结合**, 说明**指针所指向的内容的类型是整型**的.

所以 P 是一个由**返回整型数据的指针**所**组成的数组**

## int (*p)[3]

```
int (*p)[3];
```

首先从 P 处开始, **先与\*结合**, 说明 P 是**一个指针**, 然后**再与[]结合**(与"()"这步可以忽略, 只是为了改变优先级), 说明**指针所指向的内容是一个数组**, 然后**再与 int 结合**, 说明**数组里的元素是整型**的.

所以 P 是一个指向由**整型数据组成的数组**的**指针**

## int **p

```c
int **p;
```

首先从 P 开始, **先与\*结合**, 说是 P 是**一个指针**, 然后**再与\*结合**, 说明**指针所指向的元素是指针**, 然后**再与 int 结合**, 说明**该指针所指向的元素是整型数据**. 由于二级指针以及更高级的指针极少用在复杂的类型中, 所以后面更复杂的类型我们就不考虑多级指针了, 最多只考虑一级指针.

## int p(int)

```c
int p(int);
```

从 P 处起, **先与()结合**, 说明 P 是**一个函数**,然后进入()里分析, 说明该函数**有一个整型变量的参数**, 然后再与外面的 int 结合, 说明**函数的返回值**是一个**整型数据**

## int (*p)(int)

```c
int (*p)(int);
```

从 P 处开始, **先与指针结合**, 说明 P 是**一个指针**, 然后**与()结合**, 说明**指针指向的是一个函数**, 然后再与()里的int 结合, 说明函数有一个 int 型的参数, 再与最外层的int 结合, 说明函数的返回类型是整型, 所以 P 是一个指向有一个整型参数且返回类型为整型的函数的指针

## int *(*p(int))[3]

```c
int *(*p(int))[3];
```

从 P 开始, **先与()结合**, 说明 **P 是一个函数**, 然后进入()里面, 与 int 结合, 说明**函数有一个整型变量参数**, 然后再与外面的\*结合, 说明函数**返回的是一个指针**, 然后到最外面一层, 先与[]结合, 说明**返回的指针指向的是一个数组**, 然后**再与\*结合**, 说明**数组里的元素是指针**, 然后再与 int 结合, 说明**指针指向的内容是整型数据**. 

所以 P 是一个**参数为一个整数据**且返回一个指向由整型指针变量组成的数组的指针变量的函数.

# 细说指针

指针是一个**特殊的变量**，它里面**存储的数值**被解释成为**内存里的一个地址**。

要搞清一个指针需要搞清指针的**四方面的内容**: 

* **指针的类型**、
* 指针**所指向的类型**、
* 指针的**值**或者叫指针**所指向的内存区**、
* 指针**本身所占据的内存区**。

让我们分别说明。

先声明几个指针放着做例子:

(1) int \*ptr;

(2) char \*ptr;

(3) int \*\*ptr;

(4) int (\*ptr)\[3];

(5) int \*(\*ptr)\[4];

## 指针的类型

从语法的角度看，你只要把**指针声明语句**里的**指针名字去掉**，剩下的部分就是这个**指针的类型**。这是指针本身所具有的类型。让我们看看例一中各个指针的类型:

(1) int \*ptr; //指针的类型是 int*

(2) char \*ptr; //指针的类型是 char*

(3) int \*\*ptr; //指针的类型是 int**

(4) int (\*ptr)\[3]; //指针的类型是 int(*)[3]

(5) int \*(\*ptr)\[4]; //指针的类型是 int*(*)[4]

## 指针所指向的类型

当你通过指针来访问**指针所指向的内存区**时，**指针所指向的类型**决定了**编译器**将把**那片内存区里的内容**当做什么来看待。

从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声 明符*去掉，剩下的就是指针所指向的类型。例如:


# 参考

网络资源: <让你不再害怕指针>