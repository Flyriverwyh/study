## 1. 分段、段的汇编地址和段内汇编地址

处理器的工作模式是将内存分成逻辑上的段，指令的获取和数据的访问一律按“段地址：偏移地址”的方式进行。相对应地，一个规范的程序，应当包括代码段、数据段、附加段和堆栈段。

图 8-1 给出了整个源程序的组织结构。

NASM 编译器使用汇编指令“SECTION”或者“SEGMENT”来定义段。

```
SECTION 段名称
```

```
SEGMENT 段名称
```

**段名称，它主要用来引用一个段，可以是任意名字**。

NASM 编译器不关心段的用途，可能也根本不知道段的用途，不知道它是数据段，还是代码段，或是堆栈段。事实上，这都不重要，段只用来分隔程序中的不同内容。

![config](images/1.png)

一旦定义段，那么，后面的内容就都属于该段，除非又出现了另一个段的定义。

有时候，程序并不以段定义语句开始。在这种情况下，这些内容默认地自成一个段。最为典型的情况是，整个程序中都没有段定义语句。这时，整个程序自成一个段。

NASM 对段的数量没有限制。一些大的程序，可能拥有不止一个代码段和数据段。

Intel 处理器要求**段在内存中的起始物理地址起码是16字节对齐**的。这句话的意思是，必须是16 的倍数。

相应地，汇编语言源程序中定义的各个段，也有对齐方面的要求。具体做法是，在段定义中使用“align=”子句，用于指定某个SECTION的汇编地址对齐方式。比如说，“align=16”就表示段是 16 字节对齐的，“align=32”就表示段是 32 字节对齐的。

在源程序编译阶段，编译器将根据 align 子句确定段的起始汇编地址。如下面所示，这
里定义了三个段，分别是 data1、data2 和 data3，每个段里只有一个字节的数据，分别是 0x55、0xaa 和 0x99。

```
section data1 align=16
    db 0x55
    
section data2 align=16
    db 0xaa

section data3 align=16
    db 0x99
```

理论上，如果不考虑段的对齐方式，那么段 data1 的汇编地址是 0，段 data2 的汇编地址是 1，段 data3 的汇编地址是 2。

查看文件大小，有33字节

```
root@Gerry:/home/project/nasm# ll section
-rw-r--r-- 1 root root 33 Dec 17 00:13 section
```

编译并查看文件的16进制数据。

```
root@Gerry:/home/project/nasm# hexdump -C section
00000000  55 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |U...............|
00000010  aa 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000020  99                                                |.|
00000021
```

每个段都有一个汇编地址，它是相对于整个程序开头（0）的。为了方便取得**该段的汇编地址**，NASM 编译器提供了以下的表达式，可以用在你的程序中：

```
section.段名称.start
```

段“header”相对于整个程序开头的汇编地址是section.header.start，段“code”相对于整个程序开头的汇编地址是 section.code.start。在这个例子中，因为段“header”是在程序的一开始定义的，它的前面没有其他内容，故 section.header.start=0。

如图 8-1 所示，段定义语句还可以包含“vstart=”子句。尽管定义了段，但是，引用某个标号时，该标号处的汇编地址依然是从整个程序的开头计算的，而不是从段的开头处计算的。

如图 8-1 所示，“putch”是段code中的一个标号，**原则上，该标号代表的汇编地址应该从程序开头计算**。但是，因为段code的定义中有“vstart=0”子句，所以，标号“putch”的汇编地址要从它所在段的开头计算，而且从0开始计算。

段data的定义中也有“vstart=0”子句，因此，当我们在段code中引用段data中的标号“string”时（mov ax,string），尽管在图中没有标明，**标号“string”所代表的汇编地址是相对于其所在段 data 的**。也就是说，传送到寄存器 AX 中的数值是标号 string 相对于段 data 起始处的长度。

但是，图中最后一个段trail的定义中没有包含“vstart=0”子句。该段内有一个标号“program_end”，它的汇编地址就要从整个程序开头计算。因为它是整个程序中的最后一行，从这个意义上来说，它所代表的汇编地址就是整个程序的大小（以字节计）。