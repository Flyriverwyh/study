Intel处理器访问内存的基本策略是分段。在16位实模式下，段的起始位置必须16字节对齐，而且段的长度最大是64KB。

进入32位保护模式之后，强化了分段功能，并提供了保护机制。此时，段可以起始于任何位置，段长度可以扩展到处理器的最大寻址范围边界。典型，早期32位处理器由32根地址总线，因此，段的长度可以扩展到4GB。

在32位保护模式下，对段的访问本着“先登记，后访问”的原则进行。登记就是在GDT或者LDT中登记段的描述符，规定了段的地址和边界，以及访问权限；访问时，需要使用段描述符的选择子。处理器用段界限和特权级别审查对段的访问，任务非法访问都会被处理器阻止，并立即产生异常中断。

一般情况下，先安装一个操作系统。这时，段是由操作系统负责管理的。操作系统加载应用程序，根据程序的要求，为它创建一个或多个段，然后将控制权交给它。

有些资料说是为了实现“虚拟内存”，真的是这样吗？如果没有分页机制，能否实现“虚拟内存”？答案是肯定的。

当同时运行的程序和任务很多时，内存可能就不够用了。这时，操作系统的价值就体现出来了，每个段描述符有A位，每当访问一个段时，处理器会将其置位。A位的清零由操作系统定时进行，它借此统计段的访问频度。当内存不够用时，它可以将那些较少访问的段换出到磁盘上，以腾出空间来给马上运行的段使用。一旦某个段被换到磁盘上，操作系统应将描述符的P位清零。当这个段又被访问，因描述符P位是“0”，处理器引发段**不存在异常（中断号为11）**。这类中断通常由操作系统负责处理的，它会同样方法腾出空间，将这个段的内容从磁盘调入内存。当这类中断返回，处理器会再次执行引发异常的那条指令（而不是下条指令），于是程序又能继续执行了。

由此可见，即使没有分页机制，利用“分段”也可以实现“虚拟内存”。

但是，因为段的长度不定，分配内存时，可能发生内存空闲区域小于要加载的段，或空闲区域远远大于要加载的段。前一种情况，需要寻找合适的空闲区域；后一种，分配成功，但过于浪费。为解决这个问题，从80386开始，引入了分页机制。

分页机制简单来说，是用长度固定的页来代替长度不定的段，以解决因段的长度不同带来的内存空间管理变得复杂的问题。

尽管操作系统也可以利用纯软件来实施固定长度的内存分配，但是太过于复杂。由处理器固件来做这件事情，可以省去很多麻烦，速度也可以提高。

## 从虚拟地址到物理地址

分页机制是80x86内存管理机制的第二部分。它在分段机制的基础上完成虚拟（逻辑）地址到物理地址转换的过程。分段机制把逻辑地址转换成线性地址，而分页则把线性地址转换成物理地址。 

![config](images/1.png)

分页机制会把线性地址空间（段已映射到其中）划分成页面，然后这些线性地址空间的页面被映射到物理地址空间的页面上。

![config](images/2.png)

80x86使用4K（2的12次方）字节固定大小的页面。每个页面均是4KB，且对齐于4K地址边界处（地址的低12位全是0）。

## 简单的分页模型

一旦决定采用页式内存管理，就应**把4GB内存分成大小相同的页**，不是在内存中随意找个位置让页从那儿开始。

分页机制也没有增加程序员的负担，程序依然按照段来组织。问题在于，如何将较大的段，映射到大小相同的页面上呢？

如图16-3，内存的分配涉及段空间的分配和页分配。左边是虚拟的4GB内存空间，称为虚拟内存；右边是实实在在的内存，被分成1048576个4KB页面。

![config](images/4.png)

在分页模式下，操作系统可以创建一个为所有任务共用的4GB虚拟内存空间，也可以为每个任务创建独立的4GB虚拟内存空间。当一个程序加载时，**操作系统既要在左边的虚拟内存中分配段空间，又要在右边的物理内存中分配相应的页面**。因此，第一个步骤是寻找空闲的段空间，该段空间既没有被其他程序使用，也没有被同一程序的其他段使用。比如图16-3，假设已经找到并分配一个段空间，基地址是0x00200000，长度是8200字节。

页最小4KB，即4096字节。因此，8200字节的段，需要占用3个页面，其中最后一个页面只用了8个字节，其他都浪费着，如果允许页共享，多个段或多个程序可以用同一个页来存放各自数据。

在分段之后，操作系统将段拆分，并分别映射到物理页。注意，**段必须是连续的，但不要求所分配的页都是连续的**。分配页面时，操作系统会搜索那些空闲的页，并分配给程序使用，所分配页面的总长度要大于等于段长度。

图中是个具体的例子。

4GB虚拟内存空间不可能用来保存任何数据，因为是虚拟的。它只是指示内存的使用情况。**当操作系统加载一个程序并创建为任务时，操作系统在虚拟内存空间寻找空闲的段，并映射到空闲的页。然后，当真正开始加载程序时，再把原本属于段的数据按页的尺寸拆分，分开写入对应的页中**。

4GB（2的32次方）的线性地址空间可以划分为1048576（2的20次方，即1M）个页面。为了根据线性地址找到对应的物理地址，操作系统必须维护一张表（如下图所示）。 

![config](images/3.png)

这个表暂且叫做“页映射表”，它一共有1048576个表项。这是一个一维表格，每个表项占4个字节，其内容是某个页的起始物理地址（共32比特，低12位全为0）。**页映射表是这样使用的：因为页的尺寸是4KB，所以线性地址的低12位可以作为页内偏移，高20位可以用来索引一个表项，找到了这个表项，就找到了对应的物理页。因此，线性地址的高20位为索引，乘以4，作为表内偏移量，从表中取出一个双字，那就是该线性地址对应的页的物理地址**。

如图16-4，如果执行指令

```
mov edx, [0x2002]
```

段部件使用段地址0x00200000加上指令中给出的偏移量0x2002，得到线性地址0x00202002。线性地址的高20位是表格索引，即0x00202。将索引乘以4，得到0x00808，这就是表内偏移。看图，从该单元可以取出一个双字0x00007000，这就是页物理地址。

线性地址低12位是页内偏移量，用页物理地址加上页内偏移量，就是最终的物理地址。0x00007000加上0x002，得到0x00007002，这就是实际要访问的物理内存地址。

![config](images/5.png)