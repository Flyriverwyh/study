## 1. 通过调用门转移控制的完整过程

先看完整的调用门控制转移和返回过程。

### 转移的过程

首先，通过调用门实施控制转移，可以使用jmp far和call far指令。指令执行时，描述符选择子必须指向调用门，32位偏移量被忽略。使用下表的特权检查机制。注意，表比较关系是数值上的。

![config](images/11.png)

当使用jmp far指令通过调用门控制转移时，要求当前特权级和目标代码段的特权级相同。原因是用**jmp far指令通过调用门控制转移时，不改变CPL**。

相反，使用**call far指令通过调用门控制转移**时，如果改变了当前特权级，则必须切换栈。即，从当前任务的固有栈切换到与目标代码段特权级相同的栈上。栈的切换由处理器自动进行。

当前栈是由SS和ESP的当前内容所指示的。要切换到的新栈的相关信息位于当前任务的TSS中，处理器知道如何找到它。**栈切换**过程如下：

1. 根据目标代码段的DPL（也就是新的CPL）到当前任务的TSS中读取新栈的选择子和栈指针。在读取栈选择子、栈指针或者栈段描述符的过程中，任何违反段界限的错误都将导致产生一个无效TSS异常。 
2. 检查栈段描述符的特权级和类型是否有效，若无效同样产生一个无效TSS异常。 
3. 临时保存SS和ESP的当前值，把新栈的选择子和栈指针加载到SS和ESP中。然后把临时保存的SS和ESP的内容压入新栈中。
4. 根据调用门描述符中“参数个数”字段，把旧栈中的所有参数复制到新栈中。如果参数个数为0，则不复制参数。 

![config](images/23.png)
 
5. 将当前CS和EIP的内容压入新栈。通过调用门实施的控制转移一定是远转移，所以要压入CS和EIP。 
6. 从调用门描述符中把目标代码段的选择子和段内偏移值传送到CS和EIP中，开始执行被调用过程。

相反，如果没有改变特权级别，则不切换栈，继续使用调用者当前的栈，只是在原来的基础上压入当前CS和EIP的内容。

![config](images/22.png)

另外，如果通过调用门的控制转移是jmp far指令发起的，结果就是“肉包子打狗——有去无回”，且没有特权级变化，也不需要切换栈。相反，如果是call far指令发起的，则可以使用远返回指令retf把控制返回到调用者。

### 返回的过程

对于相同特权级的返回，CPU从堆栈中弹出EIP和CS；**会发生特权级改变的远返回仅允许返回到低特权级程序中**，即返回到的代码段的DPL在数值上要大于CPL。返回的全部过程如下：

1. 检测被调用者栈中CS寄存器的RPL字段值，以确定在返回时特权级是否发生改变。
2. 弹出并使用被调用过程栈上的值加载EIP和CS寄存器。在此过程中会对代码段描述符和代码段选择子的RPL进行特权级与类型检查。
3. 如果远返回指令是带参数的，则将参数和ESP寄存器的当前值相加，以跳过被调用者栈中的参数部分，最后的结果是ESP寄存器指向调用者SS和ESP的压栈值。注意，retf指令的参数必须等于调用门中所有参数的总字节数之和。
4. 如果返回时需要改变特权级，则从栈中将ESP和SS弹出，并把值代入寄存器ESP和SS，切换到调用者的栈。
5. 如果远返回指令是带参数的，则将参数和ESP寄存器的当前值相加，以跳过调用者栈中的参数部分，最后的结果是调用者的栈恢复平衡。
6. 如果返回时需要改变特权级，则检查DS,ES,FS和GS的内容，如果段选择子指向数据段或者非一致代码段且段描述符的DPL在数值上小于返回后的新CPL，那么就把数值0传送到该段寄存器。
 
