
# 1. 简介

上一篇文章，我介绍了传统的低分辨率定时器的实现原理。而随着内核的不断演进，大牛们已经对这种低分辨率定时器的精度不再满足，而且，硬件也在不断地发展，系统中的定时器硬件的精度也越来越高，这也给高分辨率定时器的出现创造了条件。内核从2.6.16开始加入了高精度定时器架构。在实现方式上，内核的高分辨率定时器的实现代码几乎没有借用低分辨率定时器的数据结构和代码，内核文档给出的解释主要有以下几点：

* 低分辨率定时器的代码和jiffies的关系太过紧密，并且默认按32位进行设计，并且它的代码已经经过长时间的优化，目前的使用也是没有任何错误，如果硬要基于它来实现高分辨率定时器，势必会打破原有的时间轮概念，并且会引入一大堆#if--#else判断；

* 虽然大部分时间里，时间轮可以实现O(1)时间复杂度，但是当有进位发生时，不可预测的O(N)定时器级联迁移时间，这对于低分辨率定时器来说问题不大，可是它大大地影响了定时器的精度；

* 低分辨率定时器几乎是为“超时”而设计的，并为此对它进行了大量的优化，对于这些以“超时”未目的而使用定时器，它们大多数期望在超时到来之前获得正确的结果，然后删除定时器，精确时间并不是它们主要的目的，例如网络通信、设备IO等等。

为此，内核为高精度定时器重新设计了一套软件架构，它可以为我们提供纳秒级的定时精度，以满足对精确时间有迫切需求的应用程序或内核驱动，例如多媒体应用，音频设备的驱动程序等等。以下的讨论用hrtimer(high resolution timer)表示高精度定时器。

# 2. 如何组织hrtimer?

我们知道，低分辨率定时器使用5个链表数组来组织timer_list结构，形成了著名的时间轮概念，对于高分辨率定时器，我们期望组织它们的数据结构至少具备以下条件：

* 稳定而且快速的查找能力；
* 快速地插入和删除定时器的能力；
* 排序功能；

内核的开发者考察了多种数据结构，例如基数树、哈希表等等，最终他们选择了**红黑树**（rbtree）来**组织hrtimer**，红黑树已经以库的形式存在于内核中，并被成功地使用在内存管理子系统和文件系统中，随着系统的运行，hrtimer不停地被创建和销毁，新的hrtimer按顺序被插入到红黑树中，树的最左边的节点就是最快到期的定时器，内核用一个hrtimer结构来表示一个高精度定时器：

```cpp
struct hrtimer {
	struct timerqueue_node		node;
	ktime_t				_softexpires;
	enum hrtimer_restart		(*function)(struct hrtimer *);
	struct hrtimer_clock_base	*base;
	unsigned long			state;
        ......
};
```


# 3. hrtimer如何运转

hrtimer的实现需要一定的硬件基础，它的实现依赖于我们前几章介绍的timekeeper和clock_event_device，如果你对`timekeeper`和`clock_event_device`不了解请参考以下文章：

* Linux时间子系统之三：时间的维护者：timekeeper，
* Linux时间子系统之四：定时器的引擎：clock_event_device。

**hrtimer系统**需要通过**timekeeper**获取**当前的时间**，计算**与到期时间的差值**，并根据该差值，设定该cpu的`tick_device`（`clock_event_device`）的下一次的**到期时间**，时间一到，在`clock_event_device`的**事件回调函数**中处理到期的hrtimer。

现在你或许有疑问：前面在介绍`clock_event_device`时，我们知道，**每个cpu**有自己的`tick_device`，通常用于**周期性**地产生**进程调度**和**时间统计的tick事件**，这里又说要用tick_device调度hrtimer系统，通常cpu只有一个tick_device，那他们如何协调工作？这个问题也一度困扰着我，如果再加上`NO_HZ`配置带来tickless特性，你可能会更晕。这里我们先把这个疑问放下，我将在后面的章节中来讨论这个问题，现在我们只要先知道，一旦开启了hrtimer，`tick_device`所关联的`clock_event_device`的事件回调函数会被修改为：`hrtimer_interrupt`，并且会被设置成工作于`CLOCK_EVT_MODE_ONESHOT`单触发模式。

## 3.1. 添加一个hrtimer

要添加一个hrtimer，系统提供了一些api供我们使用，首先我们需要定义一个hrtimer结构的实例，然后用`hrtimer_init`函数对它进行初始化，它的原型如下：

```cpp
void hrtimer_init(struct hrtimer *timer, clockid_t which_clock,
			 enum hrtimer_mode mode);
```

`which_clock`可以是`CLOCK_REALTIME`、`CLOCK_MONOTONIC`、`CLOCK_BOOTTIME`中的一种，mode则可以是相对时间`HRTIMER_MODE_REL`，也可以是绝对时间`HRTIMER_MODE_ABS`。设定回调函数：

```cpp
timer.function = hr_callback;
```

如果定时器**无需指定一个到期范围**，可以在**设定回调函数**后直接使用`hrtimer_start`**激活该定时器**：

```cpp
int hrtimer_start(struct hrtimer *timer, ktime_t tim,
			 const enum hrtimer_mode mode);
```

如果需要指定到期范围，则可以使用`hrtimer_start_range_ns`激活定时器：

```cpp
hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,
			unsigned long range_ns, const enum hrtimer_mode mode);
```

要取消一个hrtimer，使用hrtimer_cancel：

```cpp
int hrtimer_cancel(struct hrtimer *timer);
```

以下两个函数用于推后定时器的到期时间：

```cpp
extern u64
hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval);
 
/* Forward a hrtimer so it expires after the hrtimer's current now */
static inline u64 hrtimer_forward_now(struct hrtimer *timer,
				      ktime_t interval)
{
	return hrtimer_forward(timer, timer->base->get_time(), interval);
}
```

以下几个函数用于获取定时器的当前状态：

```cpp
static inline int hrtimer_active(const struct hrtimer *timer)
{
	return timer->state != HRTIMER_STATE_INACTIVE;
}
 
static inline int hrtimer_is_queued(struct hrtimer *timer)
{
	return timer->state & HRTIMER_STATE_ENQUEUED;
}
 
static inline int hrtimer_callback_running(struct hrtimer *timer)
{
	return timer->state & HRTIMER_STATE_CALLBACK;
}
```

hrtimer_init最终会进入__hrtimer_init函数，该函数的主要目的是初始化hrtimer的base字段，同时初始化作为红黑树的节点的node字段：

```cpp
static void __hrtimer_init(struct hrtimer *timer, clockid_t clock_id,
			   enum hrtimer_mode mode)
{
	struct hrtimer_cpu_base *cpu_base;
	int base;
 
	memset(timer, 0, sizeof(struct hrtimer));
 
	cpu_base = &__raw_get_cpu_var(hrtimer_bases);
 
	if (clock_id == CLOCK_REALTIME && mode != HRTIMER_MODE_ABS)
		clock_id = CLOCK_MONOTONIC;
 
	base = hrtimer_clockid_to_base(clock_id);
	timer->base = &cpu_base->clock_base[base];
	timerqueue_init(&timer->node);
        ......
}
```

hrtimer_start和hrtimer_start_range_ns最终会把实际的工作交由__hrtimer_start_range_ns来完成：

```cpp
int __hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,
		unsigned long delta_ns, const enum hrtimer_mode mode,
		int wakeup)
{
        ......        
        /* 取得hrtimer_clock_base指针 */
        base = lock_hrtimer_base(timer, &flags); 
        /* 如果已经在红黑树中，先移除它: */
        ret = remove_hrtimer(timer, base); ......
        /* 如果是相对时间，则需要加上当前时间，因为内部是使用绝对时间 */
        if (mode & HRTIMER_MODE_REL) {
                tim = ktime_add_safe(tim, new_base->get_time());
                ......
        } 
        /* 设置到期的时间范围 */
        hrtimer_set_expires_range_ns(timer, tim, delta_ns);
        ...... 
        /* 把hrtime按到期时间排序，加入到对应时间基准系统的红黑树中 */
        /* 如果该定时器的是最早到期的，将会返回true */
        leftmost = enqueue_hrtimer(timer, new_base);
        /* 
        * Only allow reprogramming if the new base is on this CPU. 
        * (it might still be on another CPU if the timer was pending) 
        * 
        * XXX send_remote_softirq() ?
        * 定时器比之前的到期时间要早，所以需要重新对tick_device进行编程，重新设定的的到期时间
        */
        if (leftmost && new_base->cpu_base == &__get_cpu_var(hrtimer_bases))
                hrtimer_enqueue_reprogram(timer, new_base, wakeup);
        unlock_hrtimer_base(timer, &flags);
        return ret;
}
```

## 3.2. hrtimer的到期处理

高精度定时器系统有3个入口可以对到期定时器进行处理，它们分别是：

* 没有切换到高精度模式时，在每个jiffie的tick事件中断中进行查询和处理；
* 在HRTIMER_SOFTIRQ软中断中进行查询和处理；
* 切换到高精度模式后，在每个clock_event_device的到期事件中断中进行查询和处理；



# 4. 参考

https://blog.csdn.net/droidphone/article/details/8074892