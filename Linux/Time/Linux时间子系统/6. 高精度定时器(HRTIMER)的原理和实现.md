
# 简介

上一篇文章，我介绍了传统的低分辨率定时器的实现原理。而随着内核的不断演进，大牛们已经对这种低分辨率定时器的精度不再满足，而且，硬件也在不断地发展，系统中的定时器硬件的精度也越来越高，这也给高分辨率定时器的出现创造了条件。内核从2.6.16开始加入了高精度定时器架构。在实现方式上，内核的高分辨率定时器的实现代码几乎没有借用低分辨率定时器的数据结构和代码，内核文档给出的解释主要有以下几点：

* 低分辨率定时器的代码和jiffies的关系太过紧密，并且默认按32位进行设计，并且它的代码已经经过长时间的优化，目前的使用也是没有任何错误，如果硬要基于它来实现高分辨率定时器，势必会打破原有的时间轮概念，并且会引入一大堆#if--#else判断；

* 虽然大部分时间里，时间轮可以实现O(1)时间复杂度，但是当有进位发生时，不可预测的O(N)定时器级联迁移时间，这对于低分辨率定时器来说问题不大，可是它大大地影响了定时器的精度；

* 低分辨率定时器几乎是为“超时”而设计的，并为此对它进行了大量的优化，对于这些以“超时”未目的而使用定时器，它们大多数期望在超时到来之前获得正确的结果，然后删除定时器，精确时间并不是它们主要的目的，例如网络通信、设备IO等等。

为此，内核为高精度定时器重新设计了一套软件架构，它可以为我们提供纳秒级的定时精度，以满足对精确时间有迫切需求的应用程序或内核驱动，例如多媒体应用，音频设备的驱动程序等等。以下的讨论用hrtimer(high resolution timer)表示高精度定时器。

# 如何组织hrtimer?

我们知道，低分辨率定时器使用5个链表数组来组织timer_list结构，形成了著名的时间轮概念，对于高分辨率定时器，我们期望组织它们的数据结构至少具备以下条件：

* 稳定而且快速的查找能力；
* 快速地插入和删除定时器的能力；
* 排序功能；

内核的开发者考察了多种数据结构，例如基数树、哈希表等等，最终他们选择了**红黑树**（rbtree）来**组织hrtimer**，红黑树已经以库的形式存在于内核中，并被成功地使用在内存管理子系统和文件系统中，随着系统的运行，hrtimer不停地被创建和销毁，新的hrtimer按顺序被插入到红黑树中，树的最左边的节点就是最快到期的定时器，内核用一个hrtimer结构来表示一个高精度定时器：

```cpp
struct hrtimer {
	struct timerqueue_node		node;
	ktime_t				_softexpires;
	enum hrtimer_restart		(*function)(struct hrtimer *);
	struct hrtimer_clock_base	*base;
	unsigned long			state;
        ......
};
```


# hrtimer如何运转

hrtimer的实现需要一定的硬件基础，它的实现依赖于我们前几章介绍的timekeeper和clock_event_device，如果你对`timekeeper`和`clock_event_device`不了解请参考以下文章：

* Linux时间子系统之三：时间的维护者：timekeeper，
* Linux时间子系统之四：定时器的引擎：clock_event_device。

**hrtimer系统**需要通过**timekeeper**获取**当前的时间**，计算**与到期时间的差值**，并根据该差值，设定该cpu的`tick_device`（`clock_event_device`）的下一次的**到期时间**，时间一到，在`clock_event_device`的**事件回调函数**中处理到期的hrtimer。

现在你或许有疑问：前面在介绍`clock_event_device`时，我们知道，**每个cpu**有自己的`tick_device`，通常用于**周期性**地产生**进程调度**和**时间统计的tick事件**，这里又说要用tick_device调度hrtimer系统，通常cpu只有一个tick_device，那他们如何协调工作？这个问题也一度困扰着我，如果再加上`NO_HZ`配置带来tickless特性，你可能会更晕。这里我们先把这个疑问放下，我将在后面的章节中来讨论这个问题，现在我们只要先知道，一旦开启了hrtimer，`tick_device`所关联的`clock_event_device`的事件回调函数会被修改为：`hrtimer_interrupt`，并且会被设置成工作于`CLOCK_EVT_MODE_ONESHOT`单触发模式。

## 添加一个hrtimer

要添加一个hrtimer，系统提供了一些api供我们使用，首先我们需要定义一个hrtimer结构的实例，然后用`hrtimer_init`函数对它进行初始化，它的原型如下：

```cpp
void hrtimer_init(struct hrtimer *timer, clockid_t which_clock,
			 enum hrtimer_mode mode);
```

# 参考

https://blog.csdn.net/droidphone/article/details/8074892