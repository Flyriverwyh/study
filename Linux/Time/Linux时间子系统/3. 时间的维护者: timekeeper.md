
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 简介](#1-简介)
- [2. 时间的种类](#2-时间的种类)
  - [2.1. RTC时间](#21-rtc时间)
  - [2.2. xtime](#22-xtime)
  - [2.3. monotonic time](#23-monotonic-time)
  - [2.4. raw monotonic time](#24-raw-monotonic-time)
  - [2.5. boot time](#25-boot-time)
  - [2.6. 小结](#26-小结)
- [3. struct timerkeeper](#3-struct-timerkeeper)
- [4. timekeeper的初始化](#4-timekeeper的初始化)
- [5. 时间的更新](#5-时间的更新)
- [6. 获取时间](#6-获取时间)
- [7. 参考](#7-参考)

<!-- /code_chunk_output -->

# 1. 简介

前两节讨论了用于计时的时钟源：clocksource，以及内核内部时间的一些表示方法，但是对于真实的用户来说，我们感知的是真实世界的真实时间，也就是所谓的墙上时间，clocksource只能提供一个按给定频率不停递增的周期计数，如何把它和真实的墙上时间相关联？本节的内容正是要讨论这一点。

# 2. 时间的种类

内核管理着多种时间，它们分别是：

* RTC时间
* wall time：墙上时间
* monotonic time
* raw monotonic time
* boot time：总启动时间

## 2.1. RTC时间

在PC中，RTC时间又叫**CMOS时间**，它通常由一个**专门的计时硬件**来实现，软件可以读取该硬件来获得年月日、时分秒等时间信息，而在**嵌入式系统**中，有使用专门的**RTC芯片**，也有直接把RTC集成到**Soc芯片**中，读取Soc中的**某个寄存器**即可获取当前时间信息。

一般来说，RTC是一种**可持续计时**的，也就是说，不管系统是否上电，RTC中的时间信息都不会丢失，计时会一直持续进行，硬件上通常使用一个**后备电池**对RTC硬件进行单独的供电。因为RTC硬件的多样性，开发者需要为**每种RTC时钟硬件**提供**相应的驱动程序**，**内核和用户空间**通过**驱动程序**访问RTC硬件来获取或设置时间信息。

## 2.2. xtime

xtime和RTC时间一样，都是人们日常所使用的**墙上时间**，只是RTC时间的精度通常比较低，大多数情况下只能达到毫秒级别的精度，如果是使用外部的RTC芯片，访问速度也比较慢，为此，内核维护了另外一个wall time时间：xtime，取决于用于对xtime计时的clocksource，它的精度甚至可以达到纳秒级别，因为xtime实际上是一个**内存中的变量**，它的访问速度非常快，内核大部分时间都是使用**xtime**来获得当前时间信息。

xtime记录的是自**1970年1月1日24时**到**当前**时刻所经历的**纳秒数**。

## 2.3. monotonic time

该时间自系统开机后就一直**单调地增加**，它不像xtime可以因用户的调整时间而产生跳变，不过该时间**不计算系统休眠的时间**，也就是说，系统休眠时，monotoic时间不会递增。

## 2.4. raw monotonic time

该时间与monotonic时间类似，也是单调递增的时间，唯一的不同是：raw monotonic time“更纯净”，他**不会受到NTP时间**调整的影响，它代表着**系统独立时钟硬件**对时间的统计。

## 2.5. boot time

与monotonic时间相同，不过会累加上系统休眠的时间，它代表着系统上电后的总时间。

## 2.6. 小结

时间种类 | 精度（统计单位） | 访问速度 | 累计休眠时间 | 受NTP调整的影响
-----|----------|------|--------|----------
RTC | 低 | 慢 | Yes | Yes
xtime | 高 | 快 | Yes | Yes
monotonic | 高 | 快 | No | Yes
raw monotonic | 高 | 快 | No | No
boot time | 高 | 快 | Yes | Yes

# 3. struct timerkeeper

内核用timekeeper结构来组织与时间相关的数据，它的定义如下：

早期的内核版本中，`xtime`、`wall_to_monotonic`、`raw_time`其实是定义为全局静态变量，到我目前的版本（V3.4.10），这几个变量被移入到了`timekeeper`结构中，现在只需维护一个**timekeeper全局静态变量**即可：

```cpp
static struct timekeeper timekeeper;
```

# 4. timekeeper的初始化

timekeeper的初始化由`timekeeping_init`完成，该函数在`start_kernel`的初始化序列中被调用，`timekeeping_init`首先从RTC中获取当前时间：

# 5. 时间的更新

# 6. 获取时间



# 7. 参考

https://blog.csdn.net/DroidPhone/article/details/7989566