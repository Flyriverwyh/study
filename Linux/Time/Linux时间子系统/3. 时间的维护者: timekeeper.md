
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 简介](#1-简介)
- [2. 时间的种类](#2-时间的种类)
  - [2.1. RTC时间](#21-rtc时间)
  - [2.2. xtime](#22-xtime)
  - [2.3. monotonic time](#23-monotonic-time)
  - [2.4. raw monotonic time](#24-raw-monotonic-time)
  - [2.5. boot time](#25-boot-time)
  - [2.6. 小结](#26-小结)
- [3. struct timerkeeper](#3-struct-timerkeeper)
- [4. timekeeper的初始化](#4-timekeeper的初始化)
- [5. 时间的更新](#5-时间的更新)
- [6. 获取时间](#6-获取时间)
- [7. 参考](#7-参考)

<!-- /code_chunk_output -->

# 1. 简介

前两节讨论了用于计时的时钟源：clocksource，以及内核内部时间的一些表示方法，但是对于真实的用户来说，我们感知的是真实世界的真实时间，也就是所谓的墙上时间，clocksource只能提供一个按给定频率不停递增的周期计数，如何把它和真实的墙上时间相关联？本节的内容正是要讨论这一点。

# 2. 时间的种类

内核管理着多种时间，它们分别是：

* RTC时间
* wall time：墙上时间
* monotonic time
* raw monotonic time
* boot time：总启动时间

## 2.1. RTC时间

在PC中，RTC时间又叫**CMOS时间**，它通常由一个**专门的计时硬件**来实现，软件可以读取该硬件来获得年月日、时分秒等时间信息，而在**嵌入式系统**中，有使用专门的**RTC芯片**，也有直接把RTC集成到**Soc芯片**中，读取Soc中的**某个寄存器**即可获取当前时间信息。

一般来说，RTC是一种**可持续计时**的，也就是说，不管系统是否上电，RTC中的时间信息都不会丢失，计时会一直持续进行，硬件上通常使用一个**后备电池**对RTC硬件进行单独的供电。因为RTC硬件的多样性，开发者需要为**每种RTC时钟硬件**提供**相应的驱动程序**，**内核和用户空间**通过**驱动程序**访问RTC硬件来获取或设置时间信息。

## 2.2. xtime

xtime和RTC时间一样，都是人们日常所使用的**墙上时间**，只是**RTC时间**的精度通常比较低，大多数情况下只能达到**毫秒级别的精度**，如果是使用外部的RTC芯片，访问速度也比较慢，为此，内核维护了另外一个**wall time时间**：xtime，取决于用于对xtime计时的clocksource，它的精度甚至可以达到纳秒级别，因为xtime实际上是一个**内存中的变量**，它的访问速度非常快，内核大部分时间都是使用**xtime**来获得当前时间信息。

xtime记录的是自**1970年1月1日24时**到**当前**时刻所经历的**纳秒数**。

## 2.3. monotonic time

该时间自系统开机后就一直**单调地增加**，它不像xtime可以因用户的调整时间而产生跳变，不过该时间**不计算系统休眠的时间**，也就是说，系统休眠时，monotoic时间不会递增。

## 2.4. raw monotonic time

该时间与monotonic时间类似，也是单调递增的时间，唯一的不同是：raw monotonic time“更纯净”，他**不会受到NTP时间**调整的影响，它代表着**系统独立时钟硬件**对时间的统计。

## 2.5. boot time

与monotonic时间相同，不过会累加上系统休眠的时间，它代表着系统上电后的总时间。

## 2.6. 小结

时间种类 | 精度（统计单位） | 访问速度 | 累计休眠时间 | 受NTP调整的影响
-----|----------|------|--------|----------
RTC | 低 | 慢 | Yes | Yes
xtime | 高 | 快 | Yes | Yes
monotonic | 高 | 快 | No | Yes
raw monotonic | 高 | 快 | No | No
boot time | 高 | 快 | Yes | Yes

# 3. struct timerkeeper

内核用timekeeper结构来组织与时间相关的数据，它的定义如下：

```cpp
struct timekeeper {
	struct clocksource *clock;    /* Current clocksource used for timekeeping. */
	u32	mult;    /* NTP adjusted clock multiplier */
	int	shift;	/* The shift value of the current clocksource. */
	cycle_t cycle_interval;	/* Number of clock cycles in one NTP interval. */
	u64	xtime_interval;	/* Number of clock shifted nano seconds in one NTP interval. */
	s64	xtime_remainder;	/* shifted nano seconds left over when rounding cycle_interval */
	u32	raw_interval;	/* Raw nano seconds accumulated per NTP interval. */
 
	u64	xtime_nsec;	/* Clock shifted nano seconds remainder not stored in xtime.tv_nsec. */
	/* Difference between accumulated time and NTP time in ntp
	 * shifted nano seconds. */
	s64	ntp_error;
	/* Shift conversion between clock shifted nano seconds and
	 * ntp shifted nano seconds. */
	int	ntp_error_shift;
 
	struct timespec xtime;	/* The current time */
 
	struct timespec wall_to_monotonic;
	struct timespec total_sleep_time;	/* time spent in suspend */
	struct timespec raw_time;	/* The raw monotonic time for the CLOCK_MONOTONIC_RAW posix clock. */
 
	ktime_t offs_real;	/* Offset clock monotonic -> clock realtime */
 
	ktime_t offs_boot;	/* Offset clock monotonic -> clock boottime */
 
	seqlock_t lock;	/* Seqlock for all timekeeper values */
};
```

其中的xtime字段就是上面所说的墙上时间，它是一个timespec结构的变量，它记录了**自1970年1月1日以来所经过的时间**，因为是**timespec结构**，所以它的精度可以达到**纳秒级**，当然那要取决于系统的硬件是否支持这一精度。

内核除了用xtime表示墙上的真实时间外，还维护了另外一个时间：monotonic time，可以把它理解为自系统启动以来所经过的时间，该时间只能单调递增，可以理解为xtime虽然正常情况下也是递增的，但是毕竟用户可以主动向前或向后调整墙上时间，从而修改xtime值。但是monotonic时间不可以往后退，系统启动后只能不断递增。奇怪的是，内核并没有直接定义一个这样的变量来记录monotonic时间，而是定义了一个变量`wall_to_monotonic`，记录了**墙上时间**和monotonic时间之间的偏移量，当需要获得**monotonic时间**时，把`xtime`和`wall_to_monotonic`相加即可，因为默认启动时monotonic时间为0，所以实际上`wall_to_monotonic`的值是一个**负数**，它和xtime同一时间被初始化，请参考`timekeeping_init`函数。

计算monotonic时间要去除系统休眠期间花费的时间，内核用total_sleep_time记录休眠的时间，每次休眠醒来后重新累加该时间，并调整wall_to_monotonic的值，使其在系统休眠醒来后，monotonic时间不会发生跳变。因为wall_to_monotonic值被调整。所以如果想获取boot time，需要加入该变量的值：

早期的内核版本中，`xtime`、`wall_to_monotonic`、`raw_time`其实是定义为全局静态变量，到我目前的版本（V3.4.10），这几个变量被移入到了`timekeeper`结构中，现在只需维护一个**timekeeper全局静态变量**即可：

```cpp
static struct timekeeper timekeeper;
```

# 4. timekeeper的初始化

timekeeper的初始化由`timekeeping_init`完成，该函数在`start_kernel`的初始化序列中被调用，`timekeeping_init`首先从RTC中获取当前时间：

# 5. 时间的更新

# 6. 获取时间

timekeeper提供了一系列的接口用于获取各种时间信息。

* void getboottime(struct timespec *ts);    获取系统启动时刻的实时时间
* void get_monotonic_boottime(struct timespec *ts);     获取系统启动以来所经过的时间，包含休眠时间
* ktime_t ktime_get_boottime(void);   获取系统启动以来所经过的c时间，包含休眠时间，返回ktime类型
* ktime_t ktime_get(void);    获取**系统启动以来所经过的时间**，**不包含休眠时间**，返回ktime类型
* void ktime_get_ts(struct timespec *ts) ;   获取系统启动以来所经过的c时间，不包含休眠时间，返回timespec结构
* unsigned long get_seconds(void);    返回xtime中的秒计数值
* struct timespec current_kernel_time(void);    返回内核最后一次更新的xtime时间，不累计最后一次更新至今clocksource的计数值
* void getnstimeofday(struct timespec *ts);    获取当前时间，返回timespec结构
* void do_gettimeofday(struct timeval *tv);    获取当前时间，返回timeval结构

# 7. 参考

https://blog.csdn.net/DroidPhone/article/details/7989566