
# 简介

clock source用于为linux内核提供一个**时间基线**，如果你用linux的**date命令**获取**当前时间**，内核会**读取当前的clock source**(时钟源)，转换并返回合适的时间单位给用户空间。

在**硬件层**，时钟源通常实现为一个由**固定时钟频率驱动的计数器**，计数器只能**单调地增加**，直到**溢出为止**。

**时钟源**是内核计时的基础，系统启动时，内核通过**硬件RTC**获得**当前时间**，在这以后，在大多数情况下，内核通过**选定的时钟源**更新**实时时间信息**（墙上时间），而**不再读取RTC**的时间。

本节的内核代码树基于V3.4.10。

# struct clocksource结构体

内核用一个clocksource结构对真实的时钟源进行软件抽象，现在我们从clock source的数据结构开始，它的定义如下：

```cpp
// include/linux/clocksource.h
struct clocksource {
	/*
	 * Hotpath data, fits in a single cache line when the
	 * clocksource itself is cacheline aligned.
	 */
	cycle_t (*read)(struct clocksource *cs);
	cycle_t cycle_last;
	cycle_t mask;
	u32 mult;
	u32 shift;
	u64 max_idle_ns;
	u32 maxadj;
#ifdef CONFIG_ARCH_CLOCKSOURCE_DATA
	struct arch_clocksource_data archdata;
#endif
 
	const char *name;
	struct list_head list;
	int rating;
	int (*enable)(struct clocksource *cs);
	void (*disable)(struct clocksource *cs);
	unsigned long flags;
	void (*suspend)(struct clocksource *cs);
	void (*resume)(struct clocksource *cs);
 
	/* private: */
#ifdef CONFIG_CLOCKSOURCE_WATCHDOG
	/* Watchdog related data, used by the framework */
	struct list_head wd_list;
	cycle_t cs_last;
	cycle_t wd_last;
#endif
} ____cacheline_aligned;
```

只关注clocksource中的几个重要的字段。

## rating: 时钟源的精度

**同一个设备**下，可以有**多个时钟源**，每个时钟源的**精度**由驱动它的**时钟频率**决定，比如一个由**10MHz**时钟驱动的时钟源，他的精度就是**100nS**。

clocksource结构中有一个**rating字段**，代表着该时钟源的**精度范围**，它的取值范围如下：

* 1--99： 不适合于用作实际的时钟源，只用于启动过程或用于测试；
* 100--199：基本可用，可用作真实的时钟源，但不推荐；
* 200--299：精度较好，可用作真实的时钟源；
* 300--399：很好，精确的时钟源；
* 400--499：理想的时钟源，如有可能就必须选择它作为时钟源；

## read回调函数

时钟源本身不会产生中断，要获得时钟源的当前计数，只能通过主动调用它的read回调函数来获得当前的计数值，注意这里只能获得计数值，也就是所谓的cycle，要获得相应的时间，必须要借助clocksource的mult和shift字段进行转换计算。

## mult和shift字段



# clocksource的注册和初始化

# 参考

https://blog.csdn.net/DroidPhone/article/details/7975694