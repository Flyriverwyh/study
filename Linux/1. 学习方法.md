
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 内核文档](#1-内核文档)
- [2. 代码阅读](#2-代码阅读)
- [3. feature学习](#3-feature学习)
  - [3.1. 初始实现](#31-初始实现)
    - [3.1.1. 最初合入的patch/patchset](#311-最初合入的patchpatchset)
    - [3.1.2. 了解初始背景](#312-了解初始背景)
      - [3.1.2.1. pwclient 工具](#3121-pwclient-工具)
      - [3.1.2.2. 利用 mail list archive](#3122-利用-mail-list-archive)
    - [3.1.3. 研究初始的代码实现](#313-研究初始的代码实现)
  - [3.2. 最新版代码](#32-最新版代码)
  - [3.3. 中间版本](#33-中间版本)
- [4. 特性回合](#4-特性回合)

<!-- /code_chunk_output -->

# 1. 内核文档

先学习内核文档, `Documentation/`下, 一般包含背景介绍、实现原理和实践案例. 所以一定要先看下相应的 Doc.

# 2. 代码阅读

注: 所有git可以用tig

1. 手册为核心

以手册为核心阅读代码, 最起码两遍

看手册的描述, 然后找代码的对应实现, 可以对比多个实现, 比如 vmx 相关实现, 可以对比看 kvm、xen 和 ACRN(https://github.com/projectacrn/acrn-hypervisor)

手册中涉及的指令, 一般在系统指令部分会专门描述该指令行为的伪代码.

2. 代码为核心

git log 某个文件，按时间线从头看git commit

```
git log arch/x86/kvm/lapic.c

tig arch/x86/kvm/lapic.c
```

代码为主，google搜索patch的讨论

# 3. feature学习

每个feature整理一个PPT，分享讲出来.

feature从最开始的实现代码(一般从定义的新的变量查看相应commit)看起来, 能了解整个思想

核心思想: 以不变找万变

## 3.1. 初始实现

### 3.1.1. 最初合入的patch/patchset

* 第一步: 获取特性相关的最初合入的patch/patchset. 

一般从变量/模块参数入手(变量不会改, 往往能查到最初的patch)

通过`tig blame $file_name`查看结构体成员或者模块参数的 commit, 就能确定**最初的patch set**的某一个**commit**.

### 3.1.2. 了解初始背景

* 第二步: 确定最初author提交给社区的**真正第一版patchset/RFC**, 甚至第一次有人提出的疑问(从而引发的patchset).

因为这里面往往体现了author提出这个patch set的**最初的原因**且实现比较简单.

有两种手段

#### 3.1.2.1. pwclient 工具

> pwclient 工具, 这个往往不靠谱

使用 pwclient 工具, 确定最初合入的patch set, 具体参照`Study repo: Linux/Community/3. 从邮件列表获取patch.md`

#### 3.1.2.2. 利用 mail list archive

> 通过mail list archive查找

通过第一步找到的commit的subject, 在 mail list archive 中找到最初的patchset/RFC并了解当时的讨论

mail list archive, 官方的是
* https://patchwork.kernel.org/, 功能完善
* https://lore.kernel.org/lists.html, 

> 具体参见`Study repo: Linux/Community/1. 邮件列表.md`, 那里面有个示例参考

### 3.1.3. 研究初始的代码实现

直接reset回当时版本, 查看系统中的调用情况等等, 从而进行代码分析

## 3.2. 最新版代码

然后看一下最新的代码的实现, 如果核心思想没有变, 这样子就结束了. 如果有方案有更新, 那同样参照上面的方法追踪下新的方案的初始版本, 再看最新代码的实现. 

## 3.3. 中间版本

`tig mm/memcontrol.c`, tig查看某个文件, 从最开始的commit记录开始看, 因为一般文件名不会变化.

注: 但是内核代码往往涉及的commit太多, 所以可能会比较多

# 4. 特性回合

先对比下upstream的feature流程和产品的feature流程, 心里大概清楚差异点.

方法一(推荐):

盯着某个feature的核心实现文件

`tig arch/x86/kvm/lapic.c`

从最开始的commit逐个backport

然后提交时候, 回合一个patch便提交一个, 不要嫌麻烦最后整个作为一个patch.

方法二:

以最初的那个feature的patch set为核心逐个backport, 先把patch set中每个patch给backport了, 然后再逐行核对目前upstream的代码, 决定是否要backport修改(一般bug肯定要backport).

如果有feature依赖, 先backport被依赖的feature.










