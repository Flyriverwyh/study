
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 用途](#1-用途)
- [2. 使用方法](#2-使用方法)
- [3. ls例子](#3-ls例子)
  - [3.1. task-clock: 真正占用的处理器时间](#31-task-clock-真正占用的处理器时间)
  - [3.2. context-switches: 上下文切换](#32-context-switches-上下文切换)
  - [3.3. cpu-migration: 处理器的负载均衡](#33-cpu-migration-处理器的负载均衡)
  - [3.4. page-faults:](#34-page-faults)
  - [3.5. cycles: 处理器周期数](#35-cycles-处理器周期数)
  - [3.6. instructions: 处理器指令数](#36-instructions-处理器指令数)
  - [3.7. branches: 分支指令数](#37-branches-分支指令数)
- [4. 参数介绍](#4-参数介绍)
  - [4.1. 常用参数](#41-常用参数)
  - [4.2. 指定性能事件](#42-指定性能事件)
  - [4.3. tracepoint过滤](#43-tracepoint过滤)
  - [4.4. 禁止子任务继承](#44-禁止子任务继承)
  - [4.5. 时间](#45-时间)
  - [4.6. 重复执行次数](#46-重复执行次数)

<!-- /code_chunk_output -->

# 1. 用途

用来剖析一个**指定应用程序**的性能概况。

perf 除了可以采样(使用perf record)（包括call stack trace），还可以用于event计数。

perf stat就是用于**event计数**的，可以跟踪**指定命令**的event计数。

# 2. 使用方法

查看帮助

```
./perf help stat
```

```
perf stat [-e <EVENT> | --event=EVENT] [-a] <command>
perf stat [-e <EVENT> | --event=EVENT] [-a] -- <command> [<options>]
```

# 3. ls例子

比如查看ls程序的典型性能数据

![2020-07-20-14-26-07.png](./images/2020-07-20-14-26-07.png)

从图上可以看到，perf stat 工具利用 **10 个典型性能事件**剖析了应用程序。

## 3.1. task-clock: 真正占用的处理器时间

`task‐clock` 事件表示目标任务’ls’**真正占用处理器的时间**，单位是**毫秒**。我们将其称为任务执行时间。

如图所示，’ls’在处理器上执行了 `3.98` 毫秒。`“0.256 CPUs utilized”`表示目标任务的**处理器占用率**。处理器占用率表示**目标任务的执行时间**与**持续时间的比值**。持续时间是指从任务提交到执行结束之间的**总时间**。

## 3.2. context-switches: 上下文切换

对操作系统有过了解的读者应该知道，Linux 这种多任务分时操作系统中，一个任务不太可能在执行期间始终占据处理器。操作系统会根据调度策略(linux 目前使用 CFS 调度算法)合理安排各个任务轮流使用处理器，**每次调度**会产生**一次上下文切换**。在此期间操作系统还需处理大量中断。因此，一个任务的执行时间可能会很短，但是它的持续时间会远高于此(除非此任务是优先级最高的实时任务)。 

以图中的例子来说，’ls’的执行时间为 `3.98` 毫秒，而持续为 `15.58` 毫秒，处理器占用率为 `0.256`. 在此期间，系统共发生了 45 次上下文切换。平均每秒发生 `0.011*10^6` 次。上下文切换次数的**均值**是**上下文切换次数**与**任务执行时间**的**比值**。

## 3.3. cpu-migration: 处理器的负载均衡

在多(核)处理器系统中，Linux 为了维持**各个处理器的负载均衡**，会在特定条件下将**某个任务**从一个处理器**迁往另外一个处理器**。此时，我们便说发生了一次处理器迁移。从图上看到，ls 在执行期间**没有被操作系统迁移过**。(`cpu-migration`)

## 3.4. page-faults:

Linux 的内存管理子系统采用了**分页机制**。当应用程序请求的**页面尚未建立**、请求的**页面不在内存**中、或者**请求的页面虽然在内存**中，但**尚未建立**物理地址与虚拟地址的**映射关系**时，都会**触发一次缺页异常**(`page‐fault`)。内核在**捕获缺页异常**时，根据异常种类进行相应的处理。另外，**TLB 不命中**，**页面访问权限不匹配**等情况也会触发**缺页异常**。

内核中对 page faults (`PERF_COUNT_SW_PAGE_FAULTS`)事件的精确定义是**缺页异常的处理函数** `do_page_fault()`被执行。程序’ls’在执行期间共触发了 `320` 次缺页 异常。平均发生率为每秒 `0.08*10^6` 次。

## 3.5. cycles: 处理器周期数

‘cycles’为’ls’程序消耗的处理器周期数。如果将被’ls’占据的**那部分时间**看作**一个抽象处理器**，它的**主频**只需为 `0.75GHz` 便可以在 `3.98` 毫秒内完成’ls’命令的处理。

## 3.6. instructions: 处理器指令数

‘instructions’是指命令’ls’执行期间产生的处理器指令数。**IPC**(**instructions per cycle**)为 `0.69`。

**IPC** 是评价**处理器**与**应用程序性能**的重要指标。在 X86 这种 CSIC 处理器上，**很多指令**需要**多个处理器周期**才能执行完毕。另外，**有些指令**在**流水线**上未必能成功引退(retired)，从而形成**无效指令**。

**长指令**与**无效执行越多**，**IPC 就越低**，处理器的利用率与程序的执行效率也就越低。因此，IPC 在一定程度下， 让我们对程序的执行效率有一个**宏观认识**。

## 3.7. branches: 分支指令数

‘branches’是指程序在执行期间遇到的**分支指令数**。`’branch‐misses’`则是**预测错误的分支指令数**。

绝大多数现代处理器都具有**分支预测**与 `OOO(Out‐of‐Order) 乱序执行`机制，以充分利用 CPU 内部的资源，**减少流水线停顿周期**。当处理器遇到分支指令时，正常来说，需要等待分支条件计算完毕才能知道后续指令流该往何处跳转。这就导致在**等待分支条件计算期间**，流水线上出现**若干周期的停顿**(流水线 Hazard)。

体系结构的经典著作《计算机体系结构:量化研究方法》上说，**分支指令**产生的**性能影响**为 `10%~30%[2]`，流水线越长，性能影响就越大。为了减少分支指令造成的流水线停顿，从 P5 处理器开始引入了分支预测机制。当处理 器无法判断指令的跳转方向时，便通过分支预测单元选择一个最有可能的跳转方 向。但是，既然是预测，就存在预测失败的可能。当分支预测失败时，会对处理 器周期造成较大的浪费。在 5 发射 10 级流水线的处理器中，当分支预测的准确 率为 90%时，处理器带宽会浪费 47%;而如果准确率提高到 96%，带宽浪费可降 低至 `26%[3]`。Core i7 以及 Xeon 5500 等较新的处理器在**分支预测失效**时，已经**无需刷新全部流水线**，但错误指令加载与计算导致的无效开销依然不可小觑。这就 要求我们在编写代码时，应**尽量减少分支预测错误的次数**。但在此之前，通过 perf stat，perf top，perf record 等工具**查查分支预测失效率**，以及**导致分支预测失效过高**的**热点代码**是非常有必要的。

’branch misses’一行中的`’***% of all branches’`即为目标程序执行期间的**分支预测失效率**。

# 4. 参数介绍

## 4.1. 常用参数

* `'-e'`: 指定性能事件
* `'-p'`: 指定待分析进程的 PID 
* `'-t'`: 指定待分析线程的 TID
* `'-r N'`: 连续分析N次
* `'-d'`: 全面性能分析，采用更多的性能事件

```
./perf stat -p 178264 -e kvm:*
```

## 4.2. 指定性能事件

`‘‐e’ or ‘‐‐event’ <event>`

选择性能事件，参考 perf top 与 perf list 的相关章节。

## 4.3. tracepoint过滤

`‘‐‐filter’ <filter>`

配合 Tracepoints 使用，等同于 ftrace 中 filter 的概念，根据正则表达式追踪指定的函数。

## 4.4. 禁止子任务继承

`‘‐i’ or ‘‐‐no‐inherit’`

禁止子任务继承父任务的性能计数器。类似于’perf top’中的’‐i’参数，只是此
处是禁止继承机制。

## 4.5. 时间

`‘‐c’ or ‘‐‐scale’`

要求底层驱动记录计数器的 run 与 enabled 时间。此选项默认打开，且不能关闭。

## 4.6. 重复执行次数

`‘‐r’ or ‘‐‐repeat’ <n>`

重复执行 n 次目标程序，并给出性能指标在 n 次执行中的变化范围。

```
./perf stat ‐r 10 ls > /dev/null
```

将重复执行 10 次”ls > /dev/null”，并给出如下结果:

![2020-07-20-17-10-19.png](./images/2020-07-20-17-10-19.png)
