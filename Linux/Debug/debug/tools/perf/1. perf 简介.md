
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 系统级性能优化](#1-系统级性能优化)
- [2. Perf 简介](#2-perf-简介)
  - [2.1. 基本原理](#21-基本原理)
- [一个简单例子](#一个简单例子)
- [3. Perf的相关依赖](#3-perf的相关依赖)
  - [3.1. Symbols: 符号表](#31-symbols-符号表)
  - [3.2. perf annotate](#32-perf-annotate)
  - [3.3. Stack Traces](#33-stack-traces)
  - [3.4. 小结](#34-小结)
- [4. Perf 安装](#4-perf-安装)
  - [安装依赖库](#安装依赖库)
  - [4.1. 测试](#41-测试)
  - [4.2. 编译](#42-编译)
  - [4.3. 安装](#43-安装)
  - [4.4. 帮助文档](#44-帮助文档)
- [5. Perf性能事件](#5-perf性能事件)
  - [5.1. 三种类型性能事件](#51-三种类型性能事件)
    - [5.1.1. 硬件性能事件](#511-硬件性能事件)
    - [5.1.2. 软件性能事件](#512-软件性能事件)
    - [5.1.3. Tracingpoint事件](#513-tracingpoint事件)
    - [5.1.4. 动态追踪](#514-动态追踪)
    - [5.1.5. 事件限定符](#515-事件限定符)
  - [5.2. 性能事件的属性](#52-性能事件的属性)
    - [5.2.1. PMI中断和PEBS中断](#521-pmi中断和pebs中断)
    - [5.2.2. 性能事件的精度级别](#522-性能事件的精度级别)
    - [5.2.3. 其他属性](#523-其他属性)
  - [5.3. 没有预定义字符描述的硬件性能事件](#53-没有预定义字符描述的硬件性能事件)
  - [5.4. perf list查看所有性能事件](#54-perf-list查看所有性能事件)
  - [5.5. 性能事件指定错误](#55-性能事件指定错误)
- [6. Perf 功能概述](#6-perf-功能概述)
  - [6.1. 全局性概况](#61-全局性概况)
  - [6.2. 全局细节](#62-全局细节)
  - [6.3. 特定功能分析](#63-特定功能分析)
  - [6.4. perf record](#64-perf-record)
  - [6.5. 可视化工具perf timechart](#65-可视化工具perf-timechart)
- [7. 常用命令](#7-常用命令)
  - [7.1. 三种命令划分](#71-三种命令划分)
- [8. 简单示例](#8-简单示例)
  - [8.1. cycles原理](#81-cycles原理)
- [9. 参考](#9-参考)

<!-- /code_chunk_output -->

参照: http://www.brendangregg.com/perf.html

# 1. 系统级性能优化

系统级性能优化是指为了提高应用程序对操作系统资源与硬件资源的使用 效率，或者为了提高操作系统对硬件资源的使用效率而进行的代码优化。通过提 高对操作系统资源与硬件资源的利用率，使得应用程序与基础软硬件平台具有更 好的交互性，往往可以显著提升应用程序的执行速度和稳定性。

**系统级性能优化**包含**2个阶段**：

1. 性能剖析（**performance profiling**）：**寻找性能瓶颈**，查找引发性能问题的原因及热点代码。
2. 代码优化：针对具体的性能问题而**优化代码与编译选项**，以改善软件性能。

在代码优化阶段往往需要凭借开发者的经验，编写简洁高效的代码，甚至在汇编 语言级别合理使用各种指令，合理安排各种指令的执行顺序。

而在**性能剖析阶段**，则需要借助于现有的**profiling工具**，如 perf，VTune，Oprofile 等。

在Linux下诊断的工具比较多，比如systemtap, dtrace, perf。

# 2. Perf 简介

本文将介绍一下perf的用法，网上很多叫法如`perf_events` , `perf profiler` , `Performance Counters for Linux(Linux性能计数器, PCL)`。叫法不同，都指perf。

通过perf，你可以发现以下问题的答案：

* 为什么内核使用**太多的CPU**，**哪些代码**使用了这些CPU时间
* **什么代码**导致**CPU二级缓存不命中**
* CPU是否因**内存、IO**而卡顿
* 什么代码在**分配内存**，分配了**多少**
* 什么触发了**TCP重传**
* 某个内核函数是否**被频繁调用**
* 线程**离开CPU的原因** 

## 2.1. 基本原理

Perf是一个基于内核的子系统，它提供一个**性能分析框架**，它以**性能事件**为基础，基于**对这些事件！！！采样！！！** 进行**性能统计**原理，可用于性能瓶颈的查找与热点代码的定位.

perf的采样是**基于事件**进行的。**采样的周期**以**事件的数量来表示**，而**非基于时间**。当**目标事件计数溢出指定的数值！！！**，则**产生一个采样**。

Perf不但可以分析制定应用程序的性能问题（per thread），也可以用来分析内核的性能问题。

- 要想从剖析中获得更多**内核相关**信息，你需要`符号（Symbol）`和`栈追踪`，这可能需要安装额外的包，甚至使用**特定选项重新编译**你的内核。
- 剖析**用户空间代码**时，也要求目标应用程序的**调试信息（符号表**）被保留。

总之perf是一款很牛逼的综合性分析工具，大到系统全局性性能，再小到进程线程级别，甚至到函数及汇编级别。

perf利用Linux的**trace特性**，可以用于实时跟踪，统计event计数(perf stat)；或者使用采样(perf record)，报告(perf report|script|annotate)的使用方式进行诊断。perf命令行接口并不能利用所有的Linux trace特性，有些trace需要通过ftrace接口使用。

对于perf和ftrace的使用见 https://github.com/brendangregg/perf-tools

而Linux有多少性能事件呢?? 下面会说到。

# 一个简单例子

追踪磁盘I/O:

```
# perf record -e block:block_rq_issue -ag
^C
# ls -l perf.data
-rw------- 1 root root 3458162 Jan 26 03:03 perf.data
# perf report
[...]
# Samples: 2K of event 'block:block_rq_issue'
# Event count (approx.): 2216
#
# Overhead       Command      Shared Object                Symbol
# ........  ............  .................  ....................
#
    32.13%            dd  [kernel.kallsyms]  [k] blk_peek_request
                      |
                      --- blk_peek_request
                          virtblk_request
                          __blk_run_queue
                         |          
                         |--98.31%-- queue_unplugged
                         |          blk_flush_plug_list
                         |          |          
                         |          |--91.00%-- blk_queue_bio
                         |          |          generic_make_request
                         |          |          submit_bio
                         |          |          ext4_io_submit
                         |          |          |          
                         |          |          |--58.71%-- ext4_bio_write_page
                         |          |          |          mpage_da_submit_io
                         |          |          |          mpage_da_map_and_submit
                         |          |          |          write_cache_pages_da
                         |          |          |          ext4_da_writepages
                         |          |          |          do_writepages
                         |          |          |          __filemap_fdatawrite_range
                         |          |          |          filemap_flush
                         |          |          |          ext4_alloc_da_blocks
                         |          |          |          ext4_release_file
                         |          |          |          __fput
                         |          |          |          ____fput
                         |          |          |          task_work_run
                         |          |          |          do_notify_resume
                         |          |          |          int_signal
                         |          |          |          close
                         |          |          |          0x0
                         |          |          |          
                         |          |           --41.29%-- mpage_da_submit_io
[...]
```

这里的`perf record`命令用来追踪`block:block_rq_issue`探针, 当发起块设备I/O(磁盘io)请求时候会触发该探针.

`-a`选项用于追踪所有CPUs, `-g`用于记录调用栈, 追踪数据保存到了`perf.data`文件.

`perf report`输出显示 2216 次`disk I/O`事件被追踪,

# 3. Perf的相关依赖

我们看到perf支持这么多的事件和trace，它依赖了很多的接口来干这件事情。

## 3.1. Symbols: 符号表

没有符号表，**无法**将**内存地址**翻译成函数和变量名。

例如，无符号表的跟踪显示如下

```
    57.14%     sshd  libc-2.15.so        [.] connect           
               |
               --- connect
                  |          
                  |--25.00%-- 0x7ff3c1cddf29
                  |          
                  |--25.00%-- 0x7ff3bfe82761
                  |          0x7ff3bfe82b7c
                  |          
                  |--25.00%-- 0x7ff3bfe82dfc
                   --25.00%-- [...]
```

有符号表的跟踪显示如下

```
    57.14%     sshd  libc-2.15.so        [.] __GI___connect_internal
               |
               --- __GI___connect_internal
                  |          
                  |--25.00%-- add_one_listen_addr.isra.0
                  |          
                  |--25.00%-- __nscd_get_mapping
                  |          __nscd_get_map_ref
                  |          
                  |--25.00%-- __nscd_open_socket
                   --25.00%-- [...]
```

如何安装符号表?

对于内核代码的符号表，在编译内核时，使用`CONFIG_KALLSYMS=y`。 检查如下

```
# cat /boot/config-`uname -r` |grep CONFIG_KALLSYMS
CONFIG_KALLSYMS=y
CONFIG_KALLSYMS_ALL=y
CONFIG_KALLSYMS_EXTRA_PASS=y
```

对于用户安装软件的符号表，如果是**yum安装**的，可以安装对应的**debuginfo**包。

如果是用户自己编译的，例如使用**GCC编译**时加上`-g`选项。

## 3.2. perf annotate

`perf annotate`能够提供源码信息, 不过需要在应用编译的时候带有`-ggdb`.

## 3.3. Stack Traces

(使用`perf record -g`收集stack traces)

要跟踪完整的stack，编译时需要注意几个东西。

1. 编译perf时候需要包含`libunwind`和`-g dwarf`

2. 有些编译优化项会忽略frame pointer，所以编译**应用软件**时必须指定 `-fno-omit-frame-pointer` ，才能跟踪完整的stack trace.

3. **编译内核**时包含 `CONFIG_FRAME_POINTER=y`

## 3.4. 小结

总结一下，要愉快的跟踪更完备的信息，就要在**编译软件**时打开符号表的支持(`gcc -g`)，开启**annotate**的支持(`gcc -ggdb`)，以及**Stack trace**的支持(`gcc -fno-omit-frame-pointer`)。

# 4. Perf 安装

centos你可以使用yum安装，也可以使用源码安装。

perf 在内核源码包中的位置 tools/perf。

## 安装依赖库

安装依赖库，有一个小窍门可以找到依赖的库

```
# cat Makefile |grep found
```

## 4.1. 测试

```
[root@centos7 linux]# make -C tools/perf -f tests/make
```

## 4.2. 编译

```
[root@centos7 linux]# make -C tools/perf
```

## 4.3. 安装

```
[root@centos7 linux]# make -C tools/perf install
```

## 4.4. 帮助文档

```
man 1 perf
man 1 perf-stat
man 1 perf-top
man 1 perf-record
man 1 perf-report
man 1 perf-list
```

# 5. Perf性能事件

![2020-07-20-09-42-57.png](./images/2020-07-20-09-42-57.png)

这张图大致列出了perf支持的跟踪事件，从kernerl到user space，支持块设备、网络、CPU、文件系统、内存等，同时还支持系统调用，用户库的事件跟踪。

我们看到perf支持这么多的事件和trace，它**依赖了很多的接口**来干这件事情。

## 5.1. 三种类型性能事件

利用perf剖析程序性能时，需要指定**当前测试**的**性能事件**。性能事件是指在**处理器**或**操作系统**中发生的，**可能影响到程序性能**的硬件事件或软件事件。比如Cache丢失，流水线停顿，页面交换等。这些事件会对程序的执行时间造成较大的负面影响。在优化代码时，应尽可能减少此类事件发生。

因此，必须先利用perf等性能剖析工具查找引发这些性能事件的热点代码以及热点指令。

perf定义的性能事件分为3类，分别是硬件性能事件、软件性能事件与Tracepoint Events。也可以以这三种事件为调优方向


使用perf，可以分析程序运行期间发生的硬件事件，比如instructions retired、processor clock cycles等；也可以分析**软件事件**，比如page fault和进程切换。


### 5.1.1. 硬件性能事件

- Hardware Event由**PMU部件产生**，在特定的条件下探测性能事件是否发生以及发生的次数。比如cache命中。

来自CPU自己或CPU的PMU（Performance Monitoring Unit，性能监控单元），包含一系列微架构事件例如时钟周期、L1缓存丢失等。具体支持的事件类型取决于CPU型号

完整的性能事件列表见Intel手册`Performance Monitoring Events`

### 5.1.2. 软件性能事件

- Software Event是**内核产生的事件/计数器**，分布在**各个功能模块**中，统计和**操作系统相关性能事件**。比如**进程切换**，等。

基于**内核计数器**的低级事件，例如CPU迁移、**tick数**、上下文切换、Minor Faults、Major Faults（页面错误）

### 5.1.3. Tracingpoint事件

- Tracepoint Event是内核中**静态tracepoint所触发的事件**，这些tracepoint用来判断程序运行期间内核的行为细节（这些tracepint的对应的sysfs节点在`/sys/kernel/debug/tracing/events`目录下）。比如slab分配器的分配次数等。

由内核中的**ftrace**实现，包括：
1. 内核**追踪点事件**，静态的、内核级的追踪点，**硬编码**到内核
2. 用户**静态定义追踪**（USDT），**用户态应用程序硬编码**的追踪点
3. **动态追踪**，软件可以被动态instrumented，在任何位置创建事件。
  - 对于**内核软件**，使用**kprobes框架**；
  - 对于**用户软件**，使用**uprobes**
4. 定时追踪，以任意频率抓取快照，主要用于CPU剖析，工作机制是定期引发中断
  - perf record -F XXXHz

### 5.1.4. 动态追踪

要启用内核动态追踪，需要使用内核编译参数`CONFIG_KPROBES=y`、`CONFIG_KPROBE_EVENTS=y`。要追踪基于帧指针的内核栈，需要内核编译参数`CONFIG_FRAME_POINTER=y`。

要启用**用户动态追踪**，需要使用内核编译参数`CONFIG_UPROBES=y`、`CONFIG_UPROBE_EVENTS=y`

### 5.1.5. 事件限定符

事件有多种表示方式，最简单的是它的字符串表示。引用事件时，可以指定限定符：

https://blog.gmem.cc/perf

## 5.2. 性能事件的属性

### 5.2.1. PMI中断和PEBS中断

perf的采样是**基于事件**进行的。**采样的周期**以**事件的数量来表示**，而**非基于时间**。当**目标事件计数溢出指定的数值！！！**，则**产生一个采样**。

样本中包含的信息取决于用户和工具指定的**度量类型**，但是最重要的信息是**指令指针**（instruction pointer），也就是程序**被中断时所处的位置**。

这种基于中断的采样，在现代处理器上存在刹车效应。也就是说，**样本中记录的指针**，和程序被中断以处理PMU事件时的指令指针，可能**相隔数十个指令**。

record子命令默认使用cycle事件，类似于定期采样。


**硬件性能事件**由处理器的PMU提供支持。

如前文所述，perf会对PMI中断发生时的PC寄存器进行采样。由于现代处理器的主频非常高，在加上深度流水线机制，从**性能事件被触发**，到处理器**响应PMI中断**，流水线上可能已处理过百条指令。那么**PMI中断**采到的**指令地址**就不再是处罚性能事件的那条指令的地址了，而可能具有**非常严重的偏差**。

为了解决这个问题，intel处理器通过**PEBS**（Precise Event Based Sampling）机制实现了**高精度事件采样**。PEBS通过硬件在**计数器溢出**时将处理器现场直接保存到内存（而**不是在相应中断时**才保存寄存器现场），从而使得perf能够真正触发性能事件的那条指令的地址，提高了采样精度。

在默认条件下，perf**不使用PEBS机制**。用户如果想要使用**高精度采样**，需要在指定性能事件时，在事件后调价后缀"`:p`"或"`:pp`"。

例如：

```
perf top -e cycles:pp
```

### 5.2.2. 性能事件的精度级别

Perf 在采样精度上定义了 4 个级别.

Level | Comment
---|---
0 | 无精度保证
1 | 采样指令与触发性能事件的指令之间的偏差为常数（:p）
2 | 需要尽量保证采样指令与触发性能事件的指令的偏差为0（:pp）
3 | 保证采样指令与触发性能事件的指令之间的偏差**必须为0**（:ppp）

目前X86处理器，包括Intel处理器与AMD处理器Jun仅能实现前3个精度级别。

### 5.2.3. 其他属性

除了精度级别以外，事件还具有其他几个属性，均可以通过"event:X"的方式予以指定。

attribute | Comment
---|---
u | 仅统计用户空间程序触发的性能事件。
k | 仅统计内核触发的性能事件。
h | 仅统计Hypervisor触发的性能事件。
G | 在KVM虚拟机中，仅攻击Guest系统触发的性能事件。
H | 仅统计Host系统触发的性能事件。
p | 精度级别。

## 5.3. 没有预定义字符描述的硬件性能事件

另外需要补充的是，perf list工具仅列出了具有字符描述的**硬件性能事件**。而那些**没有预定义字符描述的性能事件**，也可以通过特殊方式使用。

这时，就需要我们**根据CPU的手册**，通过性能事件的标号配置PMU的性能计数器。可以采用如下方式：

```
perf top -e r[UMask+EventSelect]
```

举个例子，我们现在想统计所有**从内存中读过数据的指令的个数**，perf list中并未预定义此事件的字符描述。通过查找intel的处理器手册，我们找了此事件编码：

![2020-07-20-08-47-26.png](./images/2020-07-20-08-47-26.png)

便可以通过以下方式使用此事件：

```
perf stat -e r010b ls
```

所以完整的性能事件列表见Intel手册`Performance Monitoring Events`


## 5.4. perf list查看所有性能事件

不同型号的 CPU 支持的硬件性能事件不尽相同。不同版本的内核提供的软件 性能事件与 Tracepoint events 也不尽相同。因此，perf提供了list工具以查看当前软硬件平台支持的性能事件列表。

使用方法如下：

```
# ./perf list -h

 Usage: perf list [<options>] [hw|sw|cache|tracepoint|pmu|sdt|event_glob]

    -d, --desc            Print extra event descriptions. --no-desc to not print.
    -v, --long-desc       Print longer event descriptions.
        --debug           Enable debugging output
        --deprecated      Print deprecated events.
        --details         Print information on the perf event names and expressions used internally by events.
```

执行命令后，perf将给出当前软硬件平台的所有性能事件。输出结果如下图所示。每行后面括弧里的信息表示该事件是**硬件事件**、**软件事件**还是Tracepoint events。

![2020-07-19-21-04-27.png](./images/2020-07-19-21-04-27.png)

......

![2020-07-19-21-06-38.png](./images/2020-07-19-21-06-38.png)

## 5.5. 性能事件指定错误

所以如果指定性能事件失败, 可能会有类似打印

```
./perf record -e syscalls:sys_enter ls
event syntax error: 'syscalls:sys_enter'
                     \___ unknown tracepoint

Error:	File /sys/kernel/debug/tracing/events/syscalls/sys_enter not found.
Hint:	Perhaps this kernel misses some CONFIG_ setting to enable this feature?.

Run 'perf list' for a list of valid events

 Usage: perf record [<options>] [<command>]
    or: perf record [<options>] -- <command> [<options>]

    -e, --event <event>   event selector. use 'perf list' to list available events
```

# 6. Perf 功能概述

perf利用Linux的trace特性，可以用于实时跟踪，统计event计数(perf stat)；或者使用采样(perf record)，报告(perf report|script|annotate)的使用方式进行诊断。

perf命令行接口并不能利用所有的Linux trace特性，有些trace需要通过ftrace接口得到。

参考 https://github.com/brendangregg/perf-tools

perf 命令用法还是挺简单的，根据功能区分了COMMAND，每个COMMAND有各自的用法。

![2020-07-20-08-26-42.png](./images/2020-07-20-08-26-42.png)

每种功能使用命令`./perf --help CMD`查看用法等.

Perf是一个包含27种子工具的工具集，功能很全面。

No.|sub-commands|comment
:------:|------:|:------
01 | annotate      |根据数据文件（perf.data），注解被采样到的函数，显示指令级别的热点。
02 | archive       |根据数据文件中记录的build-id，将所有被采样到的ELF文件打成压缩包。利用此压缩包，可以在任何机器上分析数据文件中的采样数据。
03 | bench         |Perf中内置的benchmark，目前包括两套针对调度器和内存管理子系统的benchmark。
04 | buildid-cache |管理perf的buildid缓存。每个ELF文件都有一个独一无二的buildid。Buildid被perf用来关联性能数据与ELF文件。
05 | buildid-list  |列出数据文件中记录的所有buildid。
06 | config        |从配置文件中设置读取变量。
07 | data          |数据文件的相关处理。
08 | diff          |对比两个数据文件的差异。能够给出每个符号（函数）在热点分析上的具体差异。
09 | evlist        |列出数据文件中的所有性能事件。
10 | ftrace        |调用ftrace功能。
11 | inject        |该工具读取perf record工具记录的事件流，并将其定向到标准输出。在被分析代码中的任何一点，都可以向事件流中注入其他事件。
12 | kallsyms      |查询运行内核的符号信息。
13 | kmem          |针对内存子系统的分析工具。
14 | kvm           |此工具可以用来追踪、测试运行与KVM虚拟机上的Guest OS。
15 | list          |列出当前系统支持的所有性能事件。包括硬件性能事件、软件性能事件以及检查点。
16 | lock          |分析内核中的加锁信息。包括锁的争用情况，等待延迟等。
17 | mem           |剖析内存访问信息。
18 | record        |收集采样信息，并将其记录在数据文件中。随后可通过其他工具对数据文件进行分析。
19 | report        |读取perf record创建的数据文件，并给出热点分析结果。
20 | sched         |针对调度器子系统的分析工具。
21 | script        |执行perl或python写的功能扩展脚本、生成脚本框架、读取数据文件中的数据信息等。
22 | stat          |剖析某个特定进程的性能概况，包括CPU、Cache Miss率等。
23 | test          |Perf针对当前软硬平台的测试工具。可以用此工具测试当前软硬件平台是否能够支持perf的所有功能。
24 | timechart     |生成一幅描述处理器与各进程状态变化的矢量图。
25 | top           |类似于Linux的top命令，对系统性能进行实时分析。
26 | probe         |用于定义动态检查点。
27 | trace         |类似strace功能。

## 6.1. 全局性概况

* perf list查看当前系统支持的性能事件；
* perf bench对系统性能进行摸底；
* perf test对系统进行健全性测试；
* perf stat对全局性能进行统计；

## 6.2. 全局细节

* perf top可以实时查看当前系统进程函数占用率情况；
* perf probe可以自定义动态事件；

## 6.3. 特定功能分析

perf kmem针对slab子系统性能分析；
perf kvm针对kvm虚拟化分析；
perf lock分析锁性能；
perf mem分析内存slab性能；
perf sched分析内核调度器性能；
perf trace记录系统调用轨迹；

## 6.4. perf record

最常用功能perf record，可以系统全局，也可以具体到**某个进程**，更甚具体到**某一进程某一事件**；可宏观，也可以很微观。

* pref record记录信息到perf.data；
* perf report生成报告；
* perf diff对两个记录进行diff；
* perf evlist列出记录的性能事件；
* perf annotate显示perf.data函数代码；
* perf archive将相关符号打包，方便在其它机器进行分析；
* perf script将perf.data输出可读性文本；

## 6.5. 可视化工具perf timechart

perf timechart record记录事件；
perf timechart生成output.svg文档；

# 7. 常用命令

## 7.1. 三种命令划分

Brendan D. Gregg 收集和写了很多命令, 按从小到大开销进行划分, 分为三种:

* statistics/count: 统计/计数, 事件计数的增加
* sample: 采样. 对某几个事件进行采样, 收集性能数据(比如IP和堆栈), 这就意味着每隔一段时间就会收集一次数据, 所以开销变大
* trace: 追踪. 收集所有事件的性能数据

见 http://www.brendangregg.com/perf.html 的`2. One-Liners`

# 8. 简单示例

程序`[pi.c]`是一个简单的计算Pi的CPU密集型程序。很显然，`[pi.c]`的热点在函数`do_pi()`中。

```cpp
#include <stdio.h>
#include <math.h>
#include <sys/types.h>
#include <linux/unistd.h>

int do_pi(double *pi)
{
    double h, sum, x;
    long long n, i;

    n = 5000000;
    h = 1.0/n;
    sum = 0.0;

    for (i = 1; i <= n; i++) {
        x = h * (i - 0.5);
        sum += 4.0 / (1.0 + pow(x,2));
    }

    *pi = h *sum;
    return 0;
}

int main(void)
{
    double pi;

    printf("pid: %d\n", getpid());
    sleep(5);

    if (!do_pi(&pi)) {
        printf("PI is %f\n", pi);
    }
    return 0;
}
```
编译pi程序

```
gcc pi.c -lm -o pi
```

运行pi程序

```
./pi
```

根据程序显示的pid在命令行中执行

```
perf top -p $pid
```

该命令利用**默认的性能事件**"cycles"对`[pi]`进行热点分析。"cycles"是**处理器周期事件**。这条命令能够分析出**消耗处理器周期最多的代码**，在处理器频率稳定的前提下，我们可以认为perf给出的热点代码就是消耗时间最多的代码。

CPU周期(cpu-cycles)是默认的性能事件，所谓的CPU周期是指CPU所能识别的最小时间单元，通常为亿分之几秒，是CPU执行最简单的指令时所需要的时间，例如读取寄存器中的内容，也叫做clock tick。

执行上述命令后，Perf会给出如下结果：

![image](./images/0x01.png)

从上图可以看到，在`[pi]`程序执行期间，函数`do_pi()`消耗了62.57%的CPU周期，是消耗处理器周期最多的热点代码。这跟我们预想的一样。

## 8.1. cycles原理

那么Perf是怎么做到的呢？以`cycles`性能事件为例

首先，perf会通过系统调用`sys_perf_event_open`在内核中注册一个检测"**cycles**"**事件**的性能计数器。内核根据perf提供的信息在**PMU**上初始化一个**硬件性能计数器**（PMC：Performance Monitoring Counter）。PMC随着CPU周期的增加而自动累加。

在**PMU溢出**时，PMU触发一个PMI（Performance Monitoring Interrupt）中断。内核在PMI中断处理函数中保存**PMC的计数值**，触发中断时的**指令地址**（Register IP：Instruction Pointer），**当前时间戳**以及**当前进程**的**PID**，**TID**，**comm**等信息。我们把这些信息统称为一个**采样**（sample）。

内核会将收集到的sample放入用于跟**用户空间**通信的Ring Buffer。**用于空间**的perf分析程序采用**mmap机制**从ring buffer中读入采样，并对其解析。perf根据**pid**, comm等信息可以找到对应的进程。根据**IP**与**ELF文件**中的**符号表**可以查找到触发PMI中断的指令所在的函数。为了能够使perf读到函数名，我们的目标程序必须具备符号表。

如果perf在分析结果中**只看到一串地址**，而**没有对应的函数名**时，通常是由于在**编译时**利用**strip**删除了ELF文件中的符号信息。建议在性能剖析阶段，保留程序中的**sysbol table**与**debug info**等信息。

根据上述的perf采样原理可以得知，perf假设两次采样之间，即两次相邻的PMI中断之间系统执行的是同一个进程的同一个函数。这种假设会带来**一定的误差**，当感觉perf给出的**结果不准**时，不妨提高**采样频率**，perf会给出更加精确的结果。

# 9. 参考

http://www.brendangregg.com/perf.html
