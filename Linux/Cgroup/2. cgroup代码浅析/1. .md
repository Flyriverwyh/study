
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [cgroup概念](#cgroup概念)
  - [目的](#目的)
  - [资源划分: 子系统和cgroup](#资源划分-子系统和cgroup)
  - [进程分组: 通过css_set](#进程分组-通过css_set)
  - [进程分组css_set和节点cgroup的关系: 多对多](#进程分组css_set和节点cgroup的关系-多对多)
- [架构](#架构)
- [相关数据结构](#相关数据结构)
  - [task_struct](#task_struct)
  - [css_set](#css_set)
    - [小结](#小结)
  - [cgroup_subsys_state](#cgroup_subsys_state)
  - [cgroup_subsys](#cgroup_subsys)
  - [cgroup](#cgroup)
  - [cgrp_cset_link](#cgrp_cset_link)
  - [cgroup_root](#cgroup_root)
  - [全局变量](#全局变量)
  - [小结](#小结-1)
    - [示例](#示例)
- [参考](#参考)
  - [v1 和 v2](#v1-和-v2)

<!-- /code_chunk_output -->

# cgroup概念

## 目的

这个函数就是初始化cgroup所需要的参数的。cgroup最初是在2006年由google的一名工程师提出的，目的是把一些**共同目标的进程**放在**一个组**里面，而这个组里面的进程能**共享指定数额的资源**。而后就有了cgroup这个概念了。

这里就涉及了两个东西
* **资源划分**
* **进程分组**

## 资源划分: 子系统和cgroup

我们把**每种类型资源**叫做**子系统**，比如**CPU子系统**，**内存子系统**。为什么叫做子系统呢，因为它是从**整个操作系统的资源衍生出来**的。

然后我们创建一种**虚拟的节点**，叫做**cgroup**，然后这个虚拟节点可以扩展，以树形的结构，有**root节点**和**子节点**。这个**父节点**和**各个子节点**就形成了**层级**（`hierarchy`）。

**每个层级**都可以附带继承**一个或者多个子系统**，就意味着，我们把**资源**按照**分割**到**多个hierarchy层级系统**中，**层级系统**中的**每个节点**对**这个资源**的**占比各有不同**。

* 子系统: **每个代表了系统中可以隔离的资源类型**
* cgroup: **某个节点**, 有相应的资源占比

## 进程分组: 通过css_set

下面我们想办法把进程分组，**进程分组**的逻辑叫做`css_set`。这里的css是**cgroup_subsys_state(！！！**)的缩写。所以 **css_set** 和**进程**的关系是**一对多**的关系。

* **一个 css_set** 中有**多个 task**
* **一个 task** 只属于**某一个 css_set**

另外，在cgroup眼中，进程请不要叫做进程，叫做**task**。这个可能是为了和内核中进程的名词区分开吧。

## 进程分组css_set和节点cgroup的关系: 多对多

**进程分组css_set**、**不同层级hierarchy**中的**节点cgroup**也都有了。那么，就要把**节点cgroup**和**进程分组css_set**进行关联，和数据库中关系表一样。这个是一个**多对多的关系**。为什么呢？

* 首先，**一个节点cgroup**可以隶属于**多个css_set**，这就代表着**这批css_set**中的**进程**都拥有**这个cgroup**所代表的**资源**。
* 其次，**一个css_set**需要**多个cgroup**。因为**一个层级的cgroup**只代表**一种**或者**几种资源**，而一般**进程**是需要**多种资源的集合体**。

# 架构

![2021-02-28-16-05-53.png](./images/2021-02-28-16-05-53.png)

![2021-02-28-16-22-47.png](./images/2021-02-28-16-22-47.png)

按照资源的划分，系统被划分成了**不同的子系统**(subsystem)，正如我们上面列出的cpu, cpuset, blkio...每种资源独立构成一个subsystem.

可以将cgroup的架构抽象的理解为多根的树结构，一个hierarchy代表一棵树，树上绑定一个或多个subsystem. 而**树的叶子**则是**cgroup**, **一个cgroup**具体的限制了**某种资源**。一个或多个cgroup组成一个css_set.

简单来讲，就是一个**资源限制集合**(`css_set`)在**一种subsystem**(cpu，devices)的**限制条件只能有一个**，最终的task(进程)同`css_set`关联，从而达到限制资源的目的。

# 相关数据结构

## task_struct

首先先看进程的结构

```cpp
#ifdef CONFIG_CGROUPS
    /* Control Group info protected by css_set_lock: */
     // 设置这个进程属于哪个css_set
    struct css_set __rcu *cgroups;
    /* cg_list protected by css_set_lock and tsk->alloc_lock: */
     //用于将所有同属于一个css_set的task连成一起
    struct list_head cg_list;
#endif
```

我们会在代码中经常见到list_head。它其实就是表示，这个在链表中存在。

```cpp
struct list_head {
    struct list_head *next, *prev;
};
```

它的结构很简单，就能把某种相同性质的结构连成一个链表，根据这个链表我能前后找全整个链表或者头部节点等。

## css_set

```cpp
struct css_set {
    // 包含一系列的css, 这个就代表了css_set和子系统的多对多的其中一面
    // css_set关联的所有css(cgroup_subsys_state). css就是子系统状态 
    // 每一个subsystem对应数组中相应id的项, 每一项就表示了这个 css_set 对应的某类子系统的状态
    struct cgroup_subsys_state *subsys[CGROUP_SUBSYS_COUNT];

    // 引用计数，gc使用，如果子系统有引用到这个css_set, 则计数＋1
    refcount_t refcount;
    struct css_set *dom_cset;
    // 默认连接的cgroup
    struct cgroup *dfl_cgrp;
    
    int nr_tasks;
    // 将所有的task连起来; mg_tasks 代表迁移的任务
    struct list_head tasks;
    struct list_head mg_tasks;
    struct list_head dying_tasks;
    // 所有迭代任务的列表，这个补丁参考: https://patchwork.kernel.org/patch/7368941/
    struct list_head task_iters;

    // 把->subsys[ssid]->cgroup->e_csets[ssid]结构展平放在这里，提高迭代效率
    struct list_head e_cset_node[CGROUP_SUBSYS_COUNT];

    struct list_head threaded_csets;
    struct list_head threaded_csets_node;

    //列出有相同hash值的cgroup
    struct hlist_node hlist;
    // 将这个css_set对应的cgroup链接起来
    // 由 cgrp_cset_links 组成的链表，链表上每一项 cgrp_cset_link 都指向和css_set关联的cgroup
    struct list_head cgrp_links;

    // 内存迁移的时候产生的系列数据
    struct list_head mg_preload_node;
    struct list_head mg_node;
    struct cgroup *mg_src_cgrp;
    struct cgroup *mg_dst_cgrp;
    struct css_set *mg_dst_cset;

    // 这个css_set是否已经无效了
    bool dead;

        // rcu锁所需要的callback等信息
    /* For RCU-protected deletion */
    struct rcu_head rcu_head;
```

这里说一下rcu锁，这个锁是linux2.6引入的。它是非常高效的，适合读多写少的情况。全称是(Read-Copy Update, 读－拷贝修改)。原理就是读操作的时候，不需要任何锁，直接进行读取，写操作的时候，先拷贝一个副本，然后对副本进行修改，最后使用回调（callback）在适当的时候将**指向原来数据的指针**指向**新的被修改的数据**。https://www.ibm.com/developerworks/cn/linux/l-rcu/

这里的`rcu_head`就存储了对这个结构上rcu锁所需要的回调信息。

```cpp
struct callback_head {
    struct callback_head *next;
    void (*func)(struct callback_head *head);
} __attribute__((aligned(sizeof(void *))));

#define rcu_head callback_head
```

回到css_set，其实最重要的就是`cgroup_subsys_state subsys[]`数组这个结构, 每个 css_set 对应这个一个的数组, 代表**这个 css_set 进程组**对应的**每种资源的状态**(即子系统), 一般不同 css_set 是不同的.

`cgroup_subsys_state subsys[]` 应当包括**所有子系统的css**. 也就是说, **一类可隔离的资源算一个**, 应该包含**系统中所有可隔离的资源类型**个数目. 如果此`css_set`**没有指定某个subsystem的css**或者**subsystem没有mount**，则默认初始化为根css.

### 小结

`css_set`是直接和task关联的结构，`css_set`用来将**进程**关联到一组`cgroup_subsys_state`对象，同时通过`cgrp_cset_links`和**所有相关的cgroup**建立关联。

## cgroup_subsys_state

这个结构最重要的就是保存的**进程**与**特定子系统**相关的信息。通过它，可以将 **task_struct** 和 **cgroup** 连接起来了：

`task_struct->css_set->cgroup_subsys_state[]->cgroup`

```cpp
// 子系统状态
struct cgroup_subsys_state {
        // 这个 css 对应的cgroup
        // 一个 cgroup 可以对应多个 css
        struct cgroup *cgroup;

        // 这个 css 对应的子系统
        struct cgroup_subsys *ss;

        // per-cpu信息的引用计数
        struct percpu_ref refcnt;

        // 兄弟和孩子链表串
        struct list_head sibling;
        struct list_head children;

        struct list_head rstat_css_node;

        // css的唯一id
        int id;

        // 可设置的flag有：CSS_NO_REF/CSS_ONLINE/CSS_RELEASED/CSS_VISIBLE
        unsigned int flags;

        // 为了保证遍历的顺序性，设置遍历按照这个字段的升序走
        u64 serial_nr;

        // 计数，计算本身css和子css的活跃数，当这个数大于1，说明还有有效子css
        atomic_t online_cnt;

        // 带cpu信息的引用计数使用的rcu锁
        struct work_struct destroy_work;
        struct rcu_work destroy_rwork;

        // 父css
        struct cgroup_subsys_state *parent;
}
```

`cgroup_subsys_state` 代表了**某一类可隔离的资源(子系统)的一个状态**(每一类子系统会有很多个css状态), 而不是整体资源. 比如, 代表了 `struct cgroup_subsys pids_cgrp_subsys` 子系统的一个状态, 而这个状态仅仅是一组task(`css_set`)

##  cgroup_subsys

```cpp
// 对应特定的子系统
struct cgroup_subsys {
    // 下面的是函数指针，定义了该子系统对css_set结构的系列操作
    struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state *parent_css);
    int (*css_online)(struct cgroup_subsys_state *css);
    void (*css_offline)(struct cgroup_subsys_state *css);
    void (*css_released)(struct cgroup_subsys_state *css);
    void (*css_free)(struct cgroup_subsys_state *css);
    void (*css_reset)(struct cgroup_subsys_state *css);
    void (*css_rstat_flush)(struct cgroup_subsys_state *css, int cpu);
    int (*css_extra_stat_show)(struct seq_file *seq,
                struct cgroup_subsys_state *css);

    // 这些函数指针表示了该子系统对进程task的一系列操作
    int (*can_attach)(struct cgroup_taskset *tset);
    void (*cancel_attach)(struct cgroup_taskset *tset);
    void (*attach)(struct cgroup_taskset *tset);
    void (*post_attach)(void);
    int (*can_fork)(struct task_struct *task,
            struct css_set *cset);
    void (*cancel_fork)(struct task_struct *task, struct css_set *cset);
    void (*fork)(struct task_struct *task);
    void (*exit)(struct task_struct *task);
    void (*release)(struct task_struct *task);
    void (*bind)(struct cgroup_subsys_state *root_css);

    // 是否在前期初始化了
    bool early_init:1;

    // 如果设置了true，那么在cgroup.controllers和cgroup.subtree_control就不会显示
    bool implicit_on_dfl:1;

    bool threaded:1;

    // 启动阶段自动初始化
    int id;
    const char *name;

    // 如果子cgroup的结构继承子系统的时候没有设置name，就会沿用父系统的子系统名字，所以这里存的就是父cgroup的子系统名字
    const char *legacy_name;

    // 这个就是子系统指向的层级中的root的cgroup, 即 hierarchy
    struct cgroup_root *root;

    // 对应的css的idr
    struct idr css_idr;

    // 对应的文件系统相关信息
    struct list_head cfts;
    /* 默认的文件系统 */
    struct cftype *dfl_cftypes; /* for the default hierarchy */
    /* 继承的文件系统 */
    struct cftype *legacy_cftypes;  /* for the legacy hierarchies */

    // 有的子系统是依赖其他子系统的，这里是一个掩码来表示这个子系统依赖哪些子系统
    unsigned int depends_on;
}
```

这里特别说一下**cftype**。它是`cgroup_filesystem_type`的缩写。这个要从我们的**linux虚拟文件系统**说起（`VFS`）。VFS封装了**标准文件**的**所有系统调用**。那么我们使用cgroup，也抽象出了一个**文件系统**，自然也需要实现这个VFS。实现这个VFS就是使用这个cftype结构。

这里说一下 idr. 这个是linux的**整数id管理机制**。你可以把它看成**一个map**，这个map是把**id**和**指定指针**关联在一起的机制。它的原理是使用**基数树**。**一个结构**存储了一个**idr**，就能很方便**根据id找出这个id对应的结构的地址**了。http://blog.csdn.net/dlutbrucezhang/article/details/10103371

## cgroup

`cgroup_root`和**子节点cgroup**是使用两个不同结构表示的.

cgroup 代表了**某一个子节点**, 有着**相应的资源占比**

```cpp
struct cgroup {
    // cgroup 所在的 css
    struct cgroup_subsys_state self;

    unsigned long flags;

    // 这个cgroup所在层级中，当前cgroup的深度
    int level;

    int max_depth;

    int nr_descendants;
    int nr_dying_descendants;
    int max_descendants;

    // 每当有个非空的css_set和这个cgroup关联的时候，就增加计数1
    int nr_populated_csets;
    int nr_populated_domain_children;
    int nr_populated_threaded_children;

    int nr_threaded_children;

    struct kernfs_node *kn;     /* cgroup kernfs entry */
    struct cgroup_file procs_file;  /* handle for "cgroup.procs" */
    struct cgroup_file events_file; /* handle for "cgroup.events" */

    u16 subtree_control;
    u16 subtree_ss_mask;
    u16 old_subtree_control;
    u16 old_subtree_ss_mask;

    // 一个cgroup属于多个css，这里就是保存了cgroup和css直接多对多关系的另一半
    // 此cgroup关联subsystem的css结构，每个subsystem的css在数组中对应subsys[subsystem->subsys_id]
    struct cgroup_subsys_state __rcu *subsys[CGROUP_SUBSYS_COUNT];
    // cgroup所处的cgroupfs_root,对应hirerarchy
    struct cgroup_root *root;
    // 这个cgroup关联的所有css_set链表
    // 由 cgrp_cset_links 组成的链表，链表上每一项 cgrp_cset_link 都指向这个cgroup中task关联的css_set
    struct list_head cset_links;
    // 这个cgroup使用的所有子系统的每个链表
    struct list_head e_csets[CGROUP_SUBSYS_COUNT];

    struct cgroup *dom_cgrp;
    struct cgroup *old_dom_cgrp;

    struct cgroup_rstat_cpu __percpu *rstat_cpu;
    struct list_head rstat_css_list;

    struct cgroup_base_stat last_bstat;
    struct cgroup_base_stat bstat;
    struct prev_cputime prev_cputime;

    struct list_head pidlists;
    struct mutex pidlist_mutex;

    /* used to wait for offlining of csses */
    // 用来保存下线task
    wait_queue_head_t offline_waitq;

    /* used to schedule release agent */
    // 用来保存释放任务
    struct work_struct release_agent_work;

    /* used to track pressure stalls */
    struct psi_group psi;

    /* used to store eBPF programs */
    struct cgroup_bpf bpf;

    /* If there is block congestion on this cgroup. */
    atomic_t congestion_count;

    /* Used to store internal freezer state */
    struct cgroup_freezer_state freezer;

    /* ids of the ancestors at each level including self */
    // 保存每个level的祖先
    u64 ancestor_ids[];
};
```

这里看到一个新的结构，`wait_queue_head_t`，这个结构是用来将一个资源挂在等待队列中，具体参考：http://www.cnblogs.com/lubiao/p/4858086.html

cgroup对应一个**controll实例**，需要和`css_set`关联起来. 这样**每个 task_struct** 就可以通过 `task_struct->cgroups`(是`css_set`)再继而和cgroup关联，达到**控制和隔离资源**的目的，那么`css_set`和`cgroup`具体是怎么关联的呢？

> 一个cgoup对应一个controller实例, 是v1吧

首先需要明确的是`cgroup`和`css_set`是**多对多**的关系，既：
* 一个`css_set`可以对应**多个cgroup**;
* 同时**一个cgroup**也可以被**多个css_set**所包含。

这种多对多的映射关系，是通过`cgrp_cset_link`这个中间结构来关联的。

## cgrp_cset_link

```cpp
struct cgrp_cset_link {
    /* the cgroup and css_set this link associates */
    struct cgroup       *cgrp;
    struct css_set      *cset;

    /* list of cgrp_cset_links anchored at cgrp->cset_links */
    struct list_head    cset_link;

    /* list of cgrp_cset_links anchored at css_set->cgrp_links */
    struct list_head    cgrp_link;
};
```

**一个 cgrp_cset_link** 需要包含**两类信息**，即**关联的cgroup**和**关联的css_set**信息，一个 `cgrp_cset_link` 可以让**一个cgroup**和**一个css_set**相**关联**。

但是正如我们前面所说，`css_set`和`cgroup`是**多对多**的对应关系，所以，
* **一个css_set**需要保存**多个 cgrp_cset_link 信息**, 
* **一个cgroup**也需要保存**多个 cgrp_cset_link 信息**。

具体来说，
* **css_set** 结构体中的 `cgrp_links` 维护了一个**链表**，链表中的**元素**为 `cgrp_cset_link` 中的 `cgrp_link`. 
* **cgroup** 结构体中的 `cset_links` 也维护了一个**链表**，链表中**元素**为 `cgrp_cset_links` 中的 `cset_link`. 

结构如下图所示：

![2021-05-27-20-44-12.png](./images/2021-05-27-20-44-12.png)

## cgroup_root

还有一个结构是cgroup_root

```cpp
struct cgroup_root {
    struct kernfs_root *kf_root;

    /* The bitmask of subsystems attached to this hierarchy */
    // 挂载到这个 hierarchy 的子系统掩码
    unsigned int subsys_mask;

    /* Unique id for this hierarchy. */
    // 层级的id
    int hierarchy_id;

    /* The root cgroup.  Root is destroyed on its release. */
    // // 根部的cgroup，这里面就有下级cgroup
    struct cgroup cgrp;

    /* for cgrp->ancestor_ids[0] */
    // 相等于cgrp->ancestor_ids[0]
    u64 cgrp_ancestor_id_storage;

    /* Number of cgroups in the hierarchy, used only for /proc/cgroups */
    // 这个root层级下的cgroup数，初始化的时候为1
    atomic_t nr_cgrps;

    /* A list running through the active hierarchies */
    // 串起所有的cgroup_root
    struct list_head root_list;

    /* Hierarchy-specific flags */
    unsigned int flags;

    /* The path to use for release notifications. */
    char release_agent_path[PATH_MAX];

    /* The name for this hierarchy - may be empty */
    // 这个层级的名称，有可能为空
    char name[MAX_CGROUP_ROOT_NAMELEN];
};
```

## 全局变量

此外，还有几个cgroup相关的全局变量

```cpp

// 默认 hierarchy
struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };
EXPORT_SYMBOL_GPL(cgrp_dfl_root);

/* The default css_set - used by init and its children prior to any
 * hierarchies being mounted. It contains a pointer to the root state
 * for each subsystem. Also used to anchor the list of css_sets. Not
 * reference-counted, to improve performance when child cgroups
 * haven't been created.
 * 
 * 初始化默认的css_set. 在没有hierarchy被mount之前，系统初始化时init及其子进程关联此css_set。
 * init_css_set->subsys 指向每个subsys的root css.
 */
struct css_set init_css_set = {
        .refcount               = REFCOUNT_INIT(1),
        .dom_cset               = &init_css_set,
        .tasks                  = LIST_HEAD_INIT(init_css_set.tasks),
        .mg_tasks               = LIST_HEAD_INIT(init_css_set.mg_tasks),
        .dying_tasks            = LIST_HEAD_INIT(init_css_set.dying_tasks),
        .task_iters             = LIST_HEAD_INIT(init_css_set.task_iters),
        .threaded_csets         = LIST_HEAD_INIT(init_css_set.threaded_csets),
        .cgrp_links             = LIST_HEAD_INIT(init_css_set.cgrp_links),
        .mg_preload_node        = LIST_HEAD_INIT(init_css_set.mg_preload_node),
        .mg_node                = LIST_HEAD_INIT(init_css_set.mg_node),

        /*
         * The following field is re-initialized when this cset gets linked
         * in cgroup_init().  However, let's initialize the field
         * statically too so that the default cgroup can be accessed safely
         * early during boot.
         */
        .dfl_cgrp               = &cgrp_dfl_root.cgrp,
};

/*
 * hash table for cgroup groups. This improves the performance to find
 * an existing css_set. This hash doesn't (currently) take into
 * account cgroups in empty hierarchies.
 * 
 * css_set的hash table.将task关联到指定css，就是将task->cgroup指针指向一个
 * css_set. css_set_table 以css[]为key, 相同的css集合，即为同一个css_set.
 * 当有task需要关联到到一组css时，以css[]为key在hash table中查找是否存在,
 * 存在直接引用此key的css_set，否则创建 css_set 并添加到hash table.
 * 
#define CSS_SET_HASH_BITS    7
static DEFINE_HASHTABLE(css_set_table, CSS_SET_HASH_BITS);
```

## 小结

核心架构:

![2021-02-28-16-22-47.png](./images/2021-02-28-16-22-47.png)

关键链路:

`task_struct->css_set->cgroup_subsys_state[CGROUP_SUBSYS_COUNT]->cgroup`

目的: **一组进程**使用**一组资源**, **进程**和**资源**是多对多

**很多** `task_struct` 指向一个 `css_set`, 表示**这些 task 都属于一个组**, 即**属于这一个 css_set**;

一个 `css_set` 中有 `CGROUP_SUBSYS_COUNT`(即**子系统的数目**) 个 `cgroup_subsys_state`(**子系统状态**), **每个**都代表了**这个进程组 css_set** 在**相应子系统的状态**.

>`css_set` 关联了**一组进程**和**一组系统中所有可隔离的资源状态**

`cgroup_subsys_state` 是特定于**某个子系统**的**状态**, `struct cgroup_subsys *ss`就是对应的子系统; 它同时要和某个节点cgroup对应起来, 

### 示例

> 可能理解不对



# 参考

https://www.cnblogs.com/muahao/p/10280998.html (ing)

https://tech.meituan.com/2015/03/31/cgroups.html (none)

http://files.cnblogs.com/files/lisperl/cgroups介绍.pdf

http://tech.meituan.com/cgroups.html

http://coolshell.cn/articles/17049.html











在挂载的目录下，mkdir可创建新的cgroup, rmdir可删除cgroup(不能直接rm).


## v1 和 v2

> 自我理解, 可能不对

在 v1 中, 一个cgroup对应的就是某一个controller的实例, 而 v2 下就不是了.

> 感觉 css 是某一类controller的实例.

* v1 cgroup: `/sys/fs/cgroup/${controller}/${cgroup}`, 比如`/sys/fs/cgroup/pids/${cgroup}`, `/sys/fs/cgroup/memory/${cgroup}`
* v2 cgroup: `根/${cgroup}/${cgroup}`, 而 `cgroup.controllers` 表明可用的 controller, 也就是说一个目录下面的cgroup节点会对应多个 controller 实例的.

可以看到, 

* v1 中, 一个 cgroup **只会**对应一个 controller 实例(css), 而一个 controller 实例(css)会对应多个 cgroup(一层目录对应一个 controller 实例, 在这个目录下创建的节点都是这个 css 对应的 cgroup); 

* v2 中, 一个 cgroup 可以对应多个 controller 实例(css), 而一个 controller(css)实例也会对应多个 cgroup
