参考：  
https://www.ibm.com/developerworks/cn/linux/kernel/l-chain/index.html

http://blog.chinaunix.net/uid-23069658-id-4576255.html

https://www.linuxidc.com/Linux/2016-12/137929.htm

## 一、链表数据结构简介

链表具有更好的动态性，建立链表时无需预先知道数据总量，可以随机分配空间，可以高效地在链表中的任意位置实时插入或删除数据。链表的开销主要是访问的顺序性和组织链的空间损失。

链表分单向链表、双向链表，根据是否循环分为单向链表和循环链表。

链表中包含数据域和指针域。链表通常包含一个头结点，不存放数据，方便链表操作。

### 1. 单链表

![config](images/1.gif)

```
typedef struct node
{
     ElemType data;      //数据域
     struct node *next;  //指针域
}node, *list;
```

单链表是最简单的一类链表，它的特点是仅有一个指针域指向后继节点（next），因此，对单链表的遍历只能从头至尾（通常是NULL空指针）顺序进行。

### 2. 双链表

![config](images/2.gif)

通过设计前驱和后继两个指针域，双链表可以从两个方向遍历，这是它区别于单链表的地方。如果打乱前驱、后继的依赖关系，就可以构成"二叉树"；如果再让首节点的前驱指向链表尾节点、尾节点的后继指向首节点（如图2中虚线部分），就构成了循环链表；如果设计更多的指针域，就可以构成各种复杂的树状数据结构。

### 3. 循环链表

循环链表的特点是尾节点的后继指向首节点。前面已经给出了双循环链表的示意图，它的特点是从任意一个节点出发，沿两个方向的任何一个，都能找到链表中的任意一个数据。如果去掉前驱指针，就是单循环链表。

单向循环链表：

![config](images/1.png)

双向循环链表：

![config](images/2.png)

## 二、Linux内核链表数据结构的实现

Linux采用了一种更通用的设计，将链表以及其相关操作函数从数据本身进行剥离，这样使用链表的时候就不用自己去实现诸如节点的插入、删除、遍历等操作了。本文主要介绍基本链表结构，然后再简要介绍一下rcu和hlist。


### 1. 链表结构定义

链表结构定义如下所示：

```
struct list_head {
    struct list_head *next, *prev;
};
```

结构如下：

![config](images/3.png)

在2.6.21里这个数据结构定义在include/linux/list.h头文件里，但是后面内核里，以及后面要介绍的哈希链表的定义都放在include/linux/types.h头文件里。对链表来说内核的版本号几乎没什么影响。

list\_head结构包含两个指向list\_head结构的指针prev和next，由此可见，**内核的链表具备双向循环链表功能**，实际上，通常它都组织成双向循环链表。

和第一节介绍的双链表结构模型不同，这里的list\_head没有数据域。在Linux内核链表中，不是在链表结构中包含数据，而是在数据结构中包含链表节点。

在数据结构课本中，链表的经典定义方式通常是这样的（以单链表为例）：

```
struct list_node {
    struct list_node *next;
    ElemType    data;
};
```
需要用链表结构时，只需要在结构体中定义一个链表类型的数据即可。例如定义一个student链表，

```
#define NAME_MAX_SIZE 32

typedef struct student{
    char name[NAME_MAX_SIZE];    /*姓名*/
    unsigned char sex;              /*性别：m-男生；f-女生*/
    unsigned char age;              /*年龄*/
    struct list_head stu_list;  /*所有的学生最终通过这个结构串成链表*/
}Student;
```

定义一个app\_info链表，app
\_info app\_info\_list;通过app\_info\_head进行链表操作。根据C语言指针操作，通过container\_of和offsetof，可以根据app\_info\_head的地址找出app\_info的起始地址，即一个完整ap\_info结构的起始地址。可以参考该目录相关文章。

### 2. 初始化链表

```
#define LIST_HEAD_INIT(name) { &(name), &(name) }

#define LIST_HEAD(name) \
    struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
    list->next = list;
    list->prev = list;
}
```

static 加在函数前，表示这个函数是静态函数，其实际上是对作用域的限制，指该函数作用域仅局限于本文件。所以说，static 具有信息隐蔽的作用。而函数前加inline关键字的函数，叫内联函数，表示编译程序在调用这个函数时，立即将该函数展开。

LIST\_HEAD宏创建一个链表头结点，并用LIST\_HEAD\_INIT宏对头结点进行赋值，使得头结点的前驱和后继指向自己。这样，我们就有了一个空链表，因为Linux用头指针的next是否指向自己来判断链表是否为空(下面代码)。

INIT\_LIST\_HEAD函数对链表进行初始化，使得前驱和后继指针指针指向头结点。

如果我们要**定义一个名为student\_list的链表**，直接LIST\_HEAD(student\_list)就可以了，展开后等价于下面的代码：

```
struct list_head student_list= { &(student_list), &(student_list) };
```

跟内核通知链类似，如果我们已经有了一个链表对象student\_list，INIT\_LIST\_HEAD()接口可以对它初始化。

所以，LIST\_HEAD(student\_list)代码和下面的代码是等价的：

```
struct list_head student_list；
INIT_LIST_HEAD (&student_list);
```

那么在写代码时，如果是通过kmalloc之类的函数动态创建节点，我们就可以用下面代码对链表节点进行初始化：

```
Student *stu1;
stu1 = kmalloc(sizeof(*stu1), GFP_KERNEL);
strcpy(stu1->name,”xiaoming”);
stu1->sex = ‘m’;
stu1->age = 18;
INIT_LIST_HEAD(&stu1-> stu_list); /*和下面的用法注意区别*/
```

如果是静态定义结构体变量的话就更简单了：

```
Student stu2={
    .name={“xiaohong”},
    .sex=’f’,
    .age=18,
    .stu_list = LIST_HEAD_INIT(stu2.stu_list); /*和上面的用法注意区别*/
};
```

有了数据节点，接下来就要对其进行操作了，内核提供了一组常用接口用于对双向链表操作，如下。

![config](images/4.png)

![config](images/5.png)

需要注意的是，上述所有链表操作函数的入参都是struct list\_head{}的指针类型，这一点需要时刻牢记在心。

还有关于链表的分割list\_cut\_position(\*list,\*head,\*entry)以及合并list\_splice(\*list,\*head)、list\_splice\_init (\*list,\*head)、list\_splice\_tail (\*list,\*head)、list\_splice\_tail\_init (\*list,\*head)这几个API。

通过上面的图我们可以看出来，在内核中当我们提及链表头的时候其实并没有牵扯到我们自己的结构体数据本身，**链表头的next所指向的节点才是真正意义上的“链表头节点”，prev所指向的节点叫做“链表尾节点”**。注意，不要把链表头和链表的头节点混为一谈。有了这个认识之后，我们就知道如果链表头的next和prev都指向链表头本身的话，那么这个链表其实就是空的，例如list\_empty()或者list\_empty\_careful()所做的事情就是给定一个链表头，判断其是否为空，即是否包含任何有效的数据节点。同样地，如何判断链表是否只有一个节点呢？看看list\_is\_singular()的实现。

### 3. 插入结点

对链表的插入操作有两种：在表头插入和在表尾插入。Linux为此提供了两个接口：

```
static inline void list_add(struct list_head *new, struct list_head *head);
static inline void list_add_tail(struct list_head *new, struct list_head *head);

static inline void __list_add(struct list_head *new,
                  struct list_head *prev,
                  struct list_head *next)
{    
    next->prev = new;
    new->next = next;
    new->prev = prev;
    prev->next = new;
}    

static inline void list_add(struct list_head *new, struct list_head *head)
{    
    __list_add(new, head, head->next);                                                          
}    
    
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{    
    __list_add(new, head->prev, head);
}    

```

在表头插入是插入在head->next指向的结点，而在表尾插入是插入在head->prev指向的尾部结点。

### 4. 删除结点

```
static inline void __list_del(struct list_head * prev, struct list_head * next)
{    
    next->prev = prev;
    prev->next = next;
}    

static inline void __list_del_entry(struct list_head *entry)
{    
    __list_del(entry->prev, entry->next);
}    
     
static inline void list_del(struct list_head *entry)
{    
    __list_del(entry->prev, entry->next);
    entry->next = LIST_POISON1;
    entry->prev = LIST_POISON2;
}    

#define LIST_POISON1  ((void *) 0x100 + POISON_POINTER_DELTA)                               
#define LIST_POISON2  ((void *) 0x200 + POISON_POINTER_DELTA)
```

从链表中删除一个节点，需要改变该节点前驱节点的后继结点和后继结点的前驱节点。最后设置该节点的前驱节点和后继结点指向LIST\_POSITION1和LIST\_POSITION2两个特殊值，这样设置是为了保证不在链表中的节点项不可访问，对LIST\_POSITION1和LIST\_POSITION2的访问都将引起页故障。与之相对应，list\_del\_init()函数将节点从链表中解下来之后，调用LIST\_INIT\_HEAD()将节点置为空链状态。

### 5. 移动结点

Linux提供了将原本属于一个链表的节点移动到另一个链表的操作，并根据插入到新链表的位置分为两类：

```
static inline void list_move(struct list_head *list, struct list_head *head)
{  
    __list_del_entry(list);
    list_add(list, head);
}  

static inline void list_move_tail(struct list_head *list,
                  struct list_head *head)
{  
    __list_del_entry(list);
    list_add_tail(list, head);
}
```

move将一个节点移动到头部或者尾部。

例如list\_move(&new\_sockopt.list,&nf\_sockopts)会把new\_sockopt从它所在的链表上删除，并将其再链入nf\_sockopts的表头。

### 6. 判断链表

```
static inline int list_is_last(const struct list_head *list,
                const struct list_head *head)
{  
    return list->next == head;
}  

static inline int list_empty(const struct list_head *head)
{  
    return head->next == head;
}
```

list\_is\_last函数判断节点是否为末尾节点，list\_empty判断链表是否为空。

### 7. 合并链表

Linux链表还提供了整个链表的插入功能：

```
static inline void list_splice(struct list_head *list, struct list_head *head);

static inline void __list_splice(const struct list_head *list,
                 struct list_head *prev,
                 struct list_head *next)
{   
    struct list_head *first = list->next;
    struct list_head *last = list->prev;
    
    first->prev = prev;
    prev->next = first;
    
    last->next = next;
    next->prev = last;
}   
    
static inline void list_splice(const struct list_head *list,
                struct list_head *head)
{   
    if (!list_empty(list))
        __list_splice(list, head, head->next);
}   

```

假设当前有两个链表，表头分别是list1和list2（都是struct list\_head变量），当调用list\_splice(&list1,&list2)时，只要list1非空，list1链表的内容将被挂接在list2链表上，位于list2和list2.next（原list2表的第一个节点）之间。新list2链表将以原list1表的第一个节点为首节点，而尾节点不变。如图（虚箭头为next指针）：

链表合并list\_splice(&list1,&list2)：

![config](images/4.gif)

当list1被挂接到list2之后，作为原表头指针的list1的next、prev仍然指向原来的节点，为了避免引起混乱，Linux提供了一个list\_splice\_init()函数：

```
static inline void list_splice_init(struct list_head *list, struct list_head *head);
```

该函数在将list合并到head链表的基础上，调用INIT\_LIST\_HEAD(list)将list设置为空链。

### 8. 遍历

前面的操作入参全是struct list\_head类型。链表的遍历是链表最经常的操作之一，为了方便核心应用遍历链表，Linux链表将遍历操作抽象成几个宏。在介绍遍历宏之前，我们先看看如何从链表中访问到我们真正需要的数据项。

#### a)	由链表节点到数据项变量

Linux链表中仅保存了数据项结构中list\_head成员变量的地址，那么我们如何通过这个list\_head成员访问到作为它的所有者的**节点数据**呢？Linux为此提供了一个list\_entry(ptr,type,member)宏，其中ptr是指向该数据中list\_head成员的指针，也就是存储在链表中的地址值，type是数据项的类型，member则是数据项类型定义中list\_head成员的变量名，它完全是container\_of(ptr, type, member)的一个别名而已。container\_of()就是根据type类型结构体中的member成员的指针ptr，反身找到该member所在结构体对象的type首地址。如图：

![config](images/6.png)

此时的用法就变成下面这样子：

![config](images/7.png)

list\_entry的实现如下：

```
#define list_entry(ptr, type, member) container_of(ptr, type, member)

container_of宏定义在[include/linux/kernel.h]中：
#define container_of(ptr, type, member) ({          \
        const typeof( ((type *)0)->member ) *__mptr = (ptr); \
        (type *)( (char *)__mptr - offsetof(type,member) );})
        
offsetof宏定义在[include/linux/stddef.h]中：
#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
```

size\_t最终定义为unsigned int（i386）。

这里使用的是一个利用编译器技术的小技巧，即先求得结构成员在与结构中的偏移量，然后根据成员变量的地址反过来得出属主结构变量的地址。

container\_of()和offsetof()并不仅用于链表操作，这里最有趣的地方是((type *)0)->member，它将0地址强制"转换"为type结构的指针，再访问到type结构中的member成员。在container_of宏中，它用来给typeof()提供参数（typeof()是gcc的扩展，和sizeof()类似），以获得member成员的数据类型；在offsetof()中，这个member成员的地址实际上就是type数据结构中member成员相对于结构变量的偏移量。

如果这么说还不好理解的话，不妨看看下面这张图：

offsetof()宏的原理:

![config](images/5.gif)

对于给定一个结构，offsetof(type,member)是一个常量，list\_entry()正是利用这个不变的偏移量来求得链表数据项的变量地址。

#### b)	遍历宏

如果每次要遍历链表时既要定义临时的struct list\_head{}指针变量，又要定义目标结构体对象指针变量，总感觉些许不爽。

```
list_for_each_entry(pos, head, member)
```

参数pos和member意义没有变，而head则指向我们要遍历的链表首地址，这样一来开发者不用再自己定义struct list\_head{}类型临时指针变量，只要需要自己定义一个的目标数据结构的临时指针变量就可以了：

```
LIST_HEAD(student_list);
struct student *st;
list_for_each_entry(st, &student_list, stu_list){
    //Todo here … …
}
```


在[net/core/netfilter.c]的nf\_register\_sockopt()函数中有这么一段话：

```
        ……
struct list_head *i;
……
    list_for_each(i, &nf_sockopts) {
        struct nf_sockopt_ops *ops = (struct nf_sockopt_ops *)i;
        ……
    }
    ……
```

函数首先定义一个(struct list\_head *)指针变量i，然后调用list\_for\_each(i,&nf\_sockopts)进行遍历。在[include/linux/list.h]中，list\_for\_each()宏是这么定义的：

```
        #define list_for_each(pos, head) \
for (pos = (head)->next, prefetch(pos->next); pos != (head); \
        pos = pos->next, prefetch(pos->next))
```

它实际上是一个for循环，利用传入的pos作为循环变量，从表头head开始，逐项向后（next方向）移动pos，直至又回到head（prefetch()可以不考虑，用于预取以提高遍历速度）。

那么在nf\_register\_sockopt()中实际上就是遍历nf\_sockopts链表。为什么能直接将获得的list\_head成员变量地址当成struct nf\_sockopt\_ops数据项变量的地址呢？我们注意到在struct nf\_sockopt\_ops结构中，list是其中的第一项成员，因此，它的地址也就是结构变量的地址。更规范的获得数据变量地址的用法应该是：

```
struct nf_sockopt_ops *ops = list_entry(i, struct nf_sockopt_ops, list);
```

大多数情况下，遍历链表的时候都需要获得链表节点数据项，也就是说list\_for\_each()和list\_entry()总是同时使用。对此Linux给出了一个list\_for\_each\_entry()宏：

```
#define list_for_each_entry(pos, head, member)      ……
```

与list\_for\_each()不同，这里的pos是数据项结构指针类型，而不是(struct list\_head *)。nf\_register\_sockopt()函数可以利用这个宏而设计得更简单：

```
……
struct nf_sockopt_ops *ops;
list_for_each_entry(ops,&nf_sockopts,list){
    ……
}
……
```

某些应用需要反向遍历链表，Linux提供了list\_for\_each\_prev()和list\_for\_each\_entry\_reverse()来完成这一操作，使用方法和上面介绍的list\_for\_each()、list\_for\_each\_entry()完全相同。

如果遍历不是从链表头开始，而是从已知的某个节点pos开始，则可以使用list\_for\_each\_entry\_continue(pos,head,member)。有时还会出现这种需求，即经过一系列计算后，如果pos有值，则从pos开始遍历，如果没有，则从链表头开始，为此，Linux专门提供了一个list\_prepare\_entry(pos,head,member)宏，将它的返回值作为list\_for\_each\_entry\_continue()的pos参数，就可以满足这一要求。



## 三、链表操作接口


#### d)	合并

除了针对节点的插入、删除操作，

### 3. 遍历





### 4. 安全性考虑

在并发执行的环境下，链表操作通常都应该考虑同步安全性问题，为了方便，Linux将这一操作留给应用自己处理。Linux链表自己考虑的安全性主要有两个方面

#### a)	list_empty()判断

基本的list\_empty()仅以头指针的next是否指向自己来判断链表是否为空，Linux链表另行提供了一个list\_empty\_careful()宏，它同时判断头指针的next和prev，仅当两者都指向自己时才返回真。这主要是为了应付另一个cpu正在处理同一个链表而造成next、prev不一致的情况。但代码注释也承认，这一安全保障能力有限：除非其他cpu的链表操作只有list\_del\_init()，否则仍然不能保证安全，也就是说，还是需要加锁保护。

#### b)	遍历时节点删除

前面介绍了用于链表遍历的几个宏，它们都是通过移动pos指针来达到遍历的目的。但如果遍历的操作中包含删除pos指针所指向的节点，pos指针的移动就会被中断，因为list\_del(pos)将把pos的next、prev置成LIST\_POSITION2和LIST\_POSITION1的特殊值。

当然，调用者完全可以自己缓存next指针使遍历操作能够连贯起来，但为了编程的一致性，Linux链表仍然提供了两个对应于基本遍历操作的"\_safe"接口：list\_for\_each\_safe(pos, n, head)、list\_for\_each\_entry\_safe(pos, n, head, member)，它们要求调用者另外提供一个与pos同类型的指针n，在for循环中暂存pos下一个节点的地址，避免因pos节点被释放而造成的断链。

## 四、扩展

