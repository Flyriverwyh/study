内存屏障是一种底层原语，在不同计算机架构下有不同的实现细节。本文主要在`x86_64`处理器下，通过Linux及其内核代码来分析和使用内存屏障

对大多数应用层开发者来说，“内存屏障”（memory barrier）是一种陌生，甚至有些诡异的技术。实际上，他常被用在操作系统内核中，用于实现同步机制、驱动程序等。

利用它，能实现高效的无锁数据结构，提高多线程程序的性能表现。本文首先探讨了内存屏障的必要性，之后介绍如何使用内存屏障实现一个无锁唤醒缓冲区（队列），用于在多个线程间进行高效的数据交换。

# 理解内存屏障

程序实际运行时很可能并不完全按照开发者编写的顺序访问内存。例如：

```cpp
x = r;
y = 1;
```

这里，y = 1很可能先于x = r执行。这就是**内存乱序访问**。内存乱序访问行为出现的理由是为了提升**程序运行时的性能**.

**编译器**和**CPU**都可能引起**内存乱序访问**：

* 编译时，编译器优化进行**指令重排**而导致内存乱序访问；
* 运行时，**多CPU间交互**引入内存乱序访问。

编译器和CPU引入内存乱序访问通常不会带来什么问题，但在一些特殊情况下（主要是**多线程程序中**），**逻辑的正确性**依赖于**内存访问顺序**，这时，内存乱序访问会带来逻辑上的错误，例如：

```cpp
// thread 1
while(!ok);
do(x);

// thread 2
x = 42;
ok = 1;
```

ok初始化为0， 线程1等待ok被设置为1后执行do函数。假如，**线程2**对内存的**写操作乱序执行**，也就是**x赋值晚于ok赋值**完成，那么do函数接受的实参很有可能出乎开发者的意料，不为42。

我们可以引入内存屏障来避免上述问题的出现。内存屏障能让**CPU或者编译器**在**内存访问上有序**。一个内存屏障之前的内存访问操作必定先于其之后的完成。内存屏障包括两类：**编译器屏障**和**CPU内存屏障**。




# 参考

http://lday.me/2017/11/04/0016_what_is_memory_barriers/