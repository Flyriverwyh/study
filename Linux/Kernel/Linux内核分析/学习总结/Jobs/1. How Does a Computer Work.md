通过反汇编一个简单的C程序，分析汇编代码理解计算机是如何工作的

```
int g(int x)
{
	return x+7;
}

int f(int x)
{
	return g(x);
}

int main(void)
{
	return f(9) + 1;
}
```

编译到汇编语言，-m32 是将main.c编译成一个32位的汇编代码。

```
gcc -S -o main.s main.c -m32
```

汇编代码：

```
	.file	"main.c"
	.text
	.globl	g
	.type	g, @function
g:
.LFB0:
	.cfi_startproc
	pushl	%ebp
	.cfi_def_cfa_offset 8
	.cfi_offset 5, -8
	movl	%esp, %ebp
	.cfi_def_cfa_register 5
	movl	8(%ebp), %eax
	addl	$7, %eax
	popl	%ebp
	.cfi_restore 5
	.cfi_def_cfa 4, 4
	ret
	.cfi_endproc
.LFE0:
	.size	g, .-g
	.globl	f
	.type	f, @function
f:
.LFB1:
	.cfi_startproc
	pushl	%ebp
	.cfi_def_cfa_offset 8
	.cfi_offset 5, -8
	movl	%esp, %ebp
	.cfi_def_cfa_register 5
	subl	$4, %esp
	movl	8(%ebp), %eax
	movl	%eax, (%esp)
	call	g
	leave
	.cfi_restore 5
	.cfi_def_cfa 4, 4
	ret
	.cfi_endproc
.LFE1:
	.size	f, .-f
	.globl	main
	.type	main, @function
main:
.LFB2:
	.cfi_startproc
	pushl	%ebp
	.cfi_def_cfa_offset 8
	.cfi_offset 5, -8
	movl	%esp, %ebp
	.cfi_def_cfa_register 5
	subl	$4, %esp
	movl	$9, (%esp)
	call	f
	addl	$1, %eax
	leave
	.cfi_restore 5
	.cfi_def_cfa 4, 4
	ret
	.cfi_endproc
.LFE2:
	.size	main, .-main
	.ident	"GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-4)"
	.section	.note.GNU-stack,"",@progbits
```

其中以点开头的是用于链接时的辅助信息，不会在实际中执行，删除这些以点开头的内容，留下纯汇编代码

```
1 g:      
2         pushl   %ebp
3         movl    %esp, %ebp
4         movl    8(%ebp), %eax 
5         addl    $7, %eax 
6         popl    %ebp
7         ret
8 f:      
9         pushl   %ebp
10         movl    %esp, %ebp
11         subl    $4, %esp
12         movl    8(%ebp), %eax
13         movl    %eax, (%esp)
14         call    g
15         leave   
16         ret
17 main:   
18         pushl   %ebp
19         movl    %esp, %ebp
20         subl    $4, %esp
21         movl    $9, (%esp)
22         call    f
23         addl    $1, %eax
24         leave   
25         ret
```

与代码对比下：

![code comparing](images/1.png)

ebp指向堆栈的栈底