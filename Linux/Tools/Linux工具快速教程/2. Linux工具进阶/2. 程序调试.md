
# 进程调试

## gdb 程序交互调试

GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。

对于一名Linux下工作的c++程序员，gdb是必不可少的工具；

GDB中的命令固然很多，但我们只需掌握其中十个左右的命令，就大致可以完成日常的基本的程序调试工作。

以下从一个完整的调试过程简单说明最基本的几个命令;

```
$gdb programmer     # 启动gdb
>break main         # 设置断点
>run                # 运行调试程序
>next               # 单步调试
>print var1         # 在调试过程中，我们需要查看当前某个变量值的时候，使用print 命令打印该值
>list               # 显示当前调试处的源代码
>info b             # 显示当前断点设置情况
```

当你完成了第一个程序调试之后，你当然会需要更多的命令：关于gdb常用命令及各种调试方法详见 `gdb 调试利器` ;

同时，你需要更高效的调试：常用的调试命令都会有单字符的缩写，使用缩写更方便；同时，直接敲回车表示重复执行上一步命令；这在单步调试时非常有用；

## pstack 跟踪栈空间

pstack是一个脚本工具，可显示**每个进程的栈跟踪**。

pstack 命令必须由相应进程的属主或 root 运行。其**核心实现**就是使用了**gdb**以及`thread apply all bt`命令;

语法:

```
pstrack <program-pid>
```

示例:

```
$ pstack 4551
Thread 7 (Thread 1084229984 (LWP 4552)):
#0  0x000000302afc63dc in epoll_wait () from /lib64/tls/libc.so.6
#1  0x00000000006f0730 in ub::EPollEx::poll ()
#2  0x00000000006f172a in ub::NetReactor::callback ()
#3  0x00000000006fbbbb in ub::UBTask::CALLBACK ()
#4  0x000000302b80610a in start_thread () from /lib64/tls/libpthread.so.0
#5  0x000000302afc6003 in clone () from /lib64/tls/libc.so.6
#6  0x0000000000000000 in ?? ()
```

## strace分析系统调用

strace常用来跟踪**进程执行时**的**系统调用**和**所接收的信号**。

在Linux世界，进程**不能直接访问硬件设备**，当进程需要**访问硬件设备**(比如读取磁盘文件，接收网络数据等等)时，必须由**用户态模式**切换至**内核态模式**，通过系统调用访问硬件设备。

strace可以跟踪到一个进程**产生的系统调用**,包括**参数**，**返回值**，**执行消耗的时间**。

完整程序:

```
strace -o output.txt -T -tt -e trace=all -p 28979
```

跟踪28979进程的所有系统调用（`-e trace=all`），并统计**系统调用**的**花费时间**，以及**开始时间**（以可视化的时分秒格式显示），最后将记录结果存在`output.txt`文件里面。

查看进程正在做什么(实时输出进程执行系统调用的情况):

```
strace -p <process-pid>
```

关于strace的详细介绍，详见 `strace 跟踪进程中的系统调用` ;

# 目标文件分析

## nm列出符号清单

nm用来列出目标文件的符号清单。

```
$nm myProgrammer
08049f28 d _DYNAMIC
08049ff4 d _GLOBAL_OFFSET_TABLE_
080484dc R _IO_stdin_used
         w _Jv_RegisterClasses
08049f18 d __CTOR_END__
08049f14 d __CTOR_LIST__
08049f20 D __DTOR_END__
08049f1c d __DTOR_LIST__
080485e0 r __FRAME_END__
08049f24 d __JCR_END__
08049f24 d __JCR_LIST__
0804a014 A __bss_start
0804a00c D __data_start
08048490 t __do_global_ctors_aux
08048360 t __do_global_dtors_aux
0804a010 D __dso_handle
         w __gmon_start__
08048482 T __i686.get_pc_thunk.bx
08049f14 d __init_array_end
08049f14 d __init_array_start
08048480 T __libc_csu_fini
08048410 T __libc_csu_init
         U __libc_start_main@@GLIBC_2.0
0804a014 A _edata
0804a01c A _end
080484bc T _fini
080484d8 R _fp_hw
080482b4 T _init
08048330 T _start
0804a014 b completed.6086
0804a00c W data_start
0804a018 b dtor_idx.6088
080483c0 t frame_dummy
080483e4 T main
         U printf@@GLIBC_2.0
```

这些包含**可执行代码的段**称为**正文段**。

同样地，**数据段**包含了**不可执行的信息或数据**。

另一种类型的段，称为 **BSS 段**，它包含以**符号数据开头的块**。

对于 nm 命令列出的**每个符号**，它们的值使用**十六进制**来表示（缺省行为），并且在该符号前面加上了一个表示**符号类型**的**编码字符**。

常见的各种编码包括：

A 表示绝对 (absolute)，这意味着不能将该值更改为其他的连接；
B 表示 BSS 段中的符号；
C 表示引用未初始化的数据的一般符号。