很多Linux内存管理从**malloc**()这个C函数开始，从而知道**虚拟内存**。**虚拟内存是什么，怎么虚拟**？早期系统没有虚拟内存概念，**为什么**现代OS都有？要搞清楚虚拟内存，可能需要了解**MMU、页表、物理内存、物理页面、建立映射关系、按需分配、缺页中断和写时复制**等机制。

MMU，除了MMU工作原理，还会接触到Linux内核**如何建立页表映射**，其中也包括**用户空间页表的建立**和**内核空间页表**的建立，以及内核是如何**查询页表和修改页表**的。

当了解**物理内存**和**物理页面**时，会接触到**struct pg\_data\_t、struct zone和 struct page**等数据结构，这3个数据结构描述了系统中**物理内存的组织架构**。struct page数据结构除了描述一个4KB大 小（或者其他大小）的物理页面外，还包含很多复杂而有趣的成员。

当了解**怎么分配物理页面**时，会接触到**伙伴系统机制**和**页面分配器**（**page allocator**),页面分配器是内存管理中最复杂的代码之一。

有了**物理内存**，那**怎么和虚拟内存建立映射关系**呢？在 Linux内核中，描述**进程的虚拟内存**用**struct vm\_area\_struct**数据结构。**虚拟内存**和**物理内存**采用**建立页表**的方法来**完成建立映射关系**。为什么**和进程地址空间建立映射的页面**有的叫**匿名页面**，而有的叫**page cache页面**呢？

当了解**malloC()怎么分配出物理内存**时，会接触到**缺页中断**，缺页中断也是内存管理中最复杂的代码之一。

这时，**虚拟内存和物理内存己经建立了映射关系**，这是**以页为基础**的，可是有时内核需要**小于一个页面**大小的内存，那么**slab机制**就诞生了。

上面己经建立起虚拟内存和物理内存的基本框图，但是如果用户**持续分配和使用内存**导致**物理内存不足**了怎么办？此时**页面回收机制**和**反向映射机制**就应运而生了。

虚拟内存和物理内存的映射关系经常是**建立后又被解除**了，时间长了，系统**物理页面布局变得凌乱**不堪，碎片化严重，这时内核如果需要**分配大块连续内存**就会变得很困难，那么**内存规整机制**（Memory Compaction) 就诞生了。

上面就是学习Linux内存管理的历程。

除了依照思考题阅读内存管理代码之外，从用户态API深入了解Linux内核的内存管理机制，下面就是常用用户态内存管理相关的API。

```
void *malloc(size_t size);
void free(void *ptr )；

void *mmap(void *addr, size_t length, int prot, int flags,
            int fd, off_t offset);
int munmap(void *addr, size—t length);

int getpagesize(void);

int mprotect(const void *addr, size—t len, int prot);

int mlock(const void *addr, size _t len);
int munlock(const void *addr, size_t len);

int madvise(void *addr, size_t length, int advice);
void *mremap(void *old_address, size_t old_size,
            size_t new_size/ int flags, ... /* void *new_address */);

int remap_file_pages(void *addr, size_t size, int prot,
            ssize__t pgoff, int flags);
```

整个第二章：

- 忽略对大页面的处理，默认省略CONFIG\_TRANSPARENT\_HUGEPAGE的支持
- 默认忽略对锁的讨论，锁在内存管理中应用见4.7
- 对page cache讨论较少
- 实验对象是ARM Vexpress平台，忽略对NUMA讨论
- 忽略对memory cgroup讨论

- 2.1 物理内存初始化

    - 2.1.1 内存管理概述

    - 2.1.2 内存大小

    - 2.1.3 物理内存映射

    - 2.1.4 zone初始化

    - 2.1.5 空间划分

    - 2.1.6物理内存初始化

本节思考：

1. 在系统启动时，ARM Linux内核如何知道系统中有**多大的内存空间**？
2. 在32bit Linux内核中，**用户空间和内核空间的比例**通常是3:1,可以**修改**成2:2吗？
3. **物理内存页面**如何添加到**伙伴系统**中，是一页一页添加，还是以2的几次幂来加入呢？

现在大部分计算机使用**DDR**（Dual Data Rate SDRAM）的**存储设备**，DDR包括DDR3L、DDR4L、LPDDR3/4等。**DDR初始化**一般在**BIOS或boot loader中**，BIOS或boot loader将DDR大小传给内核，因此从**Linux内核角度**看其实就是**一段物理内存空间**。

## 1. 内存管理概述

分层描述的话，内存空间可以分为3个层次，分别是用户空间层、内核空间层和硬件层。如图2.1。

图2.1  内存管理框图：

![config](images/1.jpg)

用户空间和内核空间的接口是系统调用，因此内核空间层首先需要处理这些**内存管理相关**的**系统调用**，例如sys\_brk、sys\_mmap、sys\_madvise等。接下来就包括VMA管理、缺页中断管理、匿名页面、page cache、页面回收、反向映射、slab分配器、页表管理等模块了。

最下面是硬件层，包括处理器的MMU、TLB和cache部件，以及板载的物理内存，例如LPDDR或DDR。

## 2. 内存大小

ARM Linux中，**各种设备的相关属性描述**都**采用DTS方式**呈现。**DTS是device tree source**，最早由PowerPC等其他体系结构使用的FDT（Flattened Device Tree）转变的，ARM Linux社区自2011年被Linus公开批评后全面支持DTS。

在**ARM Vexpress**平台中，内存的定义在vexpress-v2p-ca9.dts文件中。该DTS文件定义了内存的起始地址为0x60000000,大小为0x40000000,即1GB大小内存空间。

```
[arch/arm/boot/dts/vexpress-v2p-ca9.dts]

memory@60000000 {
    device_type = "memory";
    reg = <0x60000000 0x40000000>;
};
```

内核启动中，需要解析这些DTS文件，在early\_init\_dt\_scan\_memory()函数中。代码调用关系是：start\_kernel()\->setup\_arch()\->setup\_machine\_fdt()\->early\_init\_dt\_scan\_nodes()\->early\_init\_scan\_memory()。

```
[drivers/of/fdt.c]

int _init early_init_dt_scan_memory(unsigned long node, const char *uname,
                        int depth, void *data)
{
    const char *type = of_get_f lat_dt_prop (node, "device_type", NULL);
    const _be32  *reg, *endp;
    int l;
    
    if (strcmp(type, "memory") != 0)  #重要：匹配memory
        return 0;
        
    reg = of_get_flat_dt_prop(node, "reg", &l);  #重要：取得reg
    endp = reg + (l / sizeof(_be32));
    
    while ((endp - reg) >= (dt_root_addr_cells + dt_root_size_cells)) {
        u64 base, size ；
        
        base = dt_mem_next_cell(dt_root_addr cells, &reg);
        size = dt_mem_next_cell(dt_root_size cells, &reg);
        
        if (size == 0)
            continue;
            
        early_init_dt_add_memory_ arch(base, size); #重要
    }
    return 0;
}
```

解析 “memory” 描述的信息从而**得到内存的base\_address和 size信息**，最后**内存块信息**通过early\_init\_dt\_add\_memory\_arch()\-〉memblock\_add()函数**添加到memblock子系统**中。

## 3. 物理内存映射

在内核使用内存前，需要**初始化内核的页表**，初始化页表主要在**map\_lowmem**()函数中。在**映射页表之前**，需要**把页表的页表项清零**，主要在**prepare\_page\_table**()函数中实现。

```
[start_kemel() ->setup_arch() ->paging_init()]


static inline void prepare_page_table(void)
{
    unsigned long addr ；
    phys_addr_t end;
    
    /*
     * Clear out all the mappings below the kernel image.
     */
    for (addr = 0; addr < MODULES_VADDR; addr += PMD_SIZE)
        pmd_clear(pmd_off_k (addr));        # 重要
        
    for ( ; addr < PAGE_OFFSET; addr += PMD_SIZE)
        pmd_clear(pmd_of f_k (addr));       # 重要
    
    /*
     * Find the end of the first block of lowrnem.
     */
    end = memblock.memory.regions[0].base + memblock.memory.regions[0].size;
    /*
     * Clear out all the kernel space mappings, except for the first
     * memory bank, up to the vmalloc region.
     */
    for (addr = _ phys_to_virt (end);
        addr < VMALLOC_START; addr += PMD_SIZE)
        pmd_clear(pmd_off_k(addr));         # 重要
}
```

这里对如下3段地址调用pmd\_clear()函数来**清除一级页表项**的内容。

- 0x0\~MODULES\_VADDR。
- MODULES\_VADDR\~PAGE_OFFSET。
- arm\_lowmem\_limit\~VMALLOC\_START。

```
[start_kernel() ->setup_arch() ->paging_init() ->map_lowmem()]

static void  __init map_lowmem(void)
{
    struct memblock_region *reg;
    phys_addr_t kernel_x_start = round_down(__pa(_stext), SECTION_SIZE);
    phys_addr_t kernel_x_end = round_up(__pa(__init_end), SECTION_SIZE);
    
    /* Map all the 1owmem memory banks.  */
    for_each_memblock(memory, reg) {
        phys_addr_t start = reg->base;
        phys_addr_t end = start + reg->size;
        struct map_desc map;
        
        if (end > arm_1owmem_limit)
            end = arm_1owmem_limit;
        
        //映射kernel image区域
        map.pfn =  __phys_to_pfn(kernel_x_start);
        map.virtual = __phys_to_virt(kernel_x_start)；
        map.length = kernel_x_end - kernel_x_start;
        map.type = MT_MEMORY_RWX；
        
        create_mapping(&map);    # 重要
        
        //映射低端内存
        if (kernel_x_end < end) {
            map.pfn = __phys_to_pfn(kernel_x_end);
            map.virtual = __phys_to_virt(kernel_x_end);
            map.length = end - kernel_x_end;
            map.type = MT_MEMORY_RW;
            
            create_mapping(&map);
        }
    }
}
```

真正创建页表是在**map\_lowmem()函数**中，会从内存开始的地方覆盖到arm\_lowmem\_limit处。这里需要考虑kernel代码段的问题，kernel的代码段从\_stext幵始，到\_init\_end结束。以ARM Vexpress平台为例。

- 内存开始地址0x60000000。
- \_stext: 0x60000000。
- \_init\_end: 0x60800000（该值与实际内核配置和image大小相关）。
- arm\_lowmem\_limit: 0x8f800000。