
# 猜测

linux 内存管理中oom killer机制存在于分配内存的`__alloc_pages_slowpath()`阶段

所以猜测 memcg的oom kill机制是在`try_charge`(统计计数)阶段

# 查看最初的代码

通过`tig mm/memcontrol.c`查看最开始代码, 能得到oom最初的代码

相关commit

Memory controller: OOM handling, c7ba5c9e8176704bfac0729875fa62798037584d, 2008-02-07, 08:42

原理

>oom(Out of memory)处理用于当cgroup超过其限制. 从超过限制的cgroup中拿到一个进程, 利用现有的oom逻辑kill掉这个进程.

代码分析

> `mem_cgroup_charge()` 定义在 `mm/memcontrol.c`

```cpp
int mem_cgroup_charge(struct page *page, struct mm_struct *mm)
{
        ......
        /*
         * If we created the page_cgroup, we should free it on exceeding
         * the cgroup limit.
         */
        // 创建了新的 page_cgroup, 当超过cgroup限制的话需要释放它
        while (res_counter_charge(&mem->res, PAGE_SIZE)) {
                // 释放
                if (try_to_free_mem_cgroup_pages(mem))
                        continue;

                /*
                 * try_to_free_mem_cgroup_pages() might not give us a full
                 * picture of reclaim. Some pages are reclaimed and might be
                 * moved to swap cache or just unmapped from the cgroup.
                 * Check the limit again to see if the reclaim reduced the
                 * current usage of the cgroup before giving up
                 */
                // 可能不会提供完整的回收信息
                // 一些页面被回收可能仅仅被移至交换缓存或仅从cgroup取消映射
                // 在放弃之前, 再次检查限制, 查看回收是否减少了cgroup的当前使用率
                // 
                if (res_counter_check_under_limit(&mem->res))
                        continue;
                        /*
                         * Since we control both RSS and cache, we end up with a
                         * very interesting scenario where we end up reclaiming
                         * memory (essentially RSS), since the memory is pushed
                         * to swap cache, we eventually end up adding those
                         * pages back to our list. Hence we give ourselves a
                         * few chances before we fail
                         */
                else if (nr_retries--) {
                        congestion_wait(WRITE, HZ/10);
                        continue;
                }

                css_put(&mem->css);
                mem_cgroup_out_of_memory(mem, GFP_KERNEL);
                goto free_pc;
        }
        ......
}
```
在`mem_cgroup_charge()`阶段, 



调用了`mem_cgroup_out_of_memory(mem, GFP_KERNEL);`, 

> `mem_cgroup_out_of_memory()` 定义在 `mm/oom_kill.c`







通过`struct mem_cgroup`中oom相关的结构体变量以及`mm/memcontrol.c`中相关变量(`memcg_oom_mutex`等), 查找最初的memcg oom killer代码

> 因为结构体位置有变化(从`mm/memcontrol.c`到了`include/linux/memcontrol.h`), 以及代码覆盖情况(时间太久了), 所以有过多次reset动作

先是关注`struct mem_cgroup`的变量, 如下

```cpp
struct mem_cgroup {
    /* OOM-Killer disable */
    int             oom_kill_disable;

    /* For oom notifier event fd */
    struct list_head oom_notify;
}
```

得到最终patch set, 2010-05-26, 14:42

* memcg: oom wakeup filter, dc98df5a1b7be402a0e1c71f1b89ccf249ac15ee
* memcg: oom notifier, 9490ff275606da012d5b373342a49610ad61cb81
* memcg: oom kill disable and oom status, 3c11ecf448eff8f12922c498b8274ce98587eb74

但是查看git show 





* memcg: fix oom kill behavior, 867578cbccb0893cc14fc29c670f7185809c90d6, 2010-03-10 15:22
























最终代码:
* arch: mm: remove obsolete init OOM protection, 94bce453c78996cc4373d5da6cfabe07fcc6d9f9
* arch: mm: do not invoke OOM killer on kernel fault OOM, 871341023c771ad233620b7a1fb3d9c7031c4e5c
* arch: mm: pass userspace fault flag to generic fault handler, 759496ba6407c6994d6a5ce3a5e74937d7816208
* x86: finish user fault error path with fatal signal, 3a13c4d761b4b979ba8767f42345fed3274991b0
* mm: memcg: enable memcg OOM killer only for user faults, 519e52473ebe9db5cdef44670d5a97f1fd53d721
* mm: memcg: rework and document OOM waiting and wakeup, fb2a6fc56be66c169f8b80e07ed999ba453a2db2
* mm: memcg: do not trap chargers with full callstack on OOM, 3812c8c8f3953921ef18544110dafc3505c1ac62




improve memcg oom killer robustness (提升memcg oom killer的健壮性)

* v1
    * patch set: https://lkml.org/lkml/2013/7/25/653 , 
    * lwn: https://lwn.net/Articles/560868/

* v2
    * patch set: https://lore.kernel.org/lkml/1375549200-19110-1-git-send-email-hannes@cmpxchg.org/ , https://lkml.org/lkml/2013/8/3/81 , 
    * lwn: https://lwn.net/Articles/562091/


第一版代码分析

在分配内存失败的情况下, memcg代码会导致task trap，直到解决OOM情况为止。此时, 它们可以持有各种锁（fs，mm），这容易导致死锁。

此系列patch将memcg OOM处理转换为在charge上下文中启动的两步过程，但是在完全解开错误堆栈后将进行任何等待。

1-4为支持新的memcg要求的体系结构处理程序做准备，但是这样做还可以消除旧的残废并统一整个体系结构的内存不足行为。

补丁5禁用了针对系统调用，预读，内核故障的memcg OOM处理，因为它们可以使用-ENOMEM正常展开堆栈。 OOM处理仅限于没有其他选择的用户触发的故障。

补丁6实现了由两部分组成的OOM处理，以使任务永远不会在OOM情况下被充满电荷的堆栈所困。




