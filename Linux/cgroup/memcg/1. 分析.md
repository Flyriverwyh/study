
# 概述

## 应用背景

Cgroup的memory子系统，即memory cgroup(本文以下简称memcg)，提供了对系统中一组进程的内存行为的管理，从而对整个系统中对内存有不用需求的进程或应用程序区分管理，实现更有效的资源利用和隔离。

在实际业务场景中，为了防止一些应用程序对资源的滥用（可能因为应用本身的bug，如内存泄露），导致对同一主机上其他应用造成影响，我们往往希望可以控制应用程序的内存使用量，这是memcg提供的主要功能之一，当然它还可以做的更多。

Memcg的应用场景，往往来自一些虚拟化的业务需求，所以memcg往往作为cgroup的一个子系统与容器方案一起应用。在容器方案中，与一般的虚拟化方案不同，memcg在管理内存时，并不会在物理内存上对每个容器做区分，也就是说所有的容器使用的是同一个物理内存（有一种例外情况，如果存在多个内存节点，则可以通过cgroup中的cpuset子系统将不同的内存节点应用到不同的容器中）。对于共用的物理内存，memcg也不会对不同的容器做物理页面的预分配，也就是说同一个内存page，可能会被容器A使用，也可能被容器B使用。

所以memcg应用在容器方案中，虽然没有实现真正意义上的内存虚拟化，但是通过内核级的内存管理，依然可以实现某种意义上的虚拟化的内存管理，而且是真正的轻量级的。

## 代码分析

基于

```
VERSION = 5
PATCHLEVEL = 11
SUBLEVEL = 0
EXTRAVERSION = -rc4
```

## 功能简介






> 整个统计和限制的实现过程可简单描述为：
>某进程在需要统计的地方调用mem_cgroup_charge()来进行必要的结构体设置（增加计数等），判断增加计数后进程所在的cgroup的内存使用是否超过限制，如果超过了，则触发reclaim机制进行内存回收，如果回收后依然超过限制，则触发oom或阻塞机制等待；如果增加计数后没有超过限制，则更新相应page对应的page_cgroup，完成统计计数的修改，并将相应的page放到对应的LRU中进行管理。


>对于charge(统计)功能的实现:
>a. 统计针对每一个cgroup进行；
>b. 每个cgroup中的进程，它的mm_struct知道自己属于哪个cgroup；
>c. 每个page对应一个page_cgroup，而page_cgroup知道自己属于哪个memcg；





https://blog.csdn.net/tanzhe2017/article/details/81001507