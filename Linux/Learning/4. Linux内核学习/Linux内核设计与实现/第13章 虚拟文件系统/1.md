
# 1. 定义

虚拟文件系统(VFS)为用户空间提供了文件和文件系统相关的接口.

系统中所有文件系统不但依赖 VFS 共存, 而且也依靠 VFS 系统协同工作.

通过 VFS, 程序可以利用标准 Unix 系统调用对不同文件系统, 甚至不同介质上的文件系统进行访问.

![2021-06-19-22-21-10.png](./images/2021-06-19-22-21-10.png)

> cp 命令从 ext3 文件系统格式的硬盘拷贝数据到 ext2 文件系统格式的可移动磁盘. 两种不同的文件系统, 两种不同的介质, 连接到同一个 VFS.

# 2. 内容和作用

## 2.1. 通用的文件系统接口

> 简化了应用的开发

VFS 和块 I/O 相结合, 用户态可以直接使用 open()、read() 和 write() 这样统一的系统调用, 而无需考虑具体的文件系统和实际物理介质.

## 2.2. 文件系统抽象层

> 简化了新文件系统的实现

为了可以提供这种通用接口, 内核在底层文件系统接口之上建立了一个抽象层. 

VFS 抽象层为了衔接底层的多种文件系统, 它提供了一个通用文件系统模型, 该模型定义了任何文件系统都支持的、基本的、概念上的接口和数据结构. 该模型偏重于 Unix 风格的文件系统.

实际文件系统通过编程提供 VFS 期望的抽象接口和数据结构.

这样, 内核可以和任何文件系统协同工作, 并且提供给用户空间的接口, 也可以和任何文件系统无缝连接在一起.

## 2.3. 示例

用户程序执行如下操作:

```cpp
ret = write(fd, buf, len);
```

这个系统调用将 buf 指针指向的长度为 len 字节的数据写入文件描述符 fd 对应的文件的当前位置.

1. 首先被一个通用系统调用 sys_write() 处理, sys_write() 要找到 fd 所在的实际文件系统的写操作, 然后执行该操作;

2. 实际文件系统的写方法是文件系统实现的一部分, 数据最终通过该操作写入介质.

![2021-06-19-22-54-27.png](./images/2021-06-19-22-54-27.png)

# 3. Unix 风格文件系统

## 3.1. 四个抽象概念

Unix 使用了四种文件系统相关的抽象概念: **文件**、**目录项**、**索引节点**(`inode`)和**安装点**(`mount point`).

本质上讲, 文件系统是特殊的**数据分层存储结构**, 它包含**文件**、**目录**和**相关的控制信息**. 文件系统的通用操作包括创建、删除和安装等. 在 Unix 中, 文件系统被安装在一个特定的安装点上, 该安装点在**全局层次结构**中被称为**命名空间**, 所有已安装的文件系统都作为根文件系统树的叶子出现.

> Linux 已经引入了进程级命名空间, 每个进程指定唯一的命名空间. 因为每个进程都会继承父进程的命名空间(除非特别声明), 所以所有进程往往都只有一个全局命名空间.

**文件**就是一个有序字节串, 第一个字节是文件头, 最后一个字节是文件尾. Unix 文件的概念与面向记录的文件系统中文件对比:

* 面向记录的文件系统提供更丰富、更结构化的表示;

* 面向字节流的 Unix 文件则简单.

文件通过目录组织. 目录层层嵌套, 形成文件路径. 路径中每一个部分都被称为目录条目. "`/home/wolfman/butter`" -- **根目录** `/`, **目录** `home`、`wolfman` 和 **文件** `butter` 都是目录条目, 统称**目录项**. Unix 中, 目录属于普通文件.

Unix 将文件的相关信息和文件本身区分开. **文件相关信息**, 也称**文件元数据**, 被存储在一个单独的数据结构中, 即**索引节点**(inode, index node).

**文件系统的控制信息**存储在**超级块数据结构**中.

**文件系统的控制信息**和**文件信息**统称**文件系统数据元**.

## 3.2. 物理磁盘布局

Unix 文件系统在物理磁盘布局往往也是按照上面概念来的.

比如在磁盘上, 文件(目录也是文件)信息按照索引节点(inode)形式存储在单独的块中; 控制信息被集中存储在磁盘的超级块中, 等等.

# 4. VFS 对象及其数据结构

VFS 采用面向对象的设计思路, 使用一系列**数据结构**表示. **结构体**包含**数据**的同时也包含这些数据的**函数操作**, 其中操作函数由具体文件系统实现.

## 4.1. 四个主要对象类型

* 超级块对象, 代表一个**具体的已安装文件系统**;

* 索引节点对象, 代表一个**具体文件**;

* 目录项对象, 代表一个**目录项**, 是**路径的一个组成部分**;

* 文件对象, 代表由**进程打开的文件**.

注, VFS 将目录作为文件, 所以不存在目录对象. **目录项**代表路径中的一个组成部分, 它**可能包含一个普通文件**. 总之, 目录项不同于目录, 但是目录却是另一种形式的文件.

## 4.2. 操作对象

**每个主要对象**都包含**一个操作对象**, 描述了内核可以使用的操作函数:

* super_operations 对象, 包含内核针对特定文件系统能调用的方法, 比如 write_inode() 和 sync_fs() 等;

* inode_operations 对象, 包含内核对特定文件能调用的方法, 比如 create() 和 link() 等;

* dentry_operations 对象, 包含内核针对特定目录项所能调用的方法, 比如 d_compare() 和 d_delete() 等方法;

* file_operations 对象, 包含进程针对已打开文件能调用的方法, 比如 read() 和 write() 等方法.

操作对象通过一个个**结构体指针**来实现, 此结构体包含指向操作其父对象的函数指针. 很多方法可以继承使用 VFS 提供的通用方法.

## 4.3. 其他对象

VFS 使用了大量结构体对象. 还有其他的, 比如:

* 每个注册的文件系统都由 file_system_type 结构体表示, 描述了某种文件系统;

* 每个安装点(mount point)都用 vfsmount 结构体表示, 描述安装点的相关信息, 如位置和安装标志等.

* 与进程相关的结构体, 比如 fs_struct  结构体和 file 结构体.

# 5. 超级块对象

各种文件系统都必须实现.

用于存储**特定文件系统的信息**, 通常对应于存放在**磁盘特定扇区**中的**文件系统超级块**或**文件系统控制块**. 而基于**非磁盘的文件系统**(比如内存文件系统, sysfs等), 会创建超级块并将其保存在内存中.

超级块对象由 super_block 结构体表示.

```cpp
struct super_block {
    struct list_head    	s_list;			/* 指向所有超级块的链表 */
    dev_t			s_dev;			/* 设备标识符 */
    unsigned long 		s_blocksize; 		/* 以字节为单位的块大小 */
    unsigned char 		s_blocksize_bits;	/* 以位为单位的块大小 */
    unsigned char 		s_dirt;			/* 修改(脏)标志 */
    unsigned long long 		s_maxbytes;		/* 文件大小上限 */
    struct file_system_type	s_type;			/* 文件系统类型 */
    struct super_operations    	s_op; 			/* 超级块方法 */
    struct dquot_operations	*dq_op;			/* 磁盘限额方法 */
    struct export_operations	*s_export_op;		/* 导出方法 */
    unsigned long		s_flags;		/* 挂载标志 */
    unsigned long		s_magic;		/* 文件系统魔数 */
    struct dentry        	*s_root;           	/* 目录挂载点 */
    struct rw_semaphore		s_umount;		/* 卸载信号量 */
    struct semaphore        	s_lock;            	/* 超级块信号量 */
    int            		s_count;           	/* 超级块引用计数 */
    int				s_need_sync;		/* 尚未同步标志 */
    atomic_t			s_active;		/* 活动引用计数 */
    void			*s_security;		/* 安全模块 */
    struct xattr_handler	**s_xattr;		/* 扩展的属性操作 */
    struct list_head    	s_inodes;           	/* inode链表 */
    struct list_head		s_dirty;		/* 脏数据链表 */
    struct list_head		s_io;			/* 回写链表 */
    struct list_head		s_more_io;		/* 更多回写链表 */
    struct hlist_head		s_anon;			/* 匿名目录项 */
    struct list_head		s_files;		/* 被分配文件链表 */
    struct list_head		s_dentry_lru;		/* 未被使用目录项链表 */
    int 			s_nr_dentry_unused;	/* 上面链表中目录项的数据 */
    struct block_device		*s_bdev;		/* 相关的块设备 */
    struct mtd_info        	*s_mtd;            	/* 存储磁盘信息 */
    struct list_head		s_instance;		/* 该类型文件系统 */
    struct quota_info		s_dquota;		/* 限额相关选项 */
    int				s_frozen;		/* frozen标志位 */
    wait_queue_head_t		s_wait_unfrozen;	/* 冻结的等待队列 */
    char			s_id[32];		/* 文本名字 */
    void			*s_fs_info;		/* 文件系统特殊信息 */
    fmode_t            		s_mode;               	/* 安装权限 */
    struct semaphore		s_vfs_rename_sem;	/* 重命名信号量 */
    u32				s_time_gran;		/* 时间戳粒度 */
    char			*s_subtype;		/* 子类型名称 */
    char			*s_options;		/* 已存安装选项 */
};
```

**超级块对象**通过 `alloc_super()` **创建并初始化**. 在**文件系统安装**时, 文件系统会调用该函数, 然后从磁盘读取文件系统超级块, 并将其信息填充到内存中的超级块对象中.

# 超级块操作对象

超级块对象中的 s_op 指向超级块的操作函数表.

```cpp
struct super_operations {
    struct inode *(*alloc_inode)(struct super_block *sb); /* 创建和初始化一个索引节点对象 */
    void (*destroy_inode)(struct inode *);                /* 释放给定的索引节点 */
    
    void (*dirty_inode) (struct inode *);                 /* VFS在索引节点被修改时会调用这个函数 */
    int (*write_inode) (struct inode *, int);             /* 将索引节点写入磁盘，wait表示写操作是否需要同步 */
    void (*drop_inode) (struct inode *);                  /* 最后一个指向索引节点的引用被删除后，VFS会调用这个函数 */
    void (*delete_inode) (struct inode *);                /* 从磁盘上删除指定的索引节点 */
    void (*put_super) (struct super_block *);             /* 卸载文件系统时由VFS调用，用来释放超级块 */
    void (*write_super) (struct super_block *);           /* 用给定的超级块更新磁盘上的超级块 */
    int (*sync_fs)(struct super_block *sb, int wait);     /* 使文件系统中的数据与磁盘上的数据同步 */
    int (*statfs) (struct dentry *, struct kstatfs *);    /* VFS调用该函数获取文件系统状态 */
    int (*remount_fs) (struct super_block *, int *, char *); /* 指定新的安装选项重新安装文件系统时，VFS会调用该函数 */
    void (*clear_inode) (struct inode *);                 /* VFS调用该函数释放索引节点，并清空包含相关数据的所有页面 */
    void (*umount_begin) (struct super_block *);          /* VFS调用该函数中断安装操作 */
};
```

由于 C 语言不支持面向对象, 无法得到操作函数的父对象, 所以很多函数需要将超级块对象作为参数进行传递. 比如:

```cpp
// C
sb->s_op->write_super(sb);

// C++
sb.write_super();
```