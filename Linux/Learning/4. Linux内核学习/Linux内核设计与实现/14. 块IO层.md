
# 背景

两种基本设备类型:

* 字符设备: 按**字节流**的顺序**有序读写**. 串口和键盘等. 键盘输入字符串"wolf", 对键盘进行读操作得到**字符流**, 先 "w", 然后 "o", 再是 "l", 最后是 "x".

* 块设备: **随机**(不需要按顺序)读写**固定大小数据片**(chunks)的硬件设备, 固定大小的数据片就叫**块**. 硬盘、软盘驱动器、蓝光光驱和闪存等.

字符设备是顺序访问, 仅仅需要控制一个位置: 当前位置. 所以不必提供一个专门子系统管理.

块设备随机访问, 在介质的不同区间前后移动. 有专门的子系统: 块设备的复杂性; 块设备对执行性能要求很高.

# 扇区和块

块设备最小的可寻址单元是扇区, 即对块设备的I/O无法比对扇区还小的单元进行寻址和操作. 扇区大小一般是 2 的整数倍, 最常见是 512 字节.

块是文件系统的一种抽象 -- 只能基于块来访问文件系统. 即内核执行的所有磁盘操作都是按照块进行的, 虽然物理磁盘寻址是按扇区级进行的.

由于扇区是物理设备的最小可寻址单元, 而逻辑上最小的可寻址单元是块, 所以块大小只能数倍于扇区大小; 内核还要求块大小是 2 的整数倍, 而且不能超过一个页的长度(见12章和19章).

块大小最终要求: 必须是扇区大小的 2 的整数倍; 必须小于页面大小. 通常块大小是 512 字节、1KB 或 4KB.

* 扇区, 物理设备的最小可寻址单元, 也被称为 "**硬扇区**" 或 "**设备块**"

* 块, 文件系统的最小寻址单元, 也被称为 "**文件块**" 或 "**I/O 块**"


```
#sudo fdisk -l
Disk /dev/sda: 500.1 GB, 500107862016 bytes, 976773168 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes
Disk identifier: 0x00000000
```

* Sector size: 扇区大小值, 逻辑大小是为了兼容以前的软件; 物理大小才是实际扇区大小

* I/O size: 块大小值

# 缓冲区和缓冲区头

内核通过文件系统访问块设备, 需要将**块**读入到内存时, 它要存储在一个缓冲区中. **每个缓冲区**与**一个块**对应, 它相当于是块在内存中的表示.

> 块是文件系统的最小寻址单元

块包含一个或多个扇区, 大小不超过一个页面, 所以**一个页**可以容纳一个或**多个**内存中的**块**(**缓冲区**).

每个缓冲区有一个对应的描述符, buffer_head 结构体, 称为缓冲区头, 包含内核操作缓冲区所需要的全部信息.

```cpp
struct buffer_head {
    unsigned long 		b_state;	/* 表示缓冲区状态 */
    struct buffer_head 		*b_this_page;	/* 当前页中缓冲区 */
    struct page 		*b_page;     	/* 当前缓冲区所在内存页 */

    sector_t 			b_blocknr;   	/* 起始块号 */
    size_t 			b_size;      	/* buffer在内存中的大小 */
    char 			*b_data;    	/* 块映射在内存页中的数据 */

    struct block_device 	*b_bdev; 	/* 关联的块设备 */
    bh_end_io_t 		*b_end_io;  	/* I/O完成方法 */
    void 			*b_private;   	/* 保留的 I/O 完成方法 */
    struct list_head 		b_assoc_buffers;/* 关联的其他缓冲区 */
    struct address_space	*b_assoc_map;	/* 相关的地址空间 */
    atomic_t 			b_count;      	/* 引用计数 */
};
```

b_state 表示缓冲区的状态, 可以是 bh_state_bits 枚举中多个的组合.

```cpp
enum bh_state_bits {
    BH_Uptodate,    	/* 包含可用数据 */
    BH_Dirty,    	/* 该缓冲区是脏的(说明缓冲的内容比磁盘中的内容新，需要回写磁盘) */
    BH_Lock,    	/* 该缓冲区正在被I/O使用，锁住以防止并发访问 */
    BH_Req,        	/* 该缓冲区有I/O请求操作 */
    BH_Uptodate_Lock,	/* 由内存页中的第一个缓冲区使用，使得该页中的其他缓冲区 */
    BH_Mapped,    	/* 该缓冲区是映射到磁盘块的可用缓冲区 */
    BH_New,        	/* 缓冲区是通过 get_block() 刚刚映射的，尚且不能访问 */
    BH_Async_Read,    	/* 该缓冲区正通过 end_buffer_async_read() 被异步I/O读操作使用 */
    BH_Async_Write,    	/* 该缓冲区正通过 end_buffer_async_read() 被异步I/O写操作使用 */
    BH_Delay,    	/* 缓冲区还未和磁盘关联 */
    BH_Boundary,    	/* 该缓冲区处于连续块区的边界，下一个块不在连续 */
    BH_Write_EIO,    	/* 该缓冲区在写的时候遇到 I/O 错误 */
    BH_Ordered,    	/* 顺序写 */
    BH_Eopnotsupp,    	/* 该缓冲区发生 “不被支持” 错误 */
    BH_Unwritten,    	/* 该缓冲区在磁盘上的位置已经被申请，但还有实际写入数据 */
    BH_Quiet,    	/* 该缓冲区禁止错误 */

    BH_PrivateStart,	/* 不是表示状态，分配给其他实体的私有数据区的第一个bit */
};
```

块 I/O 层不会使用 BH_PrivateStart 或更高位. 可被其他程序使用.

操作缓冲区之前, 应先使用 get_bh() 增加引用计数, 确保该缓冲区头不再被分配出去; 完成操作后, 调用 put_bh() 减少引用计数.

与缓冲区对应的磁盘物理块由 b_blocknr 指向, 该值是 b_bdev 指明的块设备中的逻辑块号.

与缓冲区对应的内存物理页由 b_page 表示, b_data 直接指向相应的块(位于 b_page 指向的页面的某个位置上), 块大小由 b_size 域表示. 所以块在内存汇总的起始位置在 b_data 处, 结束位置是 (b_data + b_size) 处.

缓冲区头目的: 仅仅是一个**描述符**, 说明**内存缓冲区**(在特定页面上的字节序列)和**块**的**映射关系**.

2.6 内核以前, 缓冲区头作为内核中的 **I/O 操作单元**, 不仅描述了块和物理内存的映射, 还是**所有块 I/O 操作的容器**.

通过缓冲区头来管理内核的所有块 I/O 操作有 2 个弊端:

1. 内核更倾向于操作页面结构, 因为简单且高效. 所以 2.6 中, 很多 I/O 操作都是通过内核直接对页面或地址空间进行操作的, 不再使用缓冲区头; 每个**块**对应一个缓冲区头, 太耗内存(原来结构体巨大).

2. 每个缓冲区头只能表示一个块, 内核对**大块数据**的 I/O 操作会被分解为**多个对 buffer_head 结构体**进行操作. 不必要的负担和空间浪费.

# bio 结构体

为改善上面缓冲区头的 2 个弊端, 引入了 bio, 它表示**一次块 I/O 操作**涉及的**所有内存页**.

块 I/O 操作的基本容器由 bio 结构体表示. 代表了正在现场的(活动的)以片段(segment)链表形式组织的块 I/O 操作. 不需要保证单个缓冲区一定要连续. 一个片段就是一小块连续的内存缓冲区, 即让一个缓冲区分三个内存的多个位置上.

```cpp
/*
 * I/O 操作的主要单元，针对 I/O块和更低级的层 (ie drivers and
 * stacking drivers)
 */
struct bio {
    sector_t      	bi_sector;    	/* 磁盘上相关扇区 */
    struct bio        	*bi_next;    	/* 请求列表 */
    struct block_device	*bi_bdev; 	/* 相关的块设备 */
    unsigned long     	bi_flags;    	/* 状态和命令标志 */
    unsigned long	bi_rw;        	/* 读还是写 */

    unsigned short   	bi_vcnt;    	/* bio_vecs的数目 */
    unsigned short   	bi_idx;        	/* bio_io_vect的当前索引 */

    /* Number of segments in this BIO after
     * physical address coalescing is performed.
     * 结合后的片段(segment)数目
     */
    unsigned int	bi_phys_segments;
    unsigned int        bi_size;    	/* 剩余 I/O 计数 */

    /*
     * To keep track of the max segment size, we account for the
     * sizes of the first and last mergeable segments in this bio.
     * 第一个和最后一个可合并的段的大小
     */
    unsigned int        bi_seg_front_size;
    unsigned int        bi_seg_back_size;

    unsigned int        bi_max_vecs; 	/* bio_vecs数目上限 */
    unsigned int        bi_comp_cpu;    /* 结束CPU */

    atomic_t        	bi_cnt;    	/* 使用计数 */
    struct bio_vec   	*bi_io_vec;	/* bio_vec 链表 */
    bio_end_io_t        *bi_end_io; 	/* I/O 完成方法 */
    void            	*bi_private;    /* bio结构体创建者的私有方法 */
    bio_destructor_t    *bi_destructor;	/* bio撤销方法 */
    /*
     * We can inline a number of vecs at the end of the bio, to avoid
     * double allocations for a small number of bio_vecs. This member
     * MUST obviously be kept at the very end of the bio.
     * 内嵌在结构体末尾的 bio 向量，主要为了防止出现二次申请少量的 bio_vecs
     */
    struct bio_vec 	bi_inline_vecs[0];
};
```

bi_io_vec 指向一个 bio_vec 结构体链表, 每个表示 I/O 操作的一个片段; bi_vcnt 表示这个链表的个数

![2021-06-22-20-56-37.png](./images/2021-06-22-20-56-37.png)

