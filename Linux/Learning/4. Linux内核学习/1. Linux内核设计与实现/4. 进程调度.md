
# 多任务系统

多任务系统分为两类: 非抢占式多任务(cooperative multitasking)和抢占式多任务(preemptive multitasking).

Linux 提供了抢占式的多任务模式. 此模式, 调度程序会决定什么时候停止一个进程的运行, 以便其他进程能得到执行机会. 这个**强制的挂起动作**就是**抢占**(preemption). 进程被抢占前能运行的时间是预先设置好的, 即进程的**时间片**(timeslice). 多数系统对程序采用了**动态时间片计算方式**, 并引入了**可配置的计算策略**. 不过, Linux 的 "公平" 调度程序没有采用时间片达到公平调度.

非抢占多任务模式下, 除非进程自己主动停止运行, 否则会一直执行. 进程**主动挂起自己**的操作叫做**让步**(yielding). 缺点很明显: 调度程序无法对每个进程执行时间做出统一规定, 所以进程占用的时间可能超预期; 一个决不让步的悬挂进程可能使系统崩溃. 目前, 基本没有系统采用这种模式.

Unix 一开始就采用了抢占式多任务.

# 什么是调度程序

调度程序负责决定将**哪个进程投入运行**、**何时运行**以及**运行多长时间**.

为获得更好的用户体验, 运行中的进程还可以立即被其他更紧急的进程打断.

总之, 调度是一个平衡的过程. 一方面, 保证各个运行的进程能够最大限度的使用 CPU(即尽量少的切换进程); 另一方面, 保证各个进程能公平使用 CPU(即防止一个进程长时间独占CPU).

# Linux 的进程调度

1991 年 Linux 第 1 版到 2.4 内核, 调度程序都很简陋. 

2.5 版本采用 O(1) 调度程序. 静态时间片算法和针对每一处理器的运行队列. 在**数以十计**(不是数以百计)的多处理器环境下表现出近乎完美的性能和可扩展性. 但对于**响应时间敏感的程序**先天不足. 这种程序被称为**交互进程**. 所以在大服务器工作很理想, 但是对有很多交互程序运行的桌面系统上表现不佳.

2.6 内核为提高对交互程序的调度性能, 引入了新的调度算法. 最著名的是 "反转楼梯最后期限调度算法"(Rotating Staircase Deadline Scheduler, RSDL), 该算法吸取了队列理论, 将公平调度概念引入了 Linux 调度程序. 最终替代了 O(1), 被称为 "完全公平调度算法", 简称 CFS.

# 策略



## IO 消耗型和 CPU 消耗型进程

进程可以被分为这两种:

* I/O 消耗型: 大部分时间用来**提交 I/O 请求**或者**等待 I/O 请求**. 进程经常处于**可运行状态**, 但通常**只运行短短一会儿**, 因为它在**等待更多的 I/O 请求**时**最后总会阻塞**(这里所说的 I/O 是指任何类型的可阻塞资源, 比如键盘输入或网络I/O). 举例, 多数用户图形程序(GUI)属于 I/O 密集型, 即便它们从不读取或写入磁盘, 它们也在多数时间等待来自鼠标或者键盘的用户交互操作.

* CPU 消耗型: 大多数时间用来执行代码. 除非被抢占, 否则一直不停运行, 因为它们没有太多 I/O 需求. 但是, 因为它们不属于 I/O 驱动类型, 所以从系统响应速度考虑, 调度器不应该经常让它们运行. 调度策略往往是尽量降低它们的调度频率, 而延长其运行时间. 极端例子就是无限循环地执行, 比如大量数学计算的程序(sshkeygen 或 MATLAB).

这种划分并非绝对. 进程可以同时展示这两种行为: 比如, X Window 服务; 还有可以是 I/O 消耗型, 但属于处理器消耗型活动的范围. 典型如字处理器, 其通常等待键盘输入, 但在任一时刻可能又粘住处理器疯狂进行拼写检查或宏计算.

调度程序通常在这两个矛盾的目标中间寻找平衡: 进程响应迅速(响应时间短)和最大系统利用率(高吞吐量). Linux 为保证交互式应用和桌面系统的性能, 所以优化了进程的响应时间, 更倾向于优先调度 I/O 消耗型进程.

## 进程优先级

调度算法中最基本的一类就是基于优先级的调度. 通常做法是(并未被 Linux 完全采用)优先级高的进程先运行, 低的后运行; 相同优先级的进程按轮转方式进行调度. 有些系统中, 优先级高的时间片也比较长. 调度程序总是选择时间片未用尽且优先级高的运行. 所以用户可以通过设置优先级来影响系统的调度.

Linux 采用了两种不同的优先级范围.

第一种是用**nice值**. 范围是 `-20 ~ +19`, 默认为 0; 越大的 nice 值是更低的优先级. nice 值是所有 Unix 系统中的标准化的概念, 只是不同 Unix 系统对 nice 值的使用不同(调度算法不同). 比如, Mac OS X 中 nice 值意味着进程的时间片的绝对值; Linux 中 nice 值代表时间片的比例. 通过 `perf -el` 中的 NI 列是进程对应的 nice 值.

```
# ps -el
F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0       1       0  0  80   0 - 45978 do_epo ?        00:00:02 systemd
1 S     0       2       0  0  80   0 -     0 -      ?        00:00:00 kthreadd
1 I     0       3       2  0  60 -20 -     0 -      ?        00:00:00 rcu_gp
1 I     0       4       2  0  60 -20 -     0 -      ?        00:00:00 rcu_par_gp
1 I     0       6       2  0  60 -20 -     0 -      ?        00:00:00 kworker/0:0H-events_highpri
1 R     0       8       2  0  80   0 -     0 -      ?        00:00:00 kworker/u256:0-events_unbound
```

第二种是**实时优先级**. 范围是 `0 ~ 99`. 与 nice 值意义相反, 越高的实时优先级数值意味着优先级越高. **任何实时进程**的优先级都高于**普通进程**, 所以**实时优先级和nice优先级互不相交**. Linux 的实时优先级实现参考了 Unix  相关标准, 特别是 `POSIX.1b`. 多数 Unix 系统也提供了类似机制. 通过命令查看

```
# ps -eo state,uid,pid,ppid,rtprio,time,comm
S   UID     PID    PPID RTPRIO     TIME COMMAND
S     0       1       0      - 00:00:02 systemd
S     0       2       0      - 00:00:00 kthreadd
S     0      12       2     99 00:00:00 migration/0
S     0      13       2     99 00:00:00 watchdog/0
S     0      14       2      - 00:00:00 cpuhp/0
S     0      15       2      - 00:00:00 cpuhp/1
S     0      16       2     99 00:00:00 watchdog/1
S     0      17       2     99 00:00:00 migration/1
S     0      18       2      - 00:00:00 ksoftirqd/1
I     0      20       2      - 00:00:00 kworker/1:0H-events_highpri
S     0      23       2      - 00:00:00 kdevtmpfs
I     0      24       2      - 00:00:00 netns
S     0      40       2     99 00:00:00 watchdogd
I     0      41       2      - 00:00:00 kworker/0:1H-kblockd
S     0      62       2      - 00:00:00 kswapd0
I     0     155       2      - 00:00:00 kthrotld
S     0     156       2     50 00:00:00 irq/24-pciehp
S     0     157       2     50 00:00:00 irq/25-pciehp
S     0     158       2     50 00:00:00 irq/26-pciehp
```

对应列显示 "-", 说明它不是实时进程.

## 时间片

时间片是一个数值, 表明进程在被抢占之前所能持续运行的时间.

> Linux 中叫做 时间片(time slice). 其他系统中, 也被称为 量子(quantum) 或 处理器片(processor slice).

