
# 1. 进程

进程就是处于执行期的程序. 但进程不仅仅局限于一段可执行程序代码(unix 称为代码段, text section), 通常还要包含其他资源, 像打开的文件、挂起的信号、内核内部数据、处理器状态, 一个或多个具有内存映射的内存地址空间及一个或多个执行线程(thread of execution), 以及用来存放全局变量的数据段等.

执行线程, 简称线程(thread), 是在进程中活动的对象. 每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器. 

内核调度的对象是线程, 而不是进程. Linux 中线程只不过是一种特殊的进程.

进程提供了两种虚拟机制: 虚拟处理器和虚拟内存. 

* 虚拟处理器, 让进程觉得自己独享处理器;

* 虚拟内存, 让进城觉得自己拥有整个系统的所有内存资源.

线程之间可以共享虚拟内存, 但每个都拥有各自的虚拟处理器.

程序本身不是进程, 进程是处于执行器的程序以及相关的资源的总称. 多个不同的进程可以执行同一个程序; 两个或两个以上并存的进程还可以共享许多比如打开的文件、地址空间之类的资源.

进程在创建它的时候开始存活. 通常调用 fork(), 通过复制一个现有进程来创建一个全新进程. 调用结束时, 在返回点这个相同位置上, 父进程恢复执行, 子进程开始执行. fork() 系统调用从内核返回两次: 一次回到父进程, 另一次回到新产生的子进程.

> 实际上由 clone() 系统调用实现

通常, 创建新进程是为了执行新程序. 调用 exec() 这组函数, 创建新的地址空间, 并将新的程序载入其中.

最后, 通过 exit() 退出执行. 终结进程并将其占用的资源释放掉. 进程退出会被设置成僵死状态, 直到父进程调用 wait() 或 waitpid().

# 2. 进程描述符及任务结构

内核将进程存放在叫做任务队列(task list)的双向循环链表中. 链表中每一个项类型都是 task_struct, 即进程描述符(process descriptor).

进程描述符中包含的数据能完整地描述一个正在执行的程序: 它打开的文件, 进程的地址空间, 挂起的信号, 进程的状态, 和其他更多信息.

![2021-06-30-19-53-20.png](./images/2021-06-30-19-53-20.png)

## 2.1. 分配进程描述符

Linux 通过 slab 分配器分配 task_struct 结构, 这样能达到对象复用和缓存着色(cache coloring)的目的.

2.6 内核以前, 各个进程的 task_struct 存放在他们内核栈的尾端. 目的是为了让一些寄存器较少的硬件体系结构(比如x86)只要通过栈指针就能计算它的位置, 而避免使用额外的寄存器专门记录.

由于现在使用 slab 分配器动态生成 task_struct, 所以只需要在栈底(向下增长的栈)或栈顶(向上增长的栈)创建一个新的结构 struct thread_info, 其中的 task 指向该任务实际 task_struct 的指针.

```cpp
struct thread_info {
	struct task_struct 	*task;
	struct exec_domain	*exec_domain;
	__u32			flags;
	__u32			status;
	__u32			cpu;
	int			preempt_count;
	mm_segment_t		addr_limit;
	struct restart_block	restart_block;
	void			*sysenter_return;
	int			uaccess_err;
}
```

![2021-06-30-20-26-07.png](./images/2021-06-30-20-26-07.png)

## 2.2. 进程描述符的存放

内核通过一个唯一的进程标识符(process identification value)或PID标识. PID 是一个数, 表示为 pid_t 隐含类型, 实际上就是一个 int 类型. 最大值默认为 32768 (short int的最大值), 表示系统中允许同时存在的进程的最大数目, 可以修改 `/proc/sys/kernel/pid_max`.

> 隐含类型是指数据类型的物理表示是未知的或不相关的.

多数代码直接操作 task_struct 的. 通过 current 宏找到当前运行中的进程, 要求速度要很快. 有些硬件体系结构有一个专门寄存器存放当前 task_struct 的指针, 用于加速; x86寄存器比较少, 只能在内核栈的尾端创建 thread_info, 计算偏移间接查找.

x86 上, current 将栈指针的后 13 个有效位屏蔽掉, 用来计算出 thread_info 的偏移. 通过 current_thread_info() 来实现. 汇编如下:

```
movl $-8192, %eax
andl %esp, %eax
```

这里假定栈大小是 8KB.

`current_thread_info()->task`

而 PowerPC 上使用了单独的寄存器.

## 2.3. 进程状态和生命周期

task_struct 中的 state 表示进程的当前状态. 必然处于五种状态之一.

* TASK_RUNNING(运行). 进程是可执行的: 要么正在执行, 或者在运行队列中等待执行. 进程在用户空间中唯一可能的状态.

* TASK_INTERRUPTIBLE(可中断). 进程正在睡眠(即它被阻塞), 等待某些条件的达成. 一旦条件达成, 内核会将进程状态设置为运行; 也会因为接收到信号而提前被唤醒.

* TASK_UNINTERRUPTIBLE(不可中断). 对信号不响应. 这就是 ps 的 D 状态而又不能被杀死的原因.

* __TASK_TRACED. 被其他进程跟踪的进程, 例如通过 ptrace 对调试程序进行跟踪.

* __TASK_STOPPED(停止). 进程停止运行. 进程没有投入运行也不能投入运行. 通常在接收到 SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOU 等信号时候. 此外, 调试期间接收到任何信号, 也会进入该状态.

各状态之间的转化构成了进程的整个生命周期:

![2021-06-30-21-09-14.png](./images/2021-06-30-21-09-14.png)

## 2.4. 进程上下文

一个程序在用户空间运行, 执行系统调用或触发了某个异常, 陷入内核空间. 此时, 称内核 "代表进程执行" 并处于进程上下文中.

除非被调度了, 否则退出内核时候, 程序恢复在用户空间继续执行.

## 2.5. 进程家族树

Linux 中所有进程都是 PID 为 1 的 init 进程的后代. 内核在系统启动的最后阶段启动 init 进程. 该进程会读取系统初始化脚本(init script)并执行其他的相关程序, 最终完成系统启动的整个过程.

系统中每个进程必有一个父进程, 即 parent 指针指向; 每个进程可以拥有多个子进程, 即 children 子进程链表.

init 进程的 task_struct 是通过 init_task 静态分配的. 

这种继承体系, 可以从系统的任何一个进程出发查找到任意指定的其他进程.

任务队列是一个双向循环链表. 可以通过链表方式来获取链表上的下一个进程.

# 3. 进程创建

