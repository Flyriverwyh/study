
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 学习方法](#1-学习方法)
- [2. 基础知识](#2-基础知识)
- [3. 相关知识](#3-相关知识)
- [4. 操作系统实践](#4-操作系统实践)
- [5. Linux 内核学习](#5-linux-内核学习)
  - [5.1. 开发环境](#51-开发环境)
  - [5.2. Linux 内核设计理论](#52-linux-内核设计理论)
  - [5.3. Linux 内核源码](#53-linux-内核源码)
- [6. 自制OS](#6-自制os)
  - [6.1. 真实](#61-真实)
- [7. 内核书籍](#7-内核书籍)
- [8. 内核文档](#8-内核文档)
- [9. 代码阅读](#9-代码阅读)
- [10. feature学习](#10-feature学习)
  - [10.1. 初始实现](#101-初始实现)
    - [10.1.1. 最初合入的patch/patchset](#1011-最初合入的patchpatchset)
    - [10.1.2. 了解初始背景](#1012-了解初始背景)
      - [10.1.2.1. pwclient 工具](#10121-pwclient-工具)
      - [10.1.2.2. 利用 mail list archive](#10122-利用-mail-list-archive)
    - [10.1.3. 研究初始的代码实现](#1013-研究初始的代码实现)
  - [10.2. 最新版代码](#102-最新版代码)
  - [10.3. 中间版本](#103-中间版本)
- [11. 特性回合](#11-特性回合)

<!-- /code_chunk_output -->

# 1. 学习方法

学好一门计算机的专业课，无外乎两个部分。**掌握知识**、**学会实践**.

不要找博客！！！, 通过比较有名的课程和书籍进行系统性学习

* 课程: 主要看国外知名大学的
* 书籍: 最好看外文书, 也可以是翻译的, 对照看

[超过 200 本经典的计算机书籍分享](https://github.com/imarvinle/awesome-cs-books)

操作系统学习资料荟萃: https://zhuanlan.kanxue.com/article-8722.htm

怎样深入学习操作系统？https://www.zhihu.com/question/27567302

# 2. 基础知识

先看一本关于操作系统理论的书, 建议看国外的教材书, 同时配合学校的课程一起看, 一定要完成后面的 homework.

1. csapp(Computer System A Programmer's Perspective), 整个计算机系统. 大杂烩，lab出名，算法比较旧，建议配合CMU的ICS课程.
2. ostep(Operating system: three easy pieces), 操作系统. 有一定的实际算法设计. 阅读体验比较好，讨论问题由浅入深
3. Operating System internals and design principles, 《操作系统：精髓与设计原理》, 操作系统
4. Modern Operating Systems, 现代操作系统

1 必看, 2 和 3 选其一即可, 推荐2, 4 不是很推荐.

清华大学 操作系统 练习题:

https://xuyongjiande.gitbooks.io/os_exercises/content/all/1-intro.html

# 3. 相关知识

对于基础知识学习会有帮助的一些书

王爽 汇编语言(教会16位nasm汇编)

《x86汇编语言：从实模式到保护模式》, 了解保护模式, 动手照着书上写代码

《x86/x64体系探索及编程》

# 4. 操作系统实践

操作系统课程实践, 带你完成一个 mini os.

1. MIT 的 6.S081 和 6.828, 基于xv6系统, lab完形填空微内核，算法新

2. Berkeley 的操作系统课程

3. UIUC 的操作系统课程

4. HIT 的操作系统课程, 魔改了 linux 0.11

5. Tsinghua 的操作系统课程

看 1 就行了, 国内的还是尽量别看

通过自己动手实现 thread、spinlock、semaphore 等等东西，会让你理解更加深刻

# 5. Linux 内核学习

## 5.1. 开发环境

安装一个开发环境用于调试源码，推荐用docker建立一个本地镜像，你在本地的所有操作都会同步到容器中，这样你可以一边在本地用ide操作源码，一边在docker环境中进行编译、执行。

你肯定会需要debug，因此可以了解一下gdb，至少基本操作要会。

一切准备就绪，就可以开始鼓捣Linux了，你可以像xv6的文档中的引导顺序一样去弄明白Linux是怎么玩的，也可以找到Linux的文档或书籍。

推荐为Linux的内核增加一些自己的东西，比如最简单的，添加一个system call，然后成功调用它、改一改它的timer interruption等等

看下 Linux 内核是怎么实现的，最好的方式是看书，书的脉络理得很清晰。

## 5.2. Linux 内核设计理论

《深入理解Linux内核》, 内核设计理念

> 可以直接看下面的

## 5.3. Linux 内核源码

看内核源码也要配好书

1. 《Linux内核设计与实现》

> 比较薄, 有一个全局观, 既讲清楚了内核实现的要点，又不会通篇源码.

重点关注「第 3 章进程管理」、「第 5 章系统调用」、「第12章内存管理」、「第13章虚拟文件系统」、「第 15 章进程地址空间」

这些章节属于操作系统核心部分，其它如中断处理、块 IO、设备管理根据你自己兴趣选择看下就可以了

同理 《Linux内核源代码情景分析》也是这样的

2. 《Professional Linux Kernel Architecture》, 《深入Linux内核架构》

详细的源码以及设计理念

# 6. 自制OS

另外，如果你还想自己写一个（模仿） mini os，那么你需要一些前置依赖知识，否则估计会被很多硬件、汇编知识劝退：

* 筑基内功 -- 需要学习计算机原理、C语言（需要熟练运用）、数据结构课程
* 工欲善其事，必先利其器，掌握以下Linux 下常用命令行： 

>pwd、cd、find等，1-2 款趁手的编辑器，推荐掌握 vim 的基本操作  gcc、gdb、ld、make等编译构建链、objdump、nm、readif、dd 等 ELF 文件分析、烧录工具。

推荐《操作系统真象还原》, 所有需要前置依赖的部分他都会简单的写个教程，照着这本书就能撸一个属于自己的 os.

## 6.1. 真实

看《深入理解Linux内核》与《x86/x64体系探索及编程》，对照着《深入理解Linux内核》上讲的Linux内核的各种系统（eg. 虚拟文件系统、slub内存分配系统、伙伴系统），再看看Linux内核的源码，再与自己的思维融合一下下，就可以开始动手写一个自己的操作系统了。

我就是按照以上四个步骤写了一个操作系统 [GitHub - Zhang626/fuckOS](https://github.com/comiser/fuckOS)

在这期间需要查阅非常非常多的资料，大部分资料都列在MIT 6.828 的实验上了。

推荐一个外国的关于开发操作系统的论坛，上面有很多牛人 [OSDev.org](https://forum.osdev.org/) 与 [Expanded Main Page](https://wiki.osdev.org/Main_Page)











# 7. 内核书籍

先看书理清理论再实践

# 8. 内核文档

学习内核文档, `Documentation/`下, 一般包含背景介绍、实现原理和实践案例. 所以一定要先看下相应的 Doc.

# 9. 代码阅读

注: 所有git可以用tig

1. 手册为核心

以手册为核心阅读代码, 最起码两遍

看手册的描述, 然后找代码的对应实现, 可以对比多个实现, 比如 vmx 相关实现, 可以对比看 kvm、xen 和 ACRN(https://github.com/projectacrn/acrn-hypervisor)

手册中涉及的指令, 一般在系统指令部分会专门描述该指令行为的伪代码.

2. 代码为核心

git log 某个文件，按时间线从头看git commit

```
git log arch/x86/kvm/lapic.c

tig arch/x86/kvm/lapic.c
```

代码为主，google搜索patch的讨论

# 10. feature学习

每个feature整理一个PPT，分享讲出来.

feature从最开始的实现代码(一般从定义的新的变量查看相应commit)看起来, 能了解整个思想

核心思想: 以不变找万变

## 10.1. 初始实现

### 10.1.1. 最初合入的patch/patchset

* 第一步: 获取特性相关的最初合入的patch/patchset. 

一般从变量/模块参数入手(变量不会改, 往往能查到最初的patch)

通过`tig blame $file_name`查看结构体成员或者模块参数的 commit, 就能确定**最初的patch set**的某一个**commit**.

### 10.1.2. 了解初始背景

* 第二步: 确定最初author提交给社区的**真正第一版patchset/RFC**, 甚至第一次有人提出的疑问(从而引发的patchset).

因为这里面往往体现了author提出这个patch set的**最初的原因**且实现比较简单.

有两种手段

#### 10.1.2.1. pwclient 工具

> pwclient 工具, 这个往往不靠谱

使用 pwclient 工具, 确定最初合入的patch set, 具体参照`Study repo: Linux/Community/3. 从邮件列表获取patch.md`

#### 10.1.2.2. 利用 mail list archive

> 通过mail list archive查找

通过第一步找到的commit的subject, 在 mail list archive 中找到最初的patchset/RFC并了解当时的讨论

mail list archive, 官方的是
* https://patchwork.kernel.org/, 功能完善
* https://lore.kernel.org/lists.html, 

> 具体参见`Study repo: Linux/Community/1. 邮件列表.md`, 那里面有个示例参考

### 10.1.3. 研究初始的代码实现

直接reset回当时版本, 查看系统中的调用情况等等, 从而进行代码分析

## 10.2. 最新版代码

然后看一下最新的代码的实现, 如果核心思想没有变, 这样子就结束了. 如果有方案有更新, 那同样参照上面的方法追踪下新的方案的初始版本, 再看最新代码的实现. 

## 10.3. 中间版本

`tig mm/memcontrol.c`, tig查看某个文件, 从最开始的commit记录开始看, 因为一般文件名不会变化.

注: 但是内核代码往往涉及的commit太多, 所以可能会比较多

# 11. 特性回合

先对比下upstream的feature流程和产品的feature流程, 心里大概清楚差异点.

方法一(推荐):

盯着某个feature的核心实现文件

`tig arch/x86/kvm/lapic.c`

从最开始的commit逐个backport

然后提交时候, 回合一个patch便提交一个, 不要嫌麻烦最后整个作为一个patch.

方法二:

以最初的那个feature的patch set为核心逐个backport, 先把patch set中每个patch给backport了, 然后再逐行核对目前upstream的代码, 决定是否要backport修改(一般bug肯定要backport).

如果有feature依赖, 先backport被依赖的feature.










