在配置内核之后，就必须**编译源代码**，来生成**内核映像**和**模块二进制文件**。内核使用`GNU Make`来完成该工作。

它采用了一个复杂的**Makefile系统**，来满足**联编内核**的特殊要求，联编普通应用程序通常没有这些需求。要完全理解该机制的工作原理，就需要对make技巧的深入理解，本附录不打算深入细节，只是从最终用户和内核程序员的角度(不是Kbuild开发者的角度)，来简单讲述一下联编系统的使用。`Documentation/kbuild/makefiles.txt`中包含了联编系统的详细文档，本节就是基于该文档。

# 使用Kbuild系统

`联编目标help`在内核版本2.5开发期间被引入，用于向用户显示所有可用的make目标。它输出一个**目标列表**，会区分体系结构相关和无关的目标。

例如，在UltraSparc系统上，会显示如下列表:

```
wolfgang@ultrameitner> make help
Cleaning targets:
  clean             - Remove most generated files but keep the config and
                      enough build support to build external modules
  mrproper          - Remove all generated files + config + various backup files
  distclean         - mrproper + remove editor backup and patch files

Configuration targets:
  config            - Update current config utilising a line-oriented program
  menuconfig        - Update current config utilising a menu based program
  xconfig           - Update current config utilising a QT based front-end
  gconfig           - Update current config utilising a GTK based front-end
  oldconfig         - Update current config utilising a provided .config as base
  silentoldconfig   - Same as oldconfig, but quietly
  randconfig        - New config with random answer to all options
  defconfig         - New config with default answer to all options
  allmodconfig      - New config selecting modules when possible
  allyesconfig      - New config where all options are accepted with yes
  allnoconfig       - New config where all options are answered with no

Other generic targets:
  all               - Build all targets marked with [*]
* vmlinux           - Build the bare kernel
* modules           - Build all modules
  modules_install   - Install all modules to INSTALL_MOD_PATH (default: /)
  dir/              - Build all files in dir and below
  dir/file.[ois]    - Build specified target only
  dir/file.ko       - Build module including final link
  rpm               - Build a kernel as an RPM package
  tags/TAGS         - Generate tags file for editors
  cscope            - Generate cscope index
  kernelrelease     - Output the release version string
  kernelversion     - Output the version stored in Makefile
  headers_install   - Install sanitised kernel headers to INSTALL_HDR_PATH
                      (default: /home/wolfgang/linux-2.6.24/usr)
Static analysers
  checkstack        - Generate a list of stack hogs
  namespacecheck    - Name space analysis on compiled kernel
  export_report     - List the usages of all exported symbols
  headers_check     - Sanity check on exported headers

Kernel packaging:
  rpm-pkg           - Build the kernel as an RPM package
  binrpm-pkg        - Build an rpm package containing the compiled kernel
                      and modules
  deb-pkg           - Build the kernel as an deb package
  tar-pkg           - Build the kernel as an uncompressed tarball
  targz-pkg         - Build the kernel as a gzip compressed tarball
  tarbz2-pkg        - Build the kernel as a bzip2 compressed tarball

Documentation targets:
Linux kernel internal documentation in different formats:
  htmldocs          - HTML
  installmandocs    - install man pages generated by mandocs
  mandocs           - man pages
  pdfdocs           - PDF
  psdocs            - Postscript
  xmldocs           - XML DocBook

Architecture specific targets (sparc64):
* vmlinux           - Standard sparc64 kernel
  vmlinux.aout      - a.out kernel for sparc64
  tftpboot.img      - Image prepared for tftp

  make V=0|1 [targets] 0 => quiet build (default), 1 => verbose build
  make V=2 [targets] 2 => give reason for rebuild of target
  make O=dir [targets] Locate all output files in "dir", including .config
  make C=1 [targets] Check all c source with $CHECK (sparse by default)
  make C=2 [targets] Force check of all c source with $CHECK

Execute "make" or "make all" to build all targets marked with [*]
For further info see the ./README file
```

`IA-32`和`AMD64`系统所提供的体系结构**相关目标是不同的**。

```
wolfgang@meitner> make help
Architecture specific targets (x86):
* bzImage       - Compressed kernel image (arch/x86/boot/bzImage)
  install       - Install kernel using
                    (your) ~/bin/installkernel or
                    (distribution) /sbin/installkernel or
                    install to $(INSTALL_PATH) and run lilo
  bzdisk        - Create a boot floppy in /dev/fd0
  fdimage       - Create a boot floppy image
  isoimage      - Create a boot CD-ROM image
  i386_defconfig        - Build for i386
  x86_64_defconfig      - Build for x86_64
```

如帮助文本所解释的，如果调用make时没有参数，就将编译所有用\*标记的目标。

# Makefile的结构

除了`.config`文件，**Kbuild机制**还使用了下列组件。

- **主Makefile**(`/path/to/src/Makefile`)，通过根据配置**递归地编译子目录**，并将编译结果合并到最终产品中，来生成**内核本身**和**模块**。
- **体系结构相关的Makefile**，在`arch/arch/Makefile`中，负责在编译期间必须遵守的**与处理器相关**的微妙之处，如特别的编译优化选项。该文件还实现了所有**体系结构相关的make目标**，此前在讨论help时提到过这些目标。
- `scripts/Makefile.*`包含了与**一般编译、模块生成、各种实用程序的编译、从内核树删除目标文件和临时文件等任务相关的make规则**。
- 内核源代码的**各个子目录**都包含了与特定驱动程序或子系统相关的**Makefile**(也采用了标准的语法)。

## 主Makefile

主Makefile是**内核编译的关键**。它定义了**C编译器**、**链接器**的**调用路径**等信息。

必须区分下列两种备选的工具链。

- 用于生成在编译内核的主机上执行的**本地程序的工具链**。此类程序的例子如`menuconfig`的二进制文件或用于分析模块符号的工具。
- 用于**生成内核本身的工具链**。

这**两个工具链通常是相同**的。仅当**交叉编译内核**时，才有区别。换言之，在使用**某种特定体系结构的机器**来编译**另一种不同体系结构的内核**时。如果目标计算机是资源较少的嵌入式系统(例如，基于ARM或MIPS的手持设备)或非常陈旧而速度缓慢的计算机(经典的Sparc或者m68 Mac)，那么会使用这种方法。在这种情况下，**负责生成内核的工具链**必须提供**交叉编译器**(和适当的交叉二进制文件工具)，以便生成所需的代码。

本地工具链定义如下:

```
wolfgang@meitner> cat Makefile
...
HOSTCC             = gcc
HOSTCXX         = g++
HOSTCFLAGS         = -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
HOSTCXXFLAGS     = -O2
...
```

**内核工具链**定义如下:

```
wolfgang@meitner> cat Makefile
...
CROSS_COMPILE=

AS              = $(CROSS_COMPILE)as
LD              = $(CROSS_COMPILE)ld
CC              = $(CROSS_COMPILE)gcc
CPP             = $(CC) -E
AR              = $(CROSS_COMPILE)ar
NM              = $(CROSS_COMPILE)nm
STRIP           = $(CROSS_COMPILE)strip
OBJCOPY         = $(CROSS_COMPILE)objcopy
OBJDUMP         = $(CROSS_COMPILE)objdump
AWK             = awk
GENKSYMS        = scripts/genksyms/genksyms
DEPMOD          = /sbin/depmod
KALLSYMS        = scripts/kallsyms
PERL            = perl
CHECK           = sparse

CHECKFLAGS      := -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise $(CF)
MODFLAGS        = -DMODULE
CFLAGS_MODULE   = $(MODFLAGS)
AFLAGS_MODULE   = $(MODFLAGS)
LDFLAGS_MODULE  = -r
CFLAGS_KERNEL   =
AFLAGS_KERNEL   =
...
```

定义之前的`CROSS_COMPILE`前缀通常为空白。如果在为**不同体系结构编译内核**，那么必须为其指定一个适当的值(例如，ia64-linux-)。 因而，对**宿主机**和**目标**会使用**两个不同的工具链**。

注: 这可以在Makefile中**显式设置**，或通过**环境中的shell变量指定**，或作为**参数传递给make**。

所有**其他Makefile**都决**不会直接使用工具的名称**，而总是使用这里定义的**变量**。

**主Makefile**声明了**ARCH变量**，表示编译的内核所针对的体系结构。它包含了一个自动检测的值，需要与`arch/`下的**某个目录名兼容**。例如，对`IA-32`，ARCH设置为i386，因为对应的体系结构相关文 件存在于arch/i386/中。

如果是在交叉编译内核，就必须据此修改ARCH。例如，为ARM系统配置和编译内核时，需要下 列调用(假定已经有适当的工具链可用):

```
make ARCH=arm menuconfig
make ARCH=arm CROSS_COMPILE=arm-linux-
```

除了这些定义之外，Makefile还包括了其他一些语句，用于递归下降到各个子目录，并借助子目 录局部的Makefile来编译其中包含的文件。本附录不会详细讨论该机制，因为它涉及make机制的很多微妙之处。

# 驱动程序和子系统Makefile

