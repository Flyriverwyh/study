不仅要阅读**静态的源代码**，还需要在**内核运行时**密切观察，以跟踪其内部的动态过程。

对**普通的C语言程序**，程序员很清楚如何做到这一点。使用**编译器生成的调试信息**和**一个外部调试器**，就可以**逐行单步跟踪程序的执行**(或者，如果需要，可以**逐行汇编跟踪**)，来查看和修改数据结构，并在任一点暂停程序的控制流。

这只能借助于内核通过ptrace系统调用(在第13章讲过)提供的一些特别的特性来完成。

与**普通的C程序不同**，内核本身**没有**由**外部实例**提供的**运行环境**，内核本身负责**提供用户空间程序所需的这个运行环境**。因而，不可能用经典方式来调试内核本身。

# GDB和DDD

GDB代表`GNU debugger`，它是**默认的Linux调试器**。**每个Linux发行版**都带有**直接可用的GDB二进制文件**，可以用适当的软件包管理系统。当然，读者完全可以自行从www.gnu.org网站(或其他镜像) 取得源代码进行编译，但本附录就不讨论这些了。

该调试器提供了非常广泛的选项，本附录只简要概述其用法。GDB的详细讲述，可以参见其附带的用法指南(makeinfo格式)，也可以用info gdb查看。

为**调试一个程序**(在这方面，**内核也不例外**)，**编译器**必须将**特别的调试信息**集成到**二进制文件**中，以便调试器获取二进制文件和源代码之间关系的所有必要信息。

在**gcc编译**时必须选中`-g`选项， 如下所示:

```
gcc -g test.c -o test
```

因为包含了**调试符号**，导致生成的可执行文件长度增长颇多。

在**内核编译**期间也必须启用`-g`。在**早期版本**中，该选项必须以`CFLAGS_KERNEL`的名目进入到主 Makefile。但在内核版本2.5开发期间，**内核配置**进入了一个**独立的选项**，`Kernel hacking->Compile
the kernel with debug info`，用于设置该选项。同一菜单中，还包括了`Compile the kernel with frame pointers`选项，也应该被选中，因为它用于**限制活动记录或栈帧**(参见附录C)，能够向调试器提供有用信息。

GDB能够完成下列工作。

- **逐行**跟踪程序执行，可以按**源代码逐行**执行或按**汇编语句逐行**执行。
- 确定程序中使用的**所有符号类型**。
- 显示或操作**符号的当前值**。
- **反引用**程序中的**指针**或访问随机的**存储单元**，以**读取**或**修改**其值。
- 设置断点，使得程序在执行到源代码中给定位置时暂停，同时启用调试器。
- 设置条件断点，在给定条件满足时暂停程序执行。例如，当某个变量的值设置为预定义值时。 

具体可用的内核调试选项，取决于所使用的方法。 用于执行这些操作的命令语法都易学易记，因为都是基于C语言的。这在GDB文档中解释得很
好。