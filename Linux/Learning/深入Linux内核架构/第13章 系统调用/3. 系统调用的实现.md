
在系统调用的实现中，不仅需要讨论提供所需函数的**内核源代码**，还需要阐述**调用这些函数的方式**。这些函数的调用方式**与普通的C函数不同**，因为需要**跨越用户态和核心态的边界**。这引发了各种问题，这些问题需要由平台相关的汇编语言代码处理。该代码尽可能快速地建立了一个独立于处理器的状态，使得系统调用的实现能够独立于底层体系结构。参数如何在用户空间和内核空间之间传递的 问题也必须考虑。

# 系统调用的结构

用于实现系统调用的**内核代码**划分为**两个颇为不同的部分**。

**系统调用**执行的**实际任务**实现为一个**C例程**，与其余内核代码几乎没有差别。

用于**调用该例程的机制**则充满了**平台相关**的特性，必须考虑大量细节，因而最终实现使用**汇编语言**代码是必然的。

## 处理程序函数的实现

我们首先仔细观察一下，在实际处理程序函数的C语言实现之后有哪些东西。这些函数散布在内核中各处，因为这些函数都嵌入到了与其目的关系最密切的代码中。例如，所有文件相关的系统调用 都在fs/内核子目录下，因为它们与虚拟文件系统直接交互。同样地，所有的内存管理调用都在mm/子目录的文件中。

用于**实现系统调用**的**处理程序函数**，在形式上有如下几个共同的特性。

- 每个函数的**名称前缀**都是`sys_`，将该函数唯一地标识为**一个系统调用**，更精确地说，标识为一个**系统调用**的**处理程序函数**。通常，**不必区分**系统调用和处理程序函数。在以下各节中，仅当有必要之处才进行区分。
- 所有的处理程序函数都**最多接受5个参数**。这些参数在参数列表中指定，与普通的C函数相同(提供参数值的方式与传统方法稍有不同，读者稍后会看到)。
- 所有的系统调用都在核心态执行。因而，第2章讨论的限制是适用的，主要是不允许直接访问用户态的内存。回想`copy_from_user`、`copy_to_user`或其他同类函数，都必须确保在进行实际读写操作之前目标内存区对内核必须是可用的。 

在内核将控制权转移给处理程序例程后，控制流就进入了平台中立的代码，即不依赖于特定的CPU或体系结构。但因为各种原因，也有一些例外。有少量处理程序函数是针对各个平台分别实现的。 在返回结果时，处理程序函数无须进行特别的操作，简单的一个return后接返回值即可。在核心态和 用户态之间的切换，由特定于平台的内核代码执行，这与中断处理程序是无关的。图13-1说明了相关 的时间顺序。
 