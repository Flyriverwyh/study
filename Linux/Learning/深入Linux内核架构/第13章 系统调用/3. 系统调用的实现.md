
在系统调用的实现中，不仅需要讨论提供所需函数的**内核源代码**，还需要阐述**调用这些函数的方式**。这些函数的调用方式**与普通的C函数不同**，因为需要**跨越用户态和核心态的边界**。这引发了各种问题，这些问题需要由平台相关的汇编语言代码处理。该代码尽可能快速地建立了一个独立于处理器的状态，使得系统调用的实现能够独立于底层体系结构。参数如何在用户空间和内核空间之间传递的 问题也必须考虑。

# 系统调用的结构

用于实现系统调用的**内核代码**划分为**两个颇为不同的部分**。

- **系统调用**执行的**实际任务**实现为一个**C例程**，与其余内核代码几乎没有差别。

- 用于**调用该例程的机制**则充满了**平台相关**的特性，必须考虑大量细节，因而最终实现使用**汇编语言**代码是必然的。

## 处理程序函数的实现

我们首先仔细观察一下，在实际处理程序函数的C语言实现之后有哪些东西。这些函数散布在内核中各处，因为这些函数都嵌入到了与其目的关系最密切的代码中。例如，所有文件相关的系统调用 都在fs/内核子目录下，因为它们与虚拟文件系统直接交互。同样地，所有的内存管理调用都在mm/子目录的文件中。

用于**实现系统调用**的**处理程序函数**，在形式上有如下几个共同的特性。

- 每个函数的**名称前缀**都是`sys_`，将该函数唯一地标识为**一个系统调用**，更精确地说，标识为一个**系统调用**的**处理程序函数**。通常，**不必区分**系统调用和处理程序函数。在以下各节中，仅当有必要之处才进行区分。
- 所有的处理程序函数都**最多接受5个参数**。这些参数在参数列表中指定，与普通的C函数相同(提供参数值的方式与传统方法稍有不同，读者稍后会看到)。
- **所有的系统调用**都在**核心态**执行。因而，第2章讨论的限制是适用的，主要是**不允许直接访问用户态的内存**。回想`copy_from_user`、`copy_to_user`或其他同类函数，都必须确保在进行实际读写操作之前**目标内存区**对**内核**必须是**可用**的。

在**内核**将**控制权**转移给**处理程序例程**后，控制流就进入了**平台中立的代码**，即**不依赖**于**特定的CPU或体系结构**。但因为各种原因，也有一些例外。有少量处理程序函数是针对各个平台分别实现的。 在返回结果时，**处理程序函数**无须进行特别的操作，简单的一个**return后接返回值**即可。在**核心态**和**用户态**之间的**切换**，由**特定于平台的内核代码**执行，这与中断处理程序是无关的。

图13-1说明了相关的时间顺序。

![2020-01-27-21-31-22.png](./images/2020-01-27-21-31-22.png)

上述方法极大简化了程序员的工作，因为**处理程序函数的实现**实际上与普通内核代码的实现是相同的。有些系统调用非常简单，只用一行C语言代码实现。例如，**返回当前进程UID**的getuid系统调 用实现如下:

```cpp
// kernel/timer.c
asmlinkage long sys_getuid(void) 
{ 
        /* 我们只改变这个，使之变为SMP安全的 */ 
        return current->uid; 
}
```

current是一个指针，指向当前进程的`task_struct`实例，由内核自动设置。上述代码返回`task_struct`的**uid成员**(当前用户ID)。

还有复杂得多的系统调用，其中一些已经在前面几章讨论过。处理程序函数的实现总是简短而紧凑的。它通常会尽快将控制权传递给一个更通用的内核辅助函数，以read为例。

第三种“类型”系统调用充当**多路分解器**。多路分解器使用**常数**，将**系统调用**委派给执行**不同任务的函数**。一个典型的例子是socketcall(在第12章讨论)，其中聚集了所有网络相关的调用。

# 调用分派和参数传递

系统调用由内核分配的一个编号唯一标识。这样做有其实际原因，在考虑触发系统调用的过程时， 该原因会逐渐明朗化。所有的系统调用都由一处中枢代码处理，根据调用编号和一个静态表，将调用 分派到具体的函数。传递的参数也由中枢代码处理，这样参数的传递独立于实际的系统调用。

...

## 参数传递

不同的平台使用不同的汇编语言方法来执行系统调用。

注: 细节很容易在GNU标准库的源代码中找到，可参考`sysdeps/unix/sysv/linux/arch/syscall.S`文件。**特定平台**所需的**汇编语言**代码可以在syscall标号下找到，这些代码为库其余部分提供了一个**通用接口**，可用于调用系统调用。

在**所有平台**上，系统调用**参数**都是通过**寄存器**直接传递的，对具体的**处理程序函数**而言，**参数**与**寄存器**之间的**映射是精确定义**的。还需要**一个寄存器**来定义系统调用**编号**，将系统调用分派给匹配的处理程序函数。

下面概述了一些流行的体系结构上进行系统调用的方法。

### IA-32系统

在**IA\-32**系统上，使用汇编语言指令`int $0x80`来引发软件中断128。这是一个**调用门(call gate**)，为此指派了**一个特定的函数**来继续进行系统调用的处理。系统**调用编号**通过**寄存器eax**传递， 而**参数**通过寄存器**ebx**、**ecx**、**edx**、**esi**和**edi**传递。

注: 除了0x80调用门，内核在`IA-32`处理器上的实现提供了**其他两种**进入核心态执行系统调用的方法，分别是`lcall7` 和`lcall27`调用门。这些用于执行对**BSD**和**Solaris**的**二进制仿真**，因为这些系统分别以本机方式进行系统调用。

在`IA-32`系列中，更为现代的处理器(Pentium II和后续处理器)采用了**两个汇编语言指令**(**sysenter**和**sysexit**)来快速进入和退出核心态。其中仍然采用**同样的方法传递参数**，但在特权级别之间切换的**速度更快**。 

为使sysenter调用更快，而又不失去与旧处理器的**向下兼容性**，内核将**一个内存页面**映射到**地址空间的顶端**(`0xffffe000`)。根据处理机类型的不同，该页上的系统调用代码可能包含 `int 0x80`或者`sysenter`。 

**调用**存储在该地址(`0xffffe000`)的代码使得**标准库**可以**自动选择**与使用的处理器相匹配的方法。

### Alpha处理器

### PowerPC

### AMD64

AMD64体系结构在实现系统调用时，也提供了自身的汇编语言指令，其名称为**syscall**。系统调用**编号**保存在**rax寄存器**中，而**参数**保存在**rdi**、**rsi**、**rdx**、**r10**、**r8**和**r9**中。

### 内核任务

在应用程序借助于标准库切换到**核心态**后，内核面临的任务是查找与该系统调用匹配的处理程序函数，并向该处理函数提供传递的参数。

`sys_call_table`表中保存了一组指向处理程序例程的函数指针，可用于查找处理程序(在**所有平台**上)。因为该表是用**汇编语言指令**在内核的**数据段中产生**的，其内容**因平台而不同**。但原理总是同样的: 内核根据**系统调用编号**找到表中**适当的位置**，由此获得指向**目标处理程序函数的指针**。

## 系统调用表

### Sparch64

Sparc64系统上的sys_call_table，定义在arch/sparc/kernel/systlbs.S中(其他系统的系统调用表，通常可以在与处理器类型对应的目录下的entry.S文件中找到)。

### IA-32

```assembly
" arch/x86/kernel/syscall_table_32.S
ENTRY(sys_call_table)
        .long    sys_restart_syscall /* 0 - old "setup()" system call, used for restarting */
        .long    sys_exit
        .long    sys_fork
        .long sys_read
        .long sys_write
        .long sys_open /* 5 */
        .long sys_close
...
        .long sys_utimensat /* 320 */
        .long sys_signalfd
        .long sys_timerfd
        .long sys_eventfd
        .long sys_fallocate
```

`.long`语句的作用是在**内存中对齐各个表项**。 

用这种方法定义的表，与**C数组类似**，也可以用**指针运算处理**。`sys_call_table`是**基指针**，指向**数组的起始处**，即(按C语言的术语)指向**索引为0**的**数组项**。

如果一个用户空间程序调用**open系统调用**，传递的系统调用**编号是5**。**分配器例程**将**编号5**加到`sys_call_table`的基地址，得到该数组的**第6 项**，其中保存了`sys_open`的地址，这是独立于处理器的处理程序函数。在将保存在**寄存器**中的**参数**值复制到**栈上**之后，内核调用处理程序例程，并切换到系统调用处理中独立于处理器的部分。

>因为核心态和用户态使用两个不同的栈，如第3章所述，系统调用参数不能像通常那样在栈上传递。在两个栈之间的切换，或者由进入核心态时调用的体系结构相关的汇编语言代码进行，或者在特权级别从用户态切换到核心态时由处理器自动进行。

## 返回用户态

# 访问用户空间

尽管内核尽可能保持**内核空间和用户空间的独立**，有些情况下，**内核**代码必须访问**用户应用程序**的**虚拟内存**。当然，这**只**在内核执行由用户应用程序发起的**同步操作**时才有意义，而不适用于任意进程进行的读或写访问，否则不仅不能解决问题，还会导致当前执行的代码产生危险的后果。

当然，对系统调用的处理就是此类情况的一个典型的例子，内核忙于同步执行应用程序指派的任务。因为如下两种原因，**内核必须访问应用程序的地址空间**。

- 如果一个系统调用需要**超过6个不同的参数**，它们只能借助进程内存空间中的C结构实例来传递。系统调用将借助寄存器，将**指向该结构实例**的一个**指针**传递给内核。
- 由系统调用的副效应产生的**大量数据**，不能通过**返回值机制**传递给**用户进程**。相反，必须通过**指定的内存区**交换该数据。当然，该内存区**必须在用户空间**中，使得用户应用程序能够访问。

在**内核**访问**自身的内存区！！！** 时，**虚拟地址**和**物理内存页**之间的**映射**总是**存在！！！**的。但**用户空间**中的情况有所不同，如第3章所述。这里，**页可能被换出**，甚至可能**尚未分配物理内存页**。

因而，内核**不能**简单地**反引用用户空间的指针**，而必须采用**特定的函数**，确保**目标内存区**已经在**物理内存**中。为确保内核遵守了这种约定，**用户空间指针**通过`__user`属性标记，以支持C check tools对源代码的自动化检查 。 

注: Linus Torvalds设计了该工具，用于发现内核源代码中直接反引用用户空间指针之处。

第3章讨论了用于在用户空间和内核空间之间复制数据的函数。大多数情况下，是`copy_to_user`和`copy_from_user`，但还有更多的变体可用。

# 追踪系统调用

**strace工具**用来追踪进程的系统调用，它使用了13.1.1节描述的**ptrace系统调用**。

`sys_ptrace`**处理程序例程**的实现是**体系结构相关**的，定义在`arch/arch/kernel/ptrace.c`中。 各个体系结构的对应版本之间，代码只有微小的差别。

在详细考察该系统调用的流程之前，应该注意到**ptrace**本质上是一个用于**读取和修改进程地址空间中的值的工具**，**不能！！！** 用于**直接跟踪系统调用**。只有从正确的位置提取出所需的信息，才能跟踪进程并就进行的系统调用得出结论。即使**调试器如gdb**的实现也完全**依赖于ptrace**。

ptrace不仅能用于跟踪系统调用，还提供了更多的选项。

ptrace在内核源代码中的定义需要4个参数:

```cpp
// <syscalls.h>
asmlinkage long sys_ptrace(long request, long pid, long addr, long data);
```

注: `<syscalls.h>`包含了所有**独立于体系结构**的**系统调用的原型**，这些调用的参数在所有体系结构上都是相同的。

- **pid**标识了**目标进程**。进程标识符根据调用者的命名空间来解释。尽管**strace**的处理方式暗示**必须从开始就启用进程追踪**，但这**不是真实的**。跟踪者程序必须通过**ptrace**将自身**连接到目标进程**，而且这可以在**进程已经运行后进行！！！** (不仅能在进程开始时进行)。 

**strace**负责**连接到进程**，通常是用**fork**和**exec**启动**目标程序**后立即进行。

- **addr**和**data**向内核传递一个**内存地址**和**附加信息**。其语义因选择的操作而不同。
- 借助于符号常数，**request**用于选择一个**操作**，由ptrace执行。手册页ptrace(2)、内核源代码中的`<ptrace.h>`列出了所有可能值。可用的选项如下。
    - PTRACE_ATTACH发出一个请求，连接到一个进程并开始跟踪。PTRACE_DETACH从该进程断开
并结束跟踪。当被跟踪的进程有待决信号时，进程总是会被终止。该选项使得被跟踪进程 在系统调用后或一条汇编语言指令之后暂停。 在被跟踪的进程暂停时，跟踪者程序通过SIGCHLD信号得到一个通知:在被跟踪进程暂停前， 13 跟踪者可用第2章讨论的wait函数等待。 在设置了跟踪之后，将SIGSTOP信号发送给被跟踪进程，这导致跟踪者进程第一次被中断。 在跟踪系统调用时，这是必要的，如下面的例子所示。
 PEEKTEXT、PEEKDATA和PEEKUSR从进程地址空间读取数据。PEEKUSR读取普通的CPU寄存 器和使用的任何其他调试寄存器1(当然，会根据标识符只读取一个寄存器的内容，而不是 读取整个寄存器集合的内容)。PEEKEXT和PEEKDATA从进程的代码段和数据段读取任意字。
 POKETEXT、POKEDATA和PEEKUSR向被监控进程的三个指定区域写入值，因而可以操作进程 地址空间的内容。这在交互式调试程序时是非常重要的。 因为PTRACE_POKEUSR操作CPU的调试寄存器，该选项支持对高级调试技术的使用。例如可 监控此类事件:在一定的条件满足时，在特定位置暂停程序的执行。
 PTRACE_SETREGS和PTRACE_GETREGS设置和读取CPU的特权寄存器集合的值。
 PTRACE_SETFPREGS和PTRACE_GETFPREGS设置和读取用于浮点计算的寄存器。这些操作在
测试和交互式调试应用程序时也非常有用。
 系统调用追踪是基于PTRACE_SYSCALL的。如果用该选项激活ptrace，那么内核将开始执行
进程，直至调用一个系统调用。在被追踪进程停止后，wait通知跟踪者进程，跟踪者接下 来可以使用上述的ptrace选项，来分析被跟踪进程的地址空间，以收集有关系统调用的信息。 在完成系统调用之后，被跟踪的进程第二次暂停，使得跟踪者进程可以检查调用是否成功。 因为系统调用机制因平台而不同，跟踪程序如strace必须针对每个体系结构分别实现数据 的读取;这是一个乏味的任务，很快会致使可移植程序的源代码变得不可读(strace的源 代码中有大量预处理器条件，阅读其代码非常痛苦)。
 PTRACE_SINGLESTEP将处理器在执行被追踪进程期间，置于单步执行模式。在这种模式下， 跟踪者进程在每个汇编语言指令之后，可以访问被跟踪进程。这仍然是一种非常流行的应 用程序调试技术，特别是在试图跟踪编译器错误或其他比较微秒的问题时。 单步功能的实现非常强烈地依赖于所使用的CPU，毕竟，内核此时是在一个面向机器的层 8 次上运作的。尽管如此，在所有平台上都可以向跟踪者进程提供一个一致的接口。在汇编 指令执行之后，向跟踪者发送一个SIGCHLD信号，跟踪者接下来会使用其他的ptrace选项，