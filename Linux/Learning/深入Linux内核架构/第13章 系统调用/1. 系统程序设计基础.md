大体上，**系统程序设计**主要是利用**标准库**进行工作，标准库提供了各种基本函数，用于开发应用程序。

无论编写何种应用程序，程序员都必须了解系统程序设计的基础知识。一个简单的程序，如经 典的hello.c例程，在屏幕上显示“Hello, world!”或类似的文本，也会间接使用系统例程来输出必要 的字符。

当然，系统程序设计不一定总是用C语言。

标准库不仅是实现**内核系统调用的接口集合**，其中也提供了许多其他**完全在用户空间实现**的函数。

# 追踪系统调用

下列例子展示了如何**使用标准库的包装器例程**来进行系统调用:

```c
#include<stdio.h> 
#include<fcntl.h> 
#include<unistd.h> 
#include<malloc.h> 

int main() { 
    int handle, bytes; 
    void* ptr; 

    handle = open("/tmp/test.txt", O_RDONLY); 

    ptr = (void*)malloc(150); 

    bytes = read(handle, ptr, 150); 
    printf("%s", ptr); 

    close(handle); 
    return 0; 
}
```

示例程序打开文件/tmp/test.txt，读取前150个字节，并将其写到标准输出，这是UNIX head命令的一个非常简单的版本。

这个程序使用了**多少个系统调用**呢? 

能直接看到的只有**open**、**read**和**close**(其实现在第8章讨论过)。而**printf**函数也是通过**系统调用**在**标准库中实现**的。

当然可以**阅读标准库的代码**，来看看具体**使用了哪个系统调用**，但这肯定是冗长乏味的。一个简单些的方案是使用**strace工具**，它可以记录应用程序发出的**所有系统调用**并将该信息提供给程序员，在调试程序时，这个工具是不可缺少的。

**内核**自然需要为**记录系统调用**提供**专门的支持**，这将在13.3.3节讨论\[不出所料，这项支持功能也是一个系统调用(ptrace)，我们只对其输出感兴趣]。

接下来使用strace命令将shead(上述的例子程序)发出的所有系统调用的列表写到log.txt中:

```
strace -o log.txt ./shead
```

log.txt的内容比读者的预期可能要多很多:

![2020-01-26-18-27-59.png](./images/2020-01-26-18-27-59.png)

跟踪记录显示，该应用程序进行了**大量**源代码中**没有明确列出的系统调用**。因此，strace的**输出并不容易阅读**。

为此，上文复制的文本中，但凡能够在例子程序的**C源代码中找到对应系统调用的行**，都以**斜体**显示。其他行对应的系统调用，是由编译时**自动添加**的一些代码生成的。

