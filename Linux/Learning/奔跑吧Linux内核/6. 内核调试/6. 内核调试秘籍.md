
# printk

很多内核开发者最喜欢的调试工具是printk。printk是内核提供的格式化打印函数，它和C库所提供的printf()函数类似。printk()函数和printf()函数的一个重要区别是前者提供打印等级，内核根据这个等级来判断是否在终端或者串口中打印输出。从多年的工程实践经验来看，printk是最简单有效的调试方法。

```
￼       [include/linux/kern_levels.h]￼ ￼       #define KERN_EMERG KERN_SOH "0"    /* system is unusable */￼       #define KERN_ALERT  KERN_SOH "1"    /* action must be taken immediately */￼       #define KERN_CRIT   KERN_SOH "2"    /* critical conditions */￼       #define KERN_ERR   KERN_SOH "3"    /* error conditions */￼       #define KERN_WARNING   KERN_SOH "4"      /* warning conditions */￼       #define KERN_NOTICE KERN_SOH "5"    /* normal but significant condition */￼       #define KERN_INFo   KERN_SOH "6"    /* informational */￼       #define KERN_DEBUG  KERN_SOH "7"    /* debug-level messages */
```

Linux内核为printk定义了8个打印等级，KERN_EMERG等级最高，KERN_DEBUG等级最低。在内核配置时，有一个宏来设定系统默认的打印等级\2ONFIG_MESSAGE_LOGLEVEL_DEFAULT，通常该值设置为4，那么只有打印等级高于4时才会打印到终端或者串口，即只有KERN_EMERG～KERN_ERR。通常在产品开发阶段，会把系统默认等级设置到最低，以便在开发测试阶段可以暴露更多的问题和调试信息，在产品发布时再把打印等级设置为0或者4。

￼       [arch/arm/configs/vexpress_defconfig]￼ ￼       
CONFIG_MESSAGE_LOGLEVEL_DEFAULT=8 //默认打印等级设置为0，即打开所有的打印信息
此外，还可以通过在启动内核时传递commandline给内核的方法来修改系统默认的打印等级，例如传递“loglevel=8”给内核启动参数。
￼       # qemu-system-arm -M vexpress-a9  -m 1024M -kernel arch/arm/boot/zImage￼       -append "rdinit=/linuxrc console=ttyAMA0 loglevel=8" -dtb￼       arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic
在系统运行时，也可以修改系统的打印等级。
￼       # cat /proc/sys/kernel/printk     //printk默认4个等级￼       7     4    1     7￼ ￼       # echo 8 > /proc/sys/kernel/printk  //打开所有的内核打印
上述内容分别表示控制台打印等级、默认消息打印等级、最低打印等级和默认控制台打印等级。
在实际调试中，把函数名字（__func__）和代码行号（__LINE__）打印出来也是一个很好的小技巧。
￼       printk(KERN_EMERG "figo: %s, %d", __func__, __LINE__);
读者需要注意printk打印的格式，否则在编译时会出现很多的WARNNING，如表6.1所示。
表6.1 printk打印格式
￼
内核还提供了一些在实际工程中会用到的有趣的打印。
❑ 打印内存buffer的数据函数print_hex_dump()。
❑ 打印堆栈函数dump_stack()。

# 动态打印

# RAM Console

# OOPS分析

# BUG_ON()和WARN_ON()