
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [链表的演化](#链表的演化)
- [Linux内核中链表的定义和使用](#linux内核中链表的定义和使用)
  - [链表的初始化](#链表的初始化)
  - [链表的插入](#链表的插入)

<!-- /code_chunk_output -->

# 链表的演化

在C语言中，一个基本的双向链表定义如下:

```c
struct my_list{
    void *mydata;
    struct my_list *next;
    struct my_list *prev;
};
```

![2019-09-15-21-38-02.png](./images/2019-09-15-21-38-02.png)

这个链表画出图来的话是这样的, 它有前驱(prev)和后继(next), 这两个指针可以从两个方向来遍历链表, 从而使得遍历链表的效率得以提升.

为什么要把双链表作为一个重点来介绍呢? 

* 实际上, 对一个双链表减少一个指针域, 它自然就退化为一个单链表;

* 如果只能对链表的首尾进行插入或删除操作, 它就变成队列结构;

* 如果只能对链表的头进行插入或删除操作, 它就变成栈结构;

* 如果前驱和后继表示左右孩子的话, 它就变成一棵二叉树;

所以Linux内核将循环双链表作为一个基本的类型, Linux内核源码的很多数据结构里面, 都可以看到这个结构像整型一样来使用

# Linux内核中链表的定义和使用

Linux内核对链表的实现方式与众不同，在**链表中并不包含数据**，其具体的定义如下:

```c
struct list_head{
    struct list_head *next, *prev;
};
```

这个链表结构常常被嵌入到其他结构中，比如:

```c
struct my_list{
    void *mydata;
    struct list_head list;
};
```

在这个结构中, 可以看到, list域隐藏了链表的指针特性

以`struct list_head`为基本对象，可以对链表进行**插入**、**删除**、**合并**以及**遍历**等各种操作，这些操作位于**内核的头文件list.h**中。

这里主要介绍一些链表的基本介绍

## 链表的初始化

链表的声明和初始化

如何对链表初始化呢?

`struct list_head`只定义了**链表的头节点**, 并没有专门定义链表头, 那一个链表结构是如何建立起来呢? 

内核核代码`list.h`中定义了两个宏:

```c
#define LIST_HEAD_INIT(name) { &(name), &(name) } /*仅初始化*/

#define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name) /*声明并初始化*/
```

当我们调用`LIST_HEAD()`声明一个名为name的链表头时, 它的前后指针都初始化指向自己, 这样我们就有了一个**空的链表**.

那如何判断一个链表是否为空, 通过下面这个简单的函数就可以判断一个链表是否为空

```c
static inline int list_empty(const struct list_head *head)
{
    return head->next == head;
}
```

## 链表的插入

内核中如何给链表插入一个节点呢?

在include/linux/list.h中增加结点的函数为:

```c
static inline void list_add();
static inline void list_add_tail();
```

在内核代码中，`list_add()`和`list_add_tail()`均调用`__list_add()`真
正实现**头插**和**尾插**，函数名前加**两个下划线**表示**内部函数**。

```c
static inline void list_add(struct list_head *new, struct list_head *head)
{
    __list_add(new, head, head->next);
}
```

该函数向**指定链表**的**head结点**后**插入new结点**。因为是**循环链表**，而且**通常没有首尾结点的概念**，所以可以将任何结点传给head。若传最后一个元素给head，该函数就可以实现一个栈。

```c
static inline void __list_add(struct list_head *new,
                    struct list_head *prev,
                    struct list_head *next)
{
    next->prev = new;
    new->next = next;
    new->prev = prev;
    prev->next = new;
}
```

![2019-09-15-22-25-38.png](./images/2019-09-15-22-25-38.png)

`list_add_tail`