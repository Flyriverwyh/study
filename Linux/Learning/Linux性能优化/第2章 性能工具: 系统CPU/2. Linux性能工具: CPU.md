
# vmstat（虚拟内存统计）

vmstat是指**虚拟内存统计**，这个名称表明它能告诉你系统的**虚拟内存性能信息**。

实际上远不止于此。

vmstat是一个很有用的命令，它能获取整个系统性能的粗略信息，包括：

* **正在运行**的**进程个数**。
* **CPU**的**使用情况**。
* CPU接收的**中断个数**。
* 调度器执行的**上下文切换次数**。

它是用于获取系统性能大致信息的极好工具。

## CPU性能相关的选项

vmstat可以被如下命令行调用：

```
vmstat [-n] [-s] [delay [count]]
```
￼
vmstat运行于两种模式：**采样模式**和**平均模式**。如果不指定参数，则vmstat统计运行于平均模式下，vmstat显示从系统启动以来所有统计数据的均值。但是，如果指定了延迟，那么第一个采样仍然是系统启动以来的均值，但之后vmstat按延迟秒数采样系统并显示统计数据。表2-1解释了vmstat的选项。

表2-1 vmstat命令行选项:

![2019-12-08-14-07-55.png](./images/2019-12-08-14-07-55.png)
￼
vmstat提供的各种统计输出信息，使你能跟踪系统性能的不同方面。表2-2解释了与CPU性能相关的输出。下一章说明与内存性能相关的输出。

表2-2 与CPU相关的vmstat输出:

![2019-12-08-14-09-56.png](./images/2019-12-08-14-09-56.png)
￼
vmstat提供了一个低开销的良好系统性能视图。由于所有的性能统计数据都以文本形式呈现，并打印到标准输出，因此，捕捉测试中生成的数据，以及之后对其进行处理和绘图就会很方便。由于vmstat的开销如此之低，因此当你需要一目了然地监控系统健康状况时，让它在控制台上或窗口中持续运行，甚至是在负载非常重的服务器上是很实用的。

## 用法示例

如清单2.2所示，如果vmstat运行时没有使用命令行参数，显示的将是自系统启动后它记录下的统计信息的均值。根据“CPU使用率”列下面的us、sy、wa和id，本例显示出系统从启动开始，基本上处于空闲状态。从启动开始，CPU有5%的时间用于执行用户应用程序代码，1%的时间用于执行系统代码，而其余94%的时间处于空闲状态。

清单2.2:

![2019-12-08-14-12-51.png](./images/2019-12-08-14-12-51.png)
￼
尽管vmstat从系统启动时开始统计有助于确定系统的负载情况，但是，vmstat最有用的是运行于采样模式下，如清单2.3所示。在采样模式下，vmstat间隔delay参数指定的秒数输出系统统计数据，而采样次数由count给出。清单2.3第一行的统计数据和之前一样，是系统启动以来的均值，但之后就是定期采样。本例展示出系统的活动非常少。通过查看b列下面的0，我们可以知道在运行时没有阻塞进程。通过查看r列，我们还可以看到在vmstat采样数据时，正在运行的进程数量少于1。

清单2.3:

![2019-12-08-14-13-58.png](./images/2019-12-08-14-13-58.png)
￼
vmstat是一种记录系统在一定负载或测试条件下行为的好方法。可以用vmstat显示系统的行为，同时利用Linux的tee命令将结果输出到文件。（第8章详细描述了tee命令。）如果你只传递了参数delay, vmstat就会无限采样。在测试开始前启动vmstat，测试结束后终止vmstat。输出文件的形式可以是电子表格，并能够用于查看系统对负载和各种系统事件是如何反应的。清单2.4给出了按照这个方法得到的输出。在这个例子中，我们可以查看到系统发生的中断和上下文切换。在in列和cs列能分别查看到中断和上下文切换的总数。

上下文切换的数量小于中断的数量。调度器切换进程的次数少于定时器中断触发的次数。这很可能是因为系统基本上是空闲的，在定时器中断触发的大多数时候，调度器没有任何工作要做，因此它也不需要从空闲进程切换出去。

（注意：生成如下输出的vmstat版本有错误。它会导致系统输出的平均线显示不正确的数值。该错误已经报告给了vmstat的维护者，希望能尽快修复。）

清单2.4:

![2019-12-08-14-14-19.png](./images/2019-12-08-14-14-19.png)
￼
最新版本的vmstat甚至可以抽取各种系统统计数据更详细的信息，如清单2.5所示。

下一章讨论内存统计数据，但是，现在我们来查看CPU的统计信息。第一组数据，即“CPU ticks”，显示的是自系统启动的CPU时间，这里的“tick”是一个时间单位。虽然精简的vmstat输出仅显示四个CPU状态——us、sy、id和wa，这里则显示了全部CPU ticks的分布情况。此外，我们还可以看到中断和上下文切换的总数。一个新添加的内容是forks，它大体上表示的是从系统启动开始，已经创建的新进程的数量。

清单2.5:

![2019-12-08-14-15-42.png](./images/2019-12-08-14-15-42.png)
￼
vmstat提供了关于Linux系统性能的众多信息。在调查系统问题时，它是核心工具之一。

# top（2.0.x版本）

top是Linux系统监控工具中的瑞士军刀。它善于将相当多的系统整体性能信息放在一个屏幕上。显示内容还能以交互的方式进行改变，因此，在系统运行时，如果一个特定的问题不断突显，你可以修改top显示的信息。

默认情况下，top表现为一个将占用CPU最多的进程按降序排列的列表。这使得你能够迅速找出是哪个程序独占了CPU。top根据指定的延迟定期更新这个列表（其初始值为3秒）。

## CPU性能相关的选项

top用如下命令行调用：

```
top [d delay] [C] [H] [i] [n iter] [b]
```
￼
top实际上有两种模式的选项：命令行选项和运行时选项。命令行选项决定top如何显示其信息。表2-3给出的命令行选项会影响top显示的性能统计信息的类型和频率。

表2-3 top命令行选项:

![2019-12-08-14-17-48.png](./images/2019-12-08-14-17-48.png)
￼
在你运行top时，为了调查特定问题，你可能想要对你的观察略作调整。top输出的可定制性很高。表2-4给出的选项可以在top运行期间修改显示的统计信息：

表2-4 top运行时统计信息显示选项:

![2019-12-08-14-17-57.png](./images/2019-12-08-14-17-57.png)
￼
表2-5给出的选项打开或关闭各种系统级信息的显示。关闭不需要的统计信息有助于在屏幕上显示更多进程。

表2-5 top运行时输出切换选项:

![2019-12-08-14-18-08.png](./images/2019-12-08-14-18-08.png)
￼
表2-6对top支持的不同排序模式进行了说明。按内存消耗量排序尤其有用，它能找出哪个进程消耗了最多的内存。

表2-6 top输出排序/显示选项:

![2019-12-08-14-19-38.png](./images/2019-12-08-14-19-38.png)
￼
top除了提供特定进程的信息之外，还提供系统整体信息。表2-7给出了这些统计信息。

表2-7 top性能统计信息:

![2019-12-08-14-19-54.png](./images/2019-12-08-14-19-54.png)
￼
top提供了不同的正在运行进程的大量信息，是找出资源消耗大户的极好方法。

## 用法示例

清单2.6是运行top的一个例子。当它启动后，将会周期性地更新屏幕直到退出。该例展示了top能生成的一些系统整体统计信息。首先。我们能看到1分钟、5分钟和15分钟的系统平均负载。可以看出，系统已经开始忙碌起来（因为doom-3.x86）。一个CPU在用户代码上花费了90%的时间。另一个则只在用户代码上花费了约13%的时间。最后，我们看到73个进程处于睡眠状态，只有3个进程正在运行。

清单2.6￼:

![2019-12-08-14-20-38.png](./images/2019-12-08-14-20-38.png)

现在，在top运行时按下F键弹出配置界面，如清单2.7所示。当你按下代表键（A代表PID, B代表PPID，等等）时，top将切换这些统计信息在屏幕上的显示。选择好需要的全部统计信息后，按下Enter键返回top的初始界面，现在它显示的是选出的统计信息的当前值。在配置统计信息时，所有当前选择的字段将会以大写形式显示在Current Field Order行，并在其名称旁出现一个星号（\*）。

清单2.7:

![2019-12-08-14-21-27.png](./images/2019-12-08-14-21-27.png)
￼
为了展示top的可定制性，清单2.8给出了一个高度配置的输出界面，其中只显示了与CPU使用率相关的top选项：

清单2.8:

![2019-12-08-14-22-14.png](./images/2019-12-08-14-22-14.png)
￼
top提供了一个系统资源使用率的总览，其重点信息在于各种进程是如何消耗这些资源的。由于其输出格式对用户是友好的，而对工具是不友好的，因此最好是在与系统直接交互时使用。

# top（3.x.x版本）

近来，最新版本中提供的top已经有了彻底的改变，其结果就是很多命令行和交互选项发生了变化。虽然基本思路是相似的，但对top进行了精简，并添加了几个不同的显示模式。
同样的，top呈现为一个降序列表，排在最前面的是最占用CPU的进程。

## CPU性能相关的选项

用如下命令行调用top：

```
top [-d delay] [-n iter] [-i] [-b]
```
￼
top实际有两种模式的选项：命令行选项和运行时选项。命令行选项决定top如何显示其信息。表2-8给出的命令行选项会影响top显示的性能统计信息的类型和频率。

表2-8 top命令行选项:

![2019-12-08-14-23-36.png](./images/2019-12-08-14-23-36.png)
￼
运行top时，为了调查特定问题，你可能想要对你的观察略作调整。和top 2.x版本一样，其输出的可定制性很高。表2-9给出的选项可以在top运行期间修改显示的统计信息。

表2-9 top运行时选项:

![2019-12-08-14-24-37.png](./images/2019-12-08-14-24-37.png)
￼
表2-10给出的选项打开或关闭各种系统级信息的显示。关闭不需要的统计信息有助于在屏幕上显示更多进程。

表2-10 top运行时输出切换选项:

![2019-12-08-14-24-58.png](./images/2019-12-08-14-24-58.png)
￼
与top v2.x相同，top v3.x除了提供特定进程的信息之外，还提供系统整体信息。表2-11给出了这些统计信息。

表2-11 top性能统计信息:

![2019-12-08-14-25-19.png](./images/2019-12-08-14-25-19.png)
￼
top提供了不同的正在运行进程的大量信息，是找出资源消耗大户的极好方法。top v.3版对top进行了精简，并增加了一些对相同数据的不同视图。

## 用法示例

清单2.9是运行top v3.0的一个例子。同样的，它会周期性地更新屏幕直到退出。其统计信息与top v2.x相同，但名称略有改变。

清单2.9:
￼
￼![2019-12-08-14-25-46.png](./images/2019-12-08-14-25-46.png)

![2019-12-08-14-41-47.png](./images/2019-12-08-14-41-47.png)

现在，在top运行时按下f键调出配置界面，如清单2.10所示。当你按下代表键（A代表PID, B代表PPID等）时，top将切换这些统计信息在屏幕上的显示。选择好需要的全部统计信息后，按下Enter键返回top的初始界面，现在它显示的是被选出的统计信息的当前值。在配置统计信息时，所有当前被选择的字段将会以大写形式显示在Current Field Order行，并在其名称旁出现一个星号（*）。请注意，大多数统计信息都是相同的，但名称略有变化。

清单2.10:

![2019-12-08-14-26-06.png](./images/2019-12-08-14-26-06.png)
￼
清单2.11展示了新的top输出模式，许多不同的统计信息进行了分类并显示在同一屏幕上。

清单2.11:

![2019-12-08-14-26-22.png](./images/2019-12-08-14-26-22.png)
￼
top v3.x为top提供了稍简洁的界面。它简化了top的某些方面，并提供了一个很好的“总结”信息屏，显示了系统中的许多资源消费者。

# procinfo（从/proc文件系统显示信息）

就像vmstat一样，procinfo也为系统整体信息特性提供总览。尽管它提供的有些信息与vmstat相同，但它还会给出CPU从每个设备接收的中断数量。其输出格式的易读性比vmstat稍微强一点，但却会占用更多的屏幕空间。

## CPU性能相关的选项

procinfo的调用命令行如下：

```
procinfo [-f] [-d] [-D] [-n sec] [-f file]
```
￼
表2-12描述了不同的选项，用于修改procinfo显示样本的输出和频率。

表2-12 procinfo命令行选项:

![2019-12-08-14-27-18.png](./images/2019-12-08-14-27-18.png)
￼
表2-13给出了procinfo收集的CPU统计信息。

表2-13 procinfo CPU 统计信息:

![2019-12-08-14-27-27.png](./images/2019-12-08-14-27-27.png)
￼
与vmstat以及top一样，procinfo是一个低开销的命令，适合于让其自行在控制台或屏幕窗口运行。它能够很好地反映系统的健康和性能。

## 用法示例

调用procinfo时不带任何命令选项将产生如清单2.12所示的输出。无参数，则procinfo仅显示一屏状态信息并退出。使用-n second选项让procinfo周期性地更新，其作用会更大。这能使你查看到系统性能的实时变化。

清单2.12:

![2019-12-08-14-45-35.png](./images/2019-12-08-14-45-35.png)
￼
![2019-12-08-14-29-30.png](./images/2019-12-08-14-29-30.png)
￼
如同你在清单2.12中所见，procinfo为系统提供了不错的总览。从用户、nice、系统和空闲时间，我们再次发现，系统不是很忙。一个值得注意的有趣现象是，procinfo表明系统空闲时间比其运行时间（用uptime表示）还要多。这是因为系统实际上有4个CPU，因此，对于一天的墙钟时间而言，CPU时间已经过去了四天。平均负载证明系统近期相对没有多少工作。在过去的时间里，平均而言，系统准备运行的进程还不到一个；平均负载为0.47意味着单个进程准备运行的时间只有47%。对于有四个CPU的系统来说，将会浪费大量的CPU能力。

procinfo还给我们提供了很好的视图来说明系统中的哪个设备导致了中断。可以看到显卡（nvidia）、硬盘控制器（ide0）、以太网设备（eth0）以及声卡（es1371）的中断数量相对较高。这些情况一般出现在台式工作站上。

procinfo的优势是将许多系统级性能统计信息放在一个屏幕里，让你能了解系统整体执行情况。它缺乏网络和磁盘性能的详细信息，但能为CPU和内存性能的统计信息提供良好的细节。一个可能很重要的限制是，CPU处于iowait、irq或softirq模式时procinfo不会进行报告。

# gnome-system-monitor

gnome-system-monitor在很多方面都可以说是top的图形化。它使你能以图形方式监控各个进程，并在显示图表的基础上观察系统负载。

## CPU性能相关的选项

gnome-system-monitor可以从Gnome菜单调用。（Red Hat 9及其以上版本中，选择菜单System Tools→System Monitor。）不过，它也可以用如下命令调用：
￼
```
gnome-system-monitor
```

gnome-system-monitor没有相关命令行选项来影响CPU性能测量。但是，有些显示的统计信息可以通过选择gnome-system-monitor的Edit→Preferences菜单项进行修改。

## 用法示例

当你启动gnome-system-monitor时，它会创建与图2-1相似的窗口。该窗口显示了特定进程使用的CPU和内存总量信息。它还显示了进程之间父/子关系的信息。
￼
图2-1

![2019-12-08-14-31-34.png](./images/2019-12-08-14-31-34.png)

图2-2显示了系统负载和内存使用率的图形视图。从这一点可以真正区分gnome-system-monitor与top。你可以很容易地查看系统当前状态，以及与之前状态的对比。
￼
图2-2

![2019-12-08-14-32-32.png](./images/2019-12-08-14-32-32.png)

gnome-system-monitor提供的数据图形视图能够更容易更迅速地确定系统状态及其行为随时间的变化。它还能更轻松地浏览系统级进程信息。

# mpstat（多处理器统计）

mpstat是一个相当简单的命令，向你展示随着时间变化的CPU行为。mpstat最大的优点是在统计信息的旁边显示时间，由此，你可以找出CPU使用率与时间的关系。
如果你有多个CPU或超线程CPU, mpstat还能够把CPU使用率按处理器进行区分，因此你可以发现与其他处理器相比，是否某个处理器做了更多的工作。你可以选择想要监控的单个处理器，也可以要求mpstat对所有的处理器都进行监控。

## CPU性能相关的选项

mpstat可以用如下命令行调用：

```
mpstat 
```
￼
和之前一样，delay指定了采样间隔，count指定了采样次数。表2-14解释了mpstat命令行选项的含义。
表2-14 mpstat命令行选项
￼
mpstat提供与其他CPU性能工具相似的信息，但是，它允许将信息按照特定系统中的单个处理器进行分类。表2-15给出了mpstat支持的选项。
表2-15 mpstat CPU统计信息
￼
mpstat是一种很好的工具，可以分类提供每个处理器的执行情况。由于mpstat给出了每个CPU的明细，因此你可以识别是否有哪个处理器正逐渐出现超负载情况。
2.2.6.2 用法示例
首先，我们要求mpstat显示处理器编号为0的CPU的统计信息，如清单2.13所示。
清单2.13
￼
清单2.14显示了对典型无负载超线程CPU使用相同命令产生的结果。你可以看到所有显示出来的CPU统计数据。输出中有个有趣的现象，即其中一个CPU似乎处理了所有的中断。如果系统有很重的I/O负载，而全部中断又都是由一个处理器处理，那么这可能就是瓶颈，因为一个CPU超负荷，而其他CPU则在等待。如果一个CPU忙于处理所有的中断以至于没有空闲时间，而与此同时，其他处理器则处于空闲状态，那么你可以用mpstat发现这种情况。
清单2.14
￼
mpstat可以用来确定CPU是否得到充分利用，以及使用情况是否相对均衡。通过观察每个CPU处理的中断数，有可能发现其中的不均衡。如何控制中断路由的详细信息参见Documentation/IRQ-affinity.txt下的内核源码。
2.2.7 sar（系统活动报告）
sar用另一种方法来收集系统数据。sar能有效地将收集到的系统性能数据记录到二进制文件，之后，可以重播这些文件。sar是一种低开销的、记录系统执行情况信息的方法。
sar命令可以用于记录性能信息，回放之前的记录信息，以及显示当前系统的实时信息。sar命令的输出可以进行格式化，使之易于导入数据库，或是输送给其他Linux命令进行处理。
2.2.7.1 CPU性能相关的选项
sar可以使用如下命令行调用：
￼
尽管sar的报告涉及Linux多个不同领域，其统计数据有两种不同的形式。一组统计数据是采样时的瞬时值。另一组则是自上一次采样后的变化值。表2-16解释了sar的命令行选项。
表2-16 sar命令行选项
￼
sar提供的系统级CPU性能统计数据集与我们在进程工具中看到的类似（名字不同）。如表2-17所